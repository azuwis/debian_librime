Description: Use the oldschool branch from the upstream.
 The oldschool branch doesn't depend on c++11 features, so we can use
 it to work around #754199 (FTBFS on armel: std::future is broken).
 .
 This patch can be reproduced by
 $ git diff rime-1.2 c5adf50  # on the upstream git repo
 .
 This patch is needed until #727621 is fixed.
 https://bugs.debian.org/727621
Origin: https://github.com/lotem/librime/commit/c5adf5030cca30bda4049906e002151c4c8ea273
diff --git a/.gitmodules b/.gitmodules
deleted file mode 100644
index e69de29..0000000
diff --git a/.lvimrc b/.lvimrc
index bbaa1e1..c00c4d6 100644
--- a/.lvimrc
+++ b/.lvimrc
@@ -1,4 +1,3 @@
 " a.vim configuration
 let g:alternateSearchPath = '../src,../../src,../include,../include/rime,reg:|\([/\\]\)include\1rime\1\([^/\\]*\)|\1src\1\2|,reg:|\([/\\]\)src\1\([^/\\]*\)|\1include\1rime\1\2|'
 let g:syntastic_cpp_include_dirs = [ 'thirdparty/include' ]
-let g:syntastic_cpp_compiler_options = '-std=c++11'
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 95cd24b..8f9405d 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -36,7 +36,7 @@ set(Boost_USE_MULTITHREADED ON)
 if(MSVC)
   set(Boost_USE_STATIC_RUNTIME ON)
 endif(MSVC)
-find_package(Boost 1.46.0 REQUIRED COMPONENTS filesystem regex signals system)
+find_package(Boost 1.47.0 REQUIRED COMPONENTS chrono filesystem regex signals system thread)
 if(Boost_FOUND)
   include_directories(${Boost_INCLUDE_DIRS})
   link_directories(${Boost_LIBRARY_DIRS})
@@ -107,9 +107,6 @@ if(MSVC)
   endif(MSVC10)
   add_definitions("/wd4244 /wd4996")
 endif(MSVC)
-if(UNIX)
-  add_definitions("-std=c++11")
-endif(UNIX)
 if(NOT BOOST_USE_CXX11)
   add_definitions("-DBOOST_NO_CXX11_SCOPED_ENUMS")
 endif()
diff --git a/include/rime/algo/algebra.h b/include/rime/algo/algebra.h
index daca49b..305eccb 100644
--- a/include/rime/algo/algebra.h
+++ b/include/rime/algo/algebra.h
@@ -20,7 +20,7 @@ namespace rime {
 class Calculation;
 class Schema;
 
-class Script : public std::map<std::string, std::vector<Spelling>> {
+class Script : public std::map<std::string, std::vector<Spelling> > {
  public:
   bool AddSyllable(const std::string& syllable);
   void Merge(const std::string& s,
@@ -37,7 +37,7 @@ class Projection {
   // {z, y, x} -> {a, b, c, d}
   bool Apply(Script* value);
  protected:
-  std::vector<shared_ptr<Calculation>> calculation_;
+  std::vector<shared_ptr<Calculation> > calculation_;
 };
 
 }  // namespace rime
diff --git a/include/rime/algo/calculus.h b/include/rime/algo/calculus.h
index 8568ab4..be92ec6 100644
--- a/include/rime/algo/calculus.h
+++ b/include/rime/algo/calculus.h
@@ -19,10 +19,10 @@ namespace rime {
 
 class Calculation {
  public:
-  using Factory = Calculation* (const std::vector<std::string>& args);
+  typedef Calculation* Factory(const std::vector<std::string>& args);
 
-  Calculation() = default;
-  virtual ~Calculation() = default;
+  Calculation() {}
+  virtual ~Calculation() {}
   virtual bool Apply(Spelling* spelling) = 0;
   virtual bool addition() { return true; }
   virtual bool deletion() { return true; }
diff --git a/include/rime/algo/encoder.h b/include/rime/algo/encoder.h
index a233974..05ecdc3 100644
--- a/include/rime/algo/encoder.h
+++ b/include/rime/algo/encoder.h
@@ -23,8 +23,8 @@ class RawCode : public std::vector<std::string> {
 
 class PhraseCollector {
  public:
-  PhraseCollector() = default;
-  virtual ~PhraseCollector() = default;
+  PhraseCollector() {}
+  virtual ~PhraseCollector() {}
 
   virtual void CreateEntry(const std::string& phrase,
                            const std::string& code_str,
@@ -39,7 +39,7 @@ class Config;
 class Encoder {
  public:
   Encoder(PhraseCollector* collector) : collector_(collector) {}
-  virtual ~Encoder() = default;
+  virtual ~Encoder() {}
 
   virtual bool LoadSettings(Config* config) {
     return false;
diff --git a/include/rime/algo/spelling.h b/include/rime/algo/spelling.h
index b78e8a8..f8cbc28 100644
--- a/include/rime/algo/spelling.h
+++ b/include/rime/algo/spelling.h
@@ -17,19 +17,18 @@ enum SpellingType { kNormalSpelling, kFuzzySpelling,
                     kInvalidSpelling };
 
 struct SpellingProperties {
-  SpellingType type = kNormalSpelling;
-  size_t end_pos = 0;
-  double credibility = 1.0;
+  SpellingType type;
+  size_t end_pos;
+  double credibility;
   std::string tips;
+  SpellingProperties() : type(kNormalSpelling), end_pos(0), credibility(1.0) {}
 };
 
 struct Spelling {
   std::string str;
   SpellingProperties properties;
-
-  Spelling() = default;
-  Spelling(const std::string& _str) : str(_str) {}
-
+  Spelling() {}
+  Spelling(const std::string& _str) : str(_str), properties() {}
   bool operator== (const Spelling& other) { return str == other.str; }
   bool operator< (const Spelling& other) { return str < other.str; }
 };
diff --git a/include/rime/algo/syllabifier.h b/include/rime/algo/syllabifier.h
index 5beea6d..ee10f9e 100644
--- a/include/rime/algo/syllabifier.h
+++ b/include/rime/algo/syllabifier.h
@@ -17,28 +17,32 @@ namespace rime {
 
 class Prism;
 
-using SyllableId = int32_t;
+typedef int32_t SyllableId;
 
-using SpellingMap = std::map<SyllableId, SpellingProperties>;
-using VertexMap = std::map<size_t, SpellingType>;
-using EndVertexMap = std::map<size_t, SpellingMap>;
-using EdgeMap = std::map<size_t, EndVertexMap>;
+typedef std::map<SyllableId, SpellingProperties> SpellingMap;
+typedef std::map<size_t, SpellingType> VertexMap;
+typedef std::map<size_t, SpellingMap> EndVertexMap;
+typedef std::map<size_t, EndVertexMap> EdgeMap;
 
-using SpellingPropertiesList = std::vector<const SpellingProperties*>;
-using SpellingIndex = std::map<SyllableId, SpellingPropertiesList>;
-using SpellingIndices = std::map<size_t, SpellingIndex>;
+typedef std::vector<const SpellingProperties*> SpellingPropertiesList;
+typedef std::map<SyllableId, SpellingPropertiesList> SpellingIndex;
+typedef std::map<size_t, SpellingIndex> SpellingIndices;
 
 struct SyllableGraph {
-  size_t input_length = 0;
-  size_t interpreted_length = 0;
+  size_t input_length;
+  size_t interpreted_length;
   VertexMap vertices;
   EdgeMap edges;
   SpellingIndices indices;
+  SyllableGraph() : input_length(0), interpreted_length(0) {}
 };
 
 class Syllabifier {
  public:
-  Syllabifier() = default;
+  Syllabifier()
+      : enable_completion_(false),
+        strict_spelling_(false) {
+  }
   explicit Syllabifier(const std::string &delimiters,
                        bool enable_completion = false,
                        bool strict_spelling = false)
@@ -57,8 +61,8 @@ class Syllabifier {
   void Transpose(SyllableGraph* graph);
 
   std::string delimiters_;
-  bool enable_completion_ = false;
-  bool strict_spelling_ = false;
+  bool enable_completion_;
+  bool strict_spelling_;
 };
 
 }  // namespace rime
diff --git a/include/rime/candidate.h b/include/rime/candidate.h
index 108579d..d643496 100644
--- a/include/rime/candidate.h
+++ b/include/rime/candidate.h
@@ -15,17 +15,17 @@ namespace rime {
 
 class Candidate {
  public:
-  Candidate() = default;
+  Candidate() : type_(), start_(0), end_(0), quality_(0.) {}
   Candidate(const std::string type,
             size_t start,
             size_t end,
             double quality = 0.)
       : type_(type), start_(start), end_(end), quality_(quality) {}
-  virtual ~Candidate() = default;
+  virtual ~Candidate() {}
 
   static shared_ptr<Candidate>
   GetGenuineCandidate(const shared_ptr<Candidate>& cand);
-  static std::vector<shared_ptr<Candidate>>
+  static std::vector<shared_ptr<Candidate> >
   GetGenuineCandidates(const shared_ptr<Candidate>& cand);
 
   // recognized by translators in learning phase
@@ -42,31 +42,31 @@ class Candidate {
   // text shown in the preedit area, replacing input string (optional)
   virtual std::string preedit() const { return std::string(); }
 
-  void set_type(const std::string& type) { type_ = type; }
+  void set_type(const std::string &type) { type_ = type; }
   void set_start(size_t start) { start_ = start; }
   void set_end(size_t end) { end_ = end; }
   void set_quality(double quality) { quality_ = quality; }
 
  private:
   std::string type_;
-  size_t start_ = 0;
-  size_t end_ = 0;
-  double quality_ = 0.;
+  size_t start_;
+  size_t end_;
+  double quality_;
 };
 
-using CandidateList = std::vector<shared_ptr<Candidate>>;
+typedef std::vector<shared_ptr<Candidate> > CandidateList;
 
 // useful implimentations
 
 class SimpleCandidate : public Candidate {
  public:
-  SimpleCandidate() = default;
+  SimpleCandidate() : Candidate() {}
   SimpleCandidate(const std::string type,
                   size_t start,
                   size_t end,
-                  const std::string& text,
-                  const std::string& comment = std::string(),
-                  const std::string& preedit = std::string())
+                  const std::string &text,
+                  const std::string &comment = std::string(),
+                  const std::string &preedit = std::string())
       : Candidate(type, start, end),
       text_(text), comment_(comment), preedit_(preedit) {}
 
@@ -74,9 +74,9 @@ class SimpleCandidate : public Candidate {
   std::string comment() const { return comment_; }
   std::string preedit() const { return preedit_; }
 
-  void set_text(const std::string& text) { text_ = text; }
-  void set_comment(const std::string& comment) { comment_ = comment; }
-  void set_preedit(const std::string& preedit) { preedit_ = preedit; }
+  void set_text(const std::string &text) { text_ = text; }
+  void set_comment(const std::string &comment) { comment_ = comment; }
+  void set_preedit(const std::string &preedit) { preedit_ = preedit; }
 
  protected:
   std::string text_;
@@ -86,10 +86,10 @@ class SimpleCandidate : public Candidate {
 
 class ShadowCandidate : public Candidate {
  public:
-  ShadowCandidate(const shared_ptr<Candidate>& item,
-                  const std::string& type,
-                  const std::string& text = std::string(),
-                  const std::string& comment = std::string())
+  ShadowCandidate(const shared_ptr<Candidate> &item,
+                  const std::string &type,
+                  const std::string &text = std::string(),
+                  const std::string &comment = std::string())
       : Candidate(type, item->start(), item->end(), item->quality()),
         text_(text), comment_(comment),
         item_(item) {}
@@ -114,10 +114,10 @@ class ShadowCandidate : public Candidate {
 
 class UniquifiedCandidate : public Candidate {
  public:
-  UniquifiedCandidate(const shared_ptr<Candidate>& item,
-                      const std::string& type,
-                      const std::string& text = std::string(),
-                      const std::string& comment = std::string())
+  UniquifiedCandidate(const shared_ptr<Candidate> &item,
+                      const std::string &type,
+                      const std::string &text = std::string(),
+                      const std::string &comment = std::string())
       : Candidate(type, item->start(), item->end(), item->quality()),
         text_(text), comment_(comment) {
     Append(item);
@@ -135,7 +135,7 @@ class UniquifiedCandidate : public Candidate {
     return !items_.empty() ? items_.front()->preedit() : std::string();
   }
 
-  void Append(shared_ptr<Candidate> item) {
+  void Append(const shared_ptr<Candidate> &item) {
     items_.push_back(item);
     if (quality() < item->quality())
       set_quality(item->quality());
diff --git a/include/rime/common.h b/include/rime/common.h
index d997bd9..f6092c5 100644
--- a/include/rime/common.h
+++ b/include/rime/common.h
@@ -7,11 +7,12 @@
 #ifndef RIME_COMMON_H_
 #define RIME_COMMON_H_
 
-#include <memory>
-#include <utility>
-#define BOOST_BIND_NO_PLACEHOLDERS
+#include <cstdlib>
+#include <string>
 #include <boost/signals2/connection.hpp>
 #include <boost/signals2/signal.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/make_shared.hpp>
 
 #ifdef RIME_ENABLE_LOGGING
 #include <glog/logging.h>
@@ -24,13 +25,14 @@ namespace rime {
 using boost::signals2::connection;
 using boost::signals2::signal;
 
-using std::unique_ptr;
-using std::shared_ptr;
-using std::weak_ptr;
+using boost::scoped_ptr;
+using boost::shared_ptr;
+using boost::weak_ptr;
+using boost::make_shared;
 
 template <class A, class B>
 shared_ptr<A> As(const B& ptr) {
-  return std::dynamic_pointer_cast<A>(ptr);
+  return boost::dynamic_pointer_cast<A>(ptr);
 }
 
 template <class A, class B>
@@ -38,9 +40,14 @@ bool Is(const B& ptr) {
   return bool(As<A, B>(ptr));
 }
 
-template <class T, class... Args>
-inline shared_ptr<T> New(Args&&... args) {
-  return std::make_shared<T>(std::forward<Args>(args)...);
+template <class T>
+shared_ptr<T> New() {
+  return boost::make_shared<T>();
+}
+
+template <class T, class A>
+shared_ptr<T> New(const A& a) {
+  return boost::make_shared<T>(a);
 }
 
 }  // namespace rime
diff --git a/include/rime/component.h b/include/rime/component.h
index 23ed0a4..3ff4460 100644
--- a/include/rime/component.h
+++ b/include/rime/component.h
@@ -15,13 +15,13 @@ namespace rime {
 
 class ComponentBase {
  public:
-  ComponentBase() = default;
-  virtual ~ComponentBase() = default;
+  ComponentBase() {}
+  virtual ~ComponentBase() {}
 };
 
 template <class T, class Arg>
 struct Class {
-  using Initializer = Arg;
+  typedef Arg Initializer;
 
   class Component : public ComponentBase {
    public:
diff --git a/include/rime/composition.h b/include/rime/composition.h
index 9151d5a..c8a3d60 100644
--- a/include/rime/composition.h
+++ b/include/rime/composition.h
@@ -14,17 +14,16 @@ namespace rime {
 
 struct Preedit {
   std::string text;
-  size_t caret_pos = 0;
-  size_t sel_start = 0;
-  size_t sel_end = 0;
+  size_t caret_pos;
+  size_t sel_start;
+  size_t sel_end;
 };
 
 class Composition : public Segmentation {
  public:
-  Composition() = default;
-
+  Composition();
   bool HasFinishedComposition() const;
-  void GetPreedit(Preedit* preedit) const;
+  void GetPreedit(Preedit *preedit) const;
   std::string GetCommitText() const;
   std::string GetScriptText() const;
   std::string GetDebugText() const;
diff --git a/include/rime/config.h b/include/rime/config.h
index 5f8e934..f14dd1e 100644
--- a/include/rime/config.h
+++ b/include/rime/config.h
@@ -10,7 +10,7 @@
 #include <iostream>
 #include <map>
 #include <string>
-#include <type_traits>
+#include <boost/type_traits.hpp>
 #include <rime/common.h>
 #include <rime/component.h>
 
@@ -21,18 +21,19 @@ class ConfigItem {
  public:
   enum ValueType { kNull, kScalar, kList, kMap };
 
-  ConfigItem() = default;  // null
-  virtual ~ConfigItem() = default;
+  // construct a null item
+  ConfigItem() : type_(kNull) {}
+  virtual ~ConfigItem() {}
 
   ValueType type() const { return type_; }
 
  protected:
   ConfigItem(ValueType type) : type_(type) {}
 
-  ValueType type_ = kNull;
+  ValueType type_;
 };
 
-using ConfigItemPtr = shared_ptr<ConfigItem>;
+typedef shared_ptr<ConfigItem> ConfigItemPtr;
 
 class ConfigValue : public ConfigItem {
  public:
@@ -40,19 +41,19 @@ class ConfigValue : public ConfigItem {
   ConfigValue(bool value);
   ConfigValue(int value);
   ConfigValue(double value);
-  ConfigValue(const char* value);
-  ConfigValue(const std::string& value);
+  ConfigValue(const char *value);
+  ConfigValue(const std::string &value);
 
   // schalar value accessors
-  bool GetBool(bool* value) const;
-  bool GetInt(int* value) const;
-  bool GetDouble(double* value) const;
-  bool GetString(std::string* value) const;
+  bool GetBool(bool *value) const;
+  bool GetInt(int *value) const;
+  bool GetDouble(double *value) const;
+  bool GetString(std::string *value) const;
   bool SetBool(bool value);
   bool SetInt(int value);
   bool SetDouble(double value);
-  bool SetString(const char* value);
-  bool SetString(const std::string& value);
+  bool SetString(const char *value);
+  bool SetString(const std::string &value);
 
   const std::string& str() const { return value_; }
 
@@ -60,12 +61,12 @@ class ConfigValue : public ConfigItem {
   std::string value_;
 };
 
-using ConfigValuePtr = shared_ptr<ConfigValue>;
+typedef shared_ptr<ConfigValue> ConfigValuePtr;
 
 class ConfigList : public ConfigItem {
  public:
-  using Sequence = std::vector<ConfigItemPtr>;
-  using Iterator = Sequence::iterator;
+  typedef std::vector<ConfigItemPtr> Sequence;
+  typedef Sequence::iterator Iterator;
 
   ConfigList() : ConfigItem(kList) {}
   ConfigItemPtr GetAt(size_t i) const;
@@ -84,19 +85,19 @@ class ConfigList : public ConfigItem {
   Sequence seq_;
 };
 
-using ConfigListPtr = shared_ptr<ConfigList>;
+typedef shared_ptr<ConfigList> ConfigListPtr;
 
 // limitation: map keys have to be strings, preferably alphanumeric
 class ConfigMap : public ConfigItem {
  public:
-  using Map = std::map<std::string, ConfigItemPtr>;
-  using Iterator = Map::iterator;
+  typedef std::map<std::string, ConfigItemPtr> Map;
+  typedef Map::iterator Iterator;
 
   ConfigMap() : ConfigItem(kMap) {}
-  bool HasKey(const std::string& key) const;
-  ConfigItemPtr Get(const std::string& key) const;
-  ConfigValuePtr GetValue(const std::string& key) const;
-  bool Set(const std::string& key, ConfigItemPtr element);
+  bool HasKey(const std::string &key) const;
+  ConfigItemPtr Get(const std::string &key) const;
+  ConfigValuePtr GetValue(const std::string &key) const;
+  bool Set(const std::string &key, const ConfigItemPtr &element);
   bool Clear();
 
   Iterator begin();
@@ -106,7 +107,7 @@ class ConfigMap : public ConfigItem {
   Map map_;
 };
 
-using ConfigMapPtr = shared_ptr<ConfigMap>;
+typedef shared_ptr<ConfigMap> ConfigMapPtr;
 
 class ConfigData;
 class ConfigListEntryRef;
@@ -137,7 +138,7 @@ class ConfigItemRef {
   void Clear();
 
   // list
-  bool Append(ConfigItemPtr item);
+  bool Append(const ConfigItemPtr& item);
   size_t size() const;
   // map
   bool HasKey(const std::string& key) const;
@@ -147,7 +148,7 @@ class ConfigItemRef {
 
  protected:
   virtual ConfigItemPtr GetItem() const = 0;
-  virtual void SetItem(ConfigItemPtr item) = 0;
+  virtual void SetItem(const ConfigItemPtr& item) = 0;
 
   shared_ptr<ConfigData> data_;
 };
@@ -155,12 +156,12 @@ class ConfigItemRef {
 namespace {
 
 template <class T>
-ConfigItemPtr AsConfigItem(const T& a, const std::false_type&) {
+ConfigItemPtr AsConfigItem(const T& a, const boost::false_type&) {
   return New<ConfigValue>(a);
 };
 
 template <class T>
-ConfigItemPtr AsConfigItem(const T& a, const std::true_type&) {
+ConfigItemPtr AsConfigItem(const T& a, const boost::true_type&) {
   return a;
 };
 
@@ -168,20 +169,20 @@ ConfigItemPtr AsConfigItem(const T& a, const std::true_type&) {
 
 class ConfigListEntryRef : public ConfigItemRef {
  public:
-  ConfigListEntryRef(shared_ptr<ConfigData> data,
-                     ConfigListPtr list, size_t index)
+  ConfigListEntryRef(const shared_ptr<ConfigData>& data,
+                     const ConfigListPtr& list, size_t index)
       : ConfigItemRef(data), list_(list), index_(index) {
   }
   template <class T>
   ConfigListEntryRef& operator= (const T& a) {
-    SetItem(AsConfigItem(a, std::is_convertible<T, ConfigItemPtr>()));
+    SetItem(AsConfigItem(a, boost::is_convertible<T, ConfigItemPtr>()));
     return *this;
   }
  protected:
   ConfigItemPtr GetItem() const {
     return list_->GetAt(index_);
   }
-  void SetItem(ConfigItemPtr item) {
+  void SetItem(const ConfigItemPtr& item) {
     list_->SetAt(index_, item);
     set_modified();
   }
@@ -192,20 +193,20 @@ class ConfigListEntryRef : public ConfigItemRef {
 
 class ConfigMapEntryRef : public ConfigItemRef {
  public:
-  ConfigMapEntryRef(shared_ptr<ConfigData> data,
-                    ConfigMapPtr map, const std::string& key)
+  ConfigMapEntryRef(const shared_ptr<ConfigData>& data,
+                    const ConfigMapPtr& map, const std::string& key)
       : ConfigItemRef(data), map_(map), key_(key) {
   }
   template <class T>
   ConfigMapEntryRef& operator= (const T& a) {
-    SetItem(AsConfigItem(a, std::is_convertible<T, ConfigItemPtr>()));
+    SetItem(AsConfigItem(a, boost::is_convertible<T, ConfigItemPtr>()));
     return *this;
   }
  protected:
   ConfigItemPtr GetItem() const {
     return map_->Get(key_);
   }
-  void SetItem(ConfigItemPtr item) {
+  void SetItem(const ConfigItemPtr& item) {
     map_->Set(key_, item);
     set_modified();
   }
@@ -255,32 +256,32 @@ class Config : public Class<Config, const std::string&>, public ConfigItemRef {
   ConfigMapPtr GetMap(const std::string& key);
 
   // setters
-  bool SetBool(const std::string& key, bool value);
-  bool SetInt(const std::string& key, int value);
-  bool SetDouble(const std::string& key, double value);
-  bool SetString(const std::string& key, const char* value);
-  bool SetString(const std::string& key, const std::string& value);
+  bool SetBool(const std::string &key, bool value);
+  bool SetInt(const std::string &key, int value);
+  bool SetDouble(const std::string &key, double value);
+  bool SetString(const std::string &key, const char *value);
+  bool SetString(const std::string &key, const std::string &value);
   // setter for adding / replacing items to the tree
-  bool SetItem(const std::string& key, ConfigItemPtr item);
+  bool SetItem(const std::string &key, const ConfigItemPtr &item);
 
   template <class T>
   Config& operator= (const T& a) {
-    SetItem(AsConfigItem(a, std::is_convertible<T, ConfigItemPtr>()));
+    SetItem(AsConfigItem(a, boost::is_convertible<T, ConfigItemPtr>()));
     return *this;
   }
 
  protected:
   ConfigItemPtr GetItem() const;
-  void SetItem(ConfigItemPtr item);
+  void SetItem(const ConfigItemPtr& item);
  };
 
 // ConfigComponent class
 
 class ConfigComponent : public Config::Component {
  public:
-  ConfigComponent(const std::string& pattern) : pattern_(pattern) {}
-  Config* Create(const std::string& config_id);
-  std::string GetConfigFilePath(const std::string& config_id);
+  ConfigComponent(const std::string &pattern) : pattern_(pattern) {}
+  Config* Create(const std::string &config_id);
+  std::string GetConfigFilePath(const std::string &config_id);
   const std::string& pattern() const { return pattern_; }
 
  private:
diff --git a/include/rime/context.h b/include/rime/context.h
index 92193e6..dc72b25 100644
--- a/include/rime/context.h
+++ b/include/rime/context.h
@@ -20,11 +20,11 @@ struct Preedit;
 
 class Context {
  public:
-  using Notifier = signal<void (Context* ctx)>;
-  using OptionUpdateNotifier =
-      signal<void (Context* ctx, const std::string& option)>;
-  using KeyEventNotifier =
-      signal<void (Context* ctx, const KeyEvent& key_event)>;
+  typedef signal<void (Context *ctx)> Notifier;
+  typedef signal<void (Context *ctx, const std::string& option)>
+  OptionUpdateNotifier;
+  typedef signal<void (Context *ctx, const KeyEvent& key_event)>
+  KeyEventNotifier;
 
   Context();
   ~Context();
@@ -32,7 +32,7 @@ class Context {
   bool Commit();
   std::string GetCommitText() const;
   std::string GetScriptText() const;
-  void GetPreedit(Preedit* preedit, bool soft_cursor = false) const;
+  void GetPreedit(Preedit *preedit, bool soft_cursor = false) const;
   bool IsComposing() const;
   bool HasMenu() const;
 
@@ -55,22 +55,22 @@ class Context {
   bool ClearNonConfirmedComposition();
   bool RefreshNonConfirmedComposition();
 
-  void set_input(const std::string& value);
+  void set_input(const std::string &value);
   const std::string& input() const { return input_; }
 
   void set_caret_pos(size_t caret_pos);
   size_t caret_pos() const { return caret_pos_; }
 
-  void set_composition(Composition* comp);
+  void set_composition(Composition *comp);
   Composition* composition();
   const Composition* composition() const;
   CommitHistory& commit_history() { return commit_history_; }
   const CommitHistory& commit_history() const { return commit_history_; }
 
-  void set_option(const std::string& name, bool value);
-  bool get_option(const std::string& name) const;
-  void set_property(const std::string& name, const std::string& value);
-  std::string get_property(const std::string& name) const;
+  void set_option(const std::string &name, bool value);
+  bool get_option(const std::string &name) const;
+  void set_property(const std::string &name, const std::string& value);
+  std::string get_property(const std::string &name) const;
   // options and properties starting with '_' are local to schema;
   // others are session scoped.
   void ClearTransientOptions();
@@ -88,8 +88,8 @@ class Context {
 
  private:
   std::string input_;
-  size_t caret_pos_ = 0;
-  unique_ptr<Composition> composition_;
+  size_t caret_pos_;
+  scoped_ptr<Composition> composition_;
   CommitHistory commit_history_;
   std::map<std::string, bool> options_;
   std::map<std::string, std::string> properties_;
diff --git a/include/rime/deployer.h b/include/rime/deployer.h
index 92f0563..e991abc 100644
--- a/include/rime/deployer.h
+++ b/include/rime/deployer.h
@@ -7,11 +7,10 @@
 #ifndef RIME_DEPLOYER_H_
 #define RIME_DEPLOYER_H_
 
-#include <future>
-#include <mutex>
 #include <queue>
 #include <string>
 #include <boost/any.hpp>
+#include <boost/thread.hpp>
 #include <rime/common.h>
 #include <rime/component.h>
 #include <rime/messenger.h>
@@ -20,12 +19,12 @@ namespace rime {
 
 class Deployer;
 
-using TaskInitializer = boost::any;
+typedef boost::any TaskInitializer;
 
 class DeploymentTask : public Class<DeploymentTask, TaskInitializer> {
  public:
-  DeploymentTask() = default;
-  virtual ~DeploymentTask() = default;
+  DeploymentTask() {}
+  virtual ~DeploymentTask() {}
 
   virtual bool Run(Deployer* deployer) = 0;
 };
@@ -49,7 +48,8 @@ class Deployer : public Messenger {
                TaskInitializer arg = TaskInitializer());
   bool ScheduleTask(const std::string& task_name,
                     TaskInitializer arg = TaskInitializer());
-  void ScheduleTask(shared_ptr<DeploymentTask> task);
+
+  void ScheduleTask(const shared_ptr<DeploymentTask>& task);
   shared_ptr<DeploymentTask> NextTask();
   bool HasPendingTasks();
 
@@ -65,10 +65,10 @@ class Deployer : public Messenger {
   std::string user_data_sync_dir() const;
 
  private:
-  std::queue<shared_ptr<DeploymentTask>> pending_tasks_;
-  std::mutex mutex_;
-  std::future<void> work_;
-  bool maintenance_mode_ = false;
+  std::queue<shared_ptr<DeploymentTask> > pending_tasks_;
+  boost::mutex mutex_;
+  boost::thread work_thread_;
+  bool maintenance_mode_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/db.h b/include/rime/dict/db.h
index 23b7869..e252a13 100644
--- a/include/rime/dict/db.h
+++ b/include/rime/dict/db.h
@@ -15,10 +15,9 @@ namespace rime {
 
 class DbAccessor {
  public:
-  DbAccessor() = default;
-  explicit DbAccessor(const std::string& prefix)
-      : prefix_(prefix) {}
-  virtual ~DbAccessor() = default;
+  DbAccessor();
+  explicit DbAccessor(const std::string& prefix);
+  virtual ~DbAccessor();
 
   virtual bool Reset() = 0;
   virtual bool Jump(const std::string &key) = 0;
@@ -34,7 +33,7 @@ class DbAccessor {
 class Db : public Class<Db, const std::string&> {
  public:
   explicit Db(const std::string& name);
-  virtual ~Db() = default;
+  virtual ~Db();
 
   bool Exists() const;
   bool Remove();
@@ -68,26 +67,26 @@ class Db : public Class<Db, const std::string&> {
  protected:
   std::string name_;
   std::string file_name_;
-  bool loaded_ = false;
-  bool readonly_ = false;
-  bool disabled_ = false;
+  bool loaded_;
+  bool readonly_;
+  bool disabled_;
 };
 
 class Transactional {
  public:
-  Transactional() = default;
-  virtual ~Transactional() = default;
+  Transactional() : in_transaction_(false) {}
+  virtual ~Transactional() {}
   virtual bool BeginTransaction() { return false; }
   virtual bool AbortTransaction() { return false; }
   virtual bool CommitTransaction() { return false; }
   bool in_transaction() const { return in_transaction_; }
  protected:
-  bool in_transaction_ = false;
+  bool in_transaction_;
 };
 
 class Recoverable {
  public:
-  virtual ~Recoverable() = default;
+  virtual ~Recoverable() {}
   virtual bool Recover() = 0;
 };
 
diff --git a/include/rime/dict/db_utils.h b/include/rime/dict/db_utils.h
index 6735015..3b582bd 100644
--- a/include/rime/dict/db_utils.h
+++ b/include/rime/dict/db_utils.h
@@ -14,7 +14,7 @@ namespace rime {
 
 class Sink {
  public:
-  virtual ~Sink() = default;
+  virtual ~Sink() {}
   virtual bool MetaPut(const std::string& key, const std::string& value) = 0;
   virtual bool Put(const std::string& key, const std::string& value) = 0;
 
@@ -24,7 +24,7 @@ class Sink {
 
 class Source {
  public:
-  virtual ~Source() = default;
+  virtual ~Source() {}
   virtual bool MetaGet(std::string* key, std::string* value) = 0;
   virtual bool Get(std::string* key, std::string* value) = 0;
 
diff --git a/include/rime/dict/dict_compiler.h b/include/rime/dict/dict_compiler.h
index 2f04ece..6ec6ad0 100644
--- a/include/rime/dict/dict_compiler.h
+++ b/include/rime/dict/dict_compiler.h
@@ -7,9 +7,9 @@
 #ifndef RIME_DICT_COMPILER_H_
 #define RIME_DICT_COMPILER_H_
 
-#include <functional>
 #include <string>
 #include <vector>
+#include <boost/function.hpp>
 #include <rime/common.h>
 
 namespace rime {
@@ -21,8 +21,8 @@ class ReverseDb;
 class DictSettings;
 
 // return found dict file path, otherwize return empty string
-using DictFileFinder =
-    std::function<const std::string (const std::string& file_name)>;
+typedef boost::function<const std::string (const std::string& file_name)>
+DictFileFinder;
 
 class DictCompiler {
  public:
@@ -51,7 +51,7 @@ class DictCompiler {
   std::string dict_name_;
   shared_ptr<Prism> prism_;
   shared_ptr<Table> table_;
-  int options_ = 0;
+  int options_;
   DictFileFinder dict_file_finder_;
 };
 
diff --git a/include/rime/dict/dictionary.h b/include/rime/dict/dictionary.h
index d49dcae..53b886b 100644
--- a/include/rime/dict/dictionary.h
+++ b/include/rime/dict/dictionary.h
@@ -23,36 +23,37 @@ namespace dictionary {
 
 struct Chunk {
   Code code;
-  const table::Entry* entries = nullptr;
-  size_t size = 0;
-  size_t cursor = 0;
+  const table::Entry *entries;
+  size_t size;
+  size_t cursor;
   std::string remaining_code;  // for predictive queries
-  double credibility = 1.0;
+  double credibility;
 
-  Chunk() = default;
-  Chunk(const Code& c, const table::Entry* e, double cr = 1.0)
+  Chunk() : entries(NULL), size(0), cursor(0), credibility(1.0) {}
+  Chunk(const Code &c, const table::Entry *e, double cr = 1.0)
       : code(c), entries(e), size(1), cursor(0), credibility(cr) {}
-  Chunk(const TableAccessor& a, double cr = 1.0)
-      : Chunk(a, std::string(), cr) {}
-  Chunk(const TableAccessor& a, const std::string& r, double cr = 1.0)
+  Chunk(const TableAccessor &a, double cr = 1.0)
+      : code(a.index_code()), entries(a.entry()),
+        size(a.remaining()), cursor(0), credibility(cr) {}
+  Chunk(const TableAccessor &a, const std::string &r, double cr = 1.0)
       : code(a.index_code()), entries(a.entry()),
         size(a.remaining()), cursor(0), remaining_code(r), credibility(cr) {}
 };
 
-bool compare_chunk_by_leading_element(const Chunk& a, const Chunk& b);
+bool compare_chunk_by_leading_element(const Chunk &a, const Chunk &b);
 
 }  // namespace dictionary
 
 class DictEntryIterator : protected std::list<dictionary::Chunk>,
                           public DictEntryFilterBinder {
  public:
-  using Base = std::list<dictionary::Chunk>;
+  typedef std::list<dictionary::Chunk> Base;
 
   DictEntryIterator();
-  DictEntryIterator(const DictEntryIterator& other);
-  DictEntryIterator& operator= (DictEntryIterator& other);
+  DictEntryIterator(const DictEntryIterator &other);
+  DictEntryIterator& operator= (DictEntryIterator &other);
 
-  void AddChunk(dictionary::Chunk&& chunk, Table* table);
+  void AddChunk(const dictionary::Chunk &chunk, Table* table);
   void Sort();
   shared_ptr<DictEntry> Peek();
   bool Next();
@@ -79,26 +80,26 @@ struct Ticket;
 
 class Dictionary : public Class<Dictionary, const Ticket&> {
  public:
-  Dictionary(const std::string& name,
-             const shared_ptr<Table>& table,
-             const shared_ptr<Prism>& prism);
+  Dictionary(const std::string &name,
+             const shared_ptr<Table> &table,
+             const shared_ptr<Prism> &prism);
   virtual ~Dictionary();
 
   bool Exists() const;
   bool Remove();
   bool Load();
 
-  shared_ptr<DictEntryCollector> Lookup(const SyllableGraph& syllable_graph,
+  shared_ptr<DictEntryCollector> Lookup(const SyllableGraph &syllable_graph,
                                         size_t start_pos,
                                         double initial_credibility = 1.0);
   // if predictive is true, do an expand search with limit,
   // otherwise do an exact match.
   // return num of matching keys.
-  size_t LookupWords(DictEntryIterator* result,
-                     const std::string& str_code,
+  size_t LookupWords(DictEntryIterator *result,
+                     const std::string &str_code,
                      bool predictive, size_t limit = 0);
   // translate syllable id sequence to string code
-  bool Decode(const Code& code, std::vector<std::string>* result);
+  bool Decode(const Code &code, std::vector<std::string>* result);
 
   const std::string& name() const { return name_; }
   bool loaded() const;
@@ -116,12 +117,12 @@ class DictionaryComponent : public Dictionary::Component {
  public:
   DictionaryComponent();
   Dictionary* Create(const Ticket& ticket);
-  Dictionary* CreateDictionaryWithName(const std::string& dict_name,
-                                       const std::string& prism_name);
+  Dictionary* CreateDictionaryWithName(const std::string &dict_name,
+                                       const std::string &prism_name);
 
  private:
-  std::map<std::string, weak_ptr<Prism>> prism_map_;
-  std::map<std::string, weak_ptr<Table>> table_map_;
+  std::map<std::string, weak_ptr<Prism> > prism_map_;
+  std::map<std::string, weak_ptr<Table> > table_map_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/entry_collector.h b/include/rime/dict/entry_collector.h
index ea2fd6a..80c5b2c 100644
--- a/include/rime/dict/entry_collector.h
+++ b/include/rime/dict/entry_collector.h
@@ -26,11 +26,11 @@ struct RawDictEntry {
 };
 
 // code -> weight
-using WeightMap = std::map<std::string, double>;
+typedef std::map<std::string, double> WeightMap;
 // word -> { code -> weight }
-using WordMap = std::map<std::string, WeightMap>;
+typedef std::map<std::string, WeightMap> WordMap;
 // [ (word, weight), ... ]
-using EncodeQueue = std::queue<std::pair<std::string, std::string>>;
+typedef std::queue<std::pair<std::string, std::string> > EncodeQueue;
 
 class PresetVocabulary;
 class DictSettings;
@@ -39,7 +39,7 @@ class EntryCollector : public PhraseCollector {
  public:
   Syllabary syllabary;
   std::vector<RawDictEntry> entries;
-  size_t num_entries = 0;
+  size_t num_entries;
   ReverseLookupTable stems;
 
  public:
@@ -65,8 +65,8 @@ class EntryCollector : public PhraseCollector {
   void Finish();
 
  protected:
-  unique_ptr<PresetVocabulary> preset_vocabulary;
-  unique_ptr<Encoder> encoder;
+  scoped_ptr<PresetVocabulary> preset_vocabulary;
+  scoped_ptr<Encoder> encoder;
   EncodeQueue encode_queue;
   std::set<std::string/* word */> collection;
   WordMap words;
diff --git a/include/rime/dict/mapped_file.h b/include/rime/dict/mapped_file.h
index 32aabcf..a0884c9 100644
--- a/include/rime/dict/mapped_file.h
+++ b/include/rime/dict/mapped_file.h
@@ -20,15 +20,17 @@ namespace rime {
 template <class T = char, class Offset = int32_t>
 class OffsetPtr {
  public:
-  OffsetPtr() = default;
+  OffsetPtr() : offset_(0) {}
   OffsetPtr(Offset offset) : offset_(offset) {}
-  OffsetPtr(const T* ptr) : OffsetPtr(to_offset(ptr)) {}
-  OffsetPtr(const OffsetPtr<T>& ptr) : OffsetPtr(ptr.get()) {}
-  OffsetPtr<T>& operator= (const OffsetPtr<T>& ptr) {
+  OffsetPtr(const OffsetPtr<T> &ptr)
+      : offset_(to_offset(ptr.get())) {}
+  OffsetPtr(const T *ptr)
+      : offset_(to_offset(ptr)) {}
+  OffsetPtr<T>& operator= (const OffsetPtr<T> &ptr) {
     offset_ = to_offset(ptr.get());
     return *this;
   }
-  OffsetPtr<T>& operator= (const T* ptr) {
+  OffsetPtr<T>& operator= (const T *ptr) {
     offset_ = to_offset(ptr);
     return *this;
   }
@@ -44,6 +46,7 @@ class OffsetPtr {
   T& operator[] (size_t index) const {
     return *(get() + index);
   }
+  // TODO: define other operations
   T* get() const {
     if (!offset_) return NULL;
     return reinterpret_cast<T*>((char*)&offset_ + offset_);
@@ -52,7 +55,7 @@ class OffsetPtr {
   Offset to_offset(const T* ptr) const {
     return ptr ? (char*)ptr - (char*)(&offset_) : 0;
   }
-  Offset offset_ = 0;
+  Offset offset_;
 };
 
 struct String {
@@ -88,7 +91,7 @@ class MappedFileImpl;
 
 class MappedFile : boost::noncopyable {
  protected:
-  explicit MappedFile(const std::string& file_name);
+  explicit MappedFile(const std::string &file_name);
   virtual ~MappedFile();
 
   bool Create(size_t capacity);
@@ -104,11 +107,11 @@ class MappedFile : boost::noncopyable {
   template <class T>
   Array<T>* CreateArray(size_t array_size);
 
-  String* CreateString(const std::string& str);
-  bool CopyString(const std::string& src, String* dest);
+  String* CreateString(const std::string &str);
+  bool CopyString(const std::string &src, String *dest);
 
   size_t capacity() const;
-  char* address() const;
+  char * address() const;
 
  public:
   bool Exists() const;
@@ -124,14 +127,20 @@ class MappedFile : boost::noncopyable {
 
  private:
   std::string file_name_;
-  size_t size_ = 0;
-  unique_ptr<MappedFileImpl> file_;
+  size_t size_;
+  scoped_ptr<MappedFileImpl> file_;
 };
 
 // member function definitions
 
+#ifdef __GNUC__
+#define ALIGNOF __alignof__
+#elif _MSC_VER
+#define ALIGNOF __alignof
+#endif
+
 # if defined(__arm__)
-# define RIME_ALIGNED(size, T) ((size + alignof(T) - 1) & ~(alignof(T) - 1))
+# define RIME_ALIGNED(size, T) ((size + ALIGNOF(T) - 1) & ~(ALIGNOF(T) - 1))
 # else
 # define RIME_ALIGNED(size, T) (size)
 # endif
diff --git a/include/rime/dict/preset_vocabulary.h b/include/rime/dict/preset_vocabulary.h
index a5a6106..e93fa26 100644
--- a/include/rime/dict/preset_vocabulary.h
+++ b/include/rime/dict/preset_vocabulary.h
@@ -33,9 +33,9 @@ class PresetVocabulary {
   static std::string DictFilePath();
 
  protected:
-  unique_ptr<VocabularyDb> db_;
-  int max_phrase_length_ = 0;
-  double min_phrase_weight_ = 0.0;
+  scoped_ptr<VocabularyDb> db_;
+  int max_phrase_length_;
+  double min_phrase_weight_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/prism.h b/include/rime/dict/prism.h
index 577b3af..c407b6d 100644
--- a/include/rime/dict/prism.h
+++ b/include/rime/dict/prism.h
@@ -29,8 +29,8 @@ struct SpellingDescriptor {
   String tips;
 };
 
-using SpellingMapItem = List<SpellingDescriptor>;
-using SpellingMap = Array<SpellingMapItem>;
+typedef List<SpellingDescriptor> SpellingMapItem;
+typedef Array<SpellingMapItem> SpellingMap;
 
 struct Metadata {
   static const int kFormatMaxLength = 32;
@@ -66,14 +66,16 @@ class Script;
 
 class Prism : public MappedFile {
  public:
-  using Match = Darts::DoubleArray::result_pair_type;
+  typedef Darts::DoubleArray::result_pair_type Match;
 
-  explicit Prism(const std::string& file_name);
+  Prism(const std::string &file_name)
+      : MappedFile(file_name), trie_(new Darts::DoubleArray),
+        metadata_(NULL), spelling_map_(NULL), format_(0.0) {}
 
   bool Load();
   bool Save();
-  bool Build(const Syllabary& syllabary,
-             const Script* script = NULL,
+  bool Build(const Syllabary &syllabary,
+             const Script *script = NULL,
              uint32_t dict_file_checksum = 0,
              uint32_t schema_file_checksum = 0);
 
@@ -89,10 +91,10 @@ class Prism : public MappedFile {
   uint32_t schema_file_checksum() const;
 
  private:
-  unique_ptr<Darts::DoubleArray> trie_;
-  prism::Metadata* metadata_ = nullptr;
-  prism::SpellingMap* spelling_map_ = nullptr;
-  double format_ = 0.0;
+  scoped_ptr<Darts::DoubleArray> trie_;
+  prism::Metadata* metadata_;
+  prism::SpellingMap* spelling_map_;
+  double format_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/reverse_lookup_dictionary.h b/include/rime/dict/reverse_lookup_dictionary.h
index f47df26..34a6e31 100644
--- a/include/rime/dict/reverse_lookup_dictionary.h
+++ b/include/rime/dict/reverse_lookup_dictionary.h
@@ -55,9 +55,9 @@ class ReverseDb : public MappedFile {
   reverse::Metadata* metadata() const { return metadata_; }
 
  private:
-  reverse::Metadata* metadata_ = nullptr;
-  unique_ptr<StringTable> key_trie_;
-  unique_ptr<StringTable> value_trie_;
+  reverse::Metadata* metadata_;
+  scoped_ptr<StringTable> key_trie_;
+  scoped_ptr<StringTable> value_trie_;
 };
 
 class ReverseLookupDictionary
@@ -80,7 +80,7 @@ class ReverseLookupDictionaryComponent
   ReverseLookupDictionaryComponent();
   ReverseLookupDictionary* Create(const Ticket& ticket);
  private:
-  std::map<std::string, weak_ptr<ReverseDb>> db_pool_;
+  std::map<std::string, weak_ptr<ReverseDb> > db_pool_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/string_table.h b/include/rime/dict/string_table.h
index 40d36a7..817075c 100644
--- a/include/rime/dict/string_table.h
+++ b/include/rime/dict/string_table.h
@@ -16,14 +16,14 @@
 
 namespace rime {
 
-using StringId = marisa::UInt32;
+typedef marisa::UInt32 StringId;
 
 const StringId kInvalidStringId = (StringId)(-1);
 
 class StringTable {
  public:
-  StringTable() = default;
-  virtual ~StringTable() = default;
+  StringTable() {}
+  virtual ~StringTable() {}
   StringTable(const char* ptr, size_t size);
 
   bool HasKey(const std::string& key);
@@ -44,7 +44,7 @@ class StringTable {
 class StringTableBuilder: public StringTable {
  public:
   void Add(const std::string& key, double weight = 1.0,
-           StringId* reference = nullptr);
+           StringId* reference = NULL);
   void Clear();
   void Build();
   void Dump(char* ptr, size_t size);
diff --git a/include/rime/dict/table.h b/include/rime/dict/table.h
index 59427db..b1bc314 100644
--- a/include/rime/dict/table.h
+++ b/include/rime/dict/table.h
@@ -24,18 +24,18 @@ namespace rime {
 namespace table {
 
 union StringType {
-  String str;
+  int32_t offset;
   StringId str_id;
 };
 
-using Syllabary = Array<StringType>;
+typedef Array<StringType> Syllabary;
 
-using Code = List<SyllableId>;
+typedef List<SyllableId> Code;
 
 #if defined(__arm__)
-using Weight = double;
+typedef double Weight;
 #else
-using Weight = float;
+typedef float Weight;
 #endif
 
 struct Entry {
@@ -48,31 +48,24 @@ struct LongEntry {
   Entry entry;
 };
 
-union PhraseIndex;
-
 struct HeadIndexNode {
   List<Entry> entries;
-  OffsetPtr<PhraseIndex> next_level;
+  OffsetPtr<char> next_level;
 };
 
-using HeadIndex = Array<HeadIndexNode>;
+typedef Array<HeadIndexNode> HeadIndex;
 
 struct TrunkIndexNode {
   SyllableId key;
   List<Entry> entries;
-  OffsetPtr<PhraseIndex> next_level;
+  OffsetPtr<char> next_level;
 };
 
-using TrunkIndex = Array<TrunkIndexNode>;
-
-using TailIndex = Array<LongEntry>;
+typedef Array<TrunkIndexNode> TrunkIndex;
 
-union PhraseIndex {
-  TrunkIndex trunk;
-  TailIndex tail;
-};
+typedef Array<LongEntry> TailIndex;
 
-using Index = HeadIndex;
+typedef HeadIndex Index;
 
 struct Metadata {
   static const int kFormatMaxLength = 32;
@@ -93,7 +86,7 @@ struct Metadata {
 
 class TableAccessor {
  public:
-  TableAccessor() = default;
+  TableAccessor();
   TableAccessor(const Code& index_code, const List<table::Entry>* entries,
                 double credibility = 1.0);
   TableAccessor(const Code& index_code, const Array<table::Entry>* entries,
@@ -113,14 +106,14 @@ class TableAccessor {
 
  private:
   Code index_code_;
-  const table::Entry* entries_ = nullptr;
-  const table::LongEntry* long_entries_ = nullptr;
-  size_t size_ = 0;
-  size_t cursor_ = 0;
-  double credibility_ = 1.0;
+  const table::Entry* entries_;
+  const table::LongEntry* long_entries_;
+  size_t size_;
+  size_t cursor_;
+  double credibility_;
 };
 
-using TableQueryResult = std::map<int, std::vector<TableAccessor>>;
+typedef std::map<int, std::vector<TableAccessor> > TableQueryResult;
 
 struct SyllableGraph;
 class TableQuery;
@@ -132,16 +125,16 @@ class Table : public MappedFile {
 
   bool Load();
   bool Save();
-  bool Build(const Syllabary& syllabary,
-             const Vocabulary& vocabulary,
+  bool Build(const Syllabary &syllabary,
+             const Vocabulary &vocabulary,
              size_t num_entries,
              uint32_t dict_file_checksum = 0);
 
   bool GetSyllabary(Syllabary* syllabary);
   std::string GetSyllableById(int syllable_id);
   TableAccessor QueryWords(int syllable_id);
-  TableAccessor QueryPhrases(const Code& code);
-  bool Query(const SyllableGraph& syll_graph,
+  TableAccessor QueryPhrases(const Code &code);
+  bool Query(const SyllableGraph &syll_graph,
              size_t start_pos,
              TableQueryResult* result);
   std::string GetEntryText(const table::Entry& entry);
@@ -178,9 +171,9 @@ class Table : public MappedFile {
   void SelectTableFormat(double format_version);
 
  protected:
-  table::Metadata* metadata_ = nullptr;
-  table::Syllabary* syllabary_ = nullptr;
-  table::Index* index_ = nullptr;
+  table::Metadata* metadata_;
+  table::Syllabary* syllabary_;
+  table::Index* index_;
 
   struct TableFormat {
     const char* format_name;
@@ -195,8 +188,8 @@ class Table : public MappedFile {
   } format_;
 
   // v2
-  unique_ptr<StringTable> string_table_;
-  unique_ptr<StringTableBuilder> string_table_builder_;
+  scoped_ptr<StringTable> string_table_;
+  scoped_ptr<StringTableBuilder> string_table_builder_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/text_db.h b/include/rime/dict/text_db.h
index b027c7c..20050a8 100644
--- a/include/rime/dict/text_db.h
+++ b/include/rime/dict/text_db.h
@@ -16,7 +16,7 @@ namespace rime {
 
 class TextDb;
 
-using TextDbData = std::map<std::string, std::string>;
+typedef std::map<std::string, std::string> TextDbData;
 
 class TextDbAccessor : public DbAccessor {
  public:
@@ -24,8 +24,8 @@ class TextDbAccessor : public DbAccessor {
   virtual ~TextDbAccessor();
 
   virtual bool Reset();
-  virtual bool Jump(const std::string& key);
-  virtual bool GetNextRecord(std::string* key, std::string* value);
+  virtual bool Jump(const std::string &key);
+  virtual bool GetNextRecord(std::string *key, std::string *value);
   virtual bool exhausted();
 
  private:
@@ -54,15 +54,15 @@ class TextDb : public Db {
   virtual bool Restore(const std::string& snapshot_file);
 
   virtual bool CreateMetadata();
-  virtual bool MetaFetch(const std::string& key, std::string* value);
-  virtual bool MetaUpdate(const std::string& key, const std::string& value);
+  virtual bool MetaFetch(const std::string &key, std::string *value);
+  virtual bool MetaUpdate(const std::string &key, const std::string &value);
 
   virtual shared_ptr<DbAccessor> QueryMetadata();
   virtual shared_ptr<DbAccessor> QueryAll();
-  virtual shared_ptr<DbAccessor> Query(const std::string& key);
-  virtual bool Fetch(const std::string& key, std::string* value);
-  virtual bool Update(const std::string& key, const std::string& value);
-  virtual bool Erase(const std::string& key);
+  virtual shared_ptr<DbAccessor> Query(const std::string &key);
+  virtual bool Fetch(const std::string &key, std::string *value);
+  virtual bool Update(const std::string &key, const std::string &value);
+  virtual bool Erase(const std::string &key);
 
  protected:
   void Clear();
@@ -73,7 +73,7 @@ class TextDb : public Db {
   TextFormat format_;
   TextDbData metadata_;
   TextDbData data_;
-  bool modified_ = false;
+  bool modified_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/tree_db.h b/include/rime/dict/tree_db.h
index e119fba..81cd568 100644
--- a/include/rime/dict/tree_db.h
+++ b/include/rime/dict/tree_db.h
@@ -9,30 +9,37 @@
 #ifndef RIME_TREE_DB_H_
 #define RIME_TREE_DB_H_
 
+#if defined(_MSC_VER)
+#pragma warning(disable: 4244)
+#pragma warning(disable: 4351)
+#endif
+#include <kchashdb.h>
+#if defined(_MSC_VER)
+#pragma warning(default: 4351)
+#pragma warning(default: 4244)
+#endif
+
 #include <string>
 #include <rime/dict/db.h>
 
 namespace rime {
 
-struct TreeDbCursor;
-struct TreeDbWrapper;
-
 class TreeDb;
 
 class TreeDbAccessor : public DbAccessor {
  public:
   TreeDbAccessor();
-  TreeDbAccessor(TreeDbCursor* cursor,
-                 const std::string& prefix);
+  TreeDbAccessor(kyotocabinet::DB::Cursor *cursor,
+                 const std::string &prefix);
   virtual ~TreeDbAccessor();
 
   virtual bool Reset();
-  virtual bool Jump(const std::string& key);
-  virtual bool GetNextRecord(std::string* key, std::string* value);
+  virtual bool Jump(const std::string &key);
+  virtual bool GetNextRecord(std::string *key, std::string *value);
   virtual bool exhausted();
 
  private:
-  unique_ptr<TreeDbCursor> cursor_;
+  scoped_ptr<kyotocabinet::DB::Cursor> cursor_;
 };
 
 class TreeDb : public Db,
@@ -50,15 +57,15 @@ class TreeDb : public Db,
   virtual bool Restore(const std::string& snapshot_file);
 
   virtual bool CreateMetadata();
-  virtual bool MetaFetch(const std::string& key, std::string* value);
-  virtual bool MetaUpdate(const std::string& key, const std::string& value);
+  virtual bool MetaFetch(const std::string &key, std::string *value);
+  virtual bool MetaUpdate(const std::string &key, const std::string &value);
 
   virtual shared_ptr<DbAccessor> QueryMetadata();
   virtual shared_ptr<DbAccessor> QueryAll();
-  virtual shared_ptr<DbAccessor> Query(const std::string& key);
-  virtual bool Fetch(const std::string& key, std::string* value);
-  virtual bool Update(const std::string& key, const std::string& value);
-  virtual bool Erase(const std::string& key);
+  virtual shared_ptr<DbAccessor> Query(const std::string &key);
+  virtual bool Fetch(const std::string &key, std::string *value);
+  virtual bool Update(const std::string &key, const std::string &value);
+  virtual bool Erase(const std::string &key);
 
   // Recoverable
   virtual bool Recover();
@@ -71,7 +78,7 @@ class TreeDb : public Db,
  private:
   void Initialize();
 
-  unique_ptr<TreeDbWrapper> db_;
+  scoped_ptr<kyotocabinet::TreeDB> db_;
   std::string db_type_;
 };
 
diff --git a/include/rime/dict/tsv.h b/include/rime/dict/tsv.h
index 1f8a27c..0fb12d0 100644
--- a/include/rime/dict/tsv.h
+++ b/include/rime/dict/tsv.h
@@ -7,21 +7,21 @@
 #ifndef RIME_TSV_H_
 #define RIME_TSV_H_
 
-#include <functional>
 #include <string>
 #include <vector>
+#include <boost/function.hpp>
 
 namespace rime {
 
-using Tsv = std::vector<std::string>;
+typedef std::vector<std::string> Tsv;
 
-using TsvParser = std::function<bool (const Tsv& row,
-                                      std::string* key,
-                                      std::string* value)>;
+typedef boost::function<bool (const Tsv& row,
+                              std::string* key,
+                              std::string* value)> TsvParser;
 
-using TsvFormatter = std::function<bool (const std::string& key,
-                                         const std::string& value,
-                                         Tsv* row)>;
+typedef boost::function<bool (const std::string& key,
+                              const std::string& value,
+                              Tsv* row)> TsvFormatter;
 
 class Sink;
 class Source;
diff --git a/include/rime/dict/user_db.h b/include/rime/dict/user_db.h
index 11288cb..e616c31 100644
--- a/include/rime/dict/user_db.h
+++ b/include/rime/dict/user_db.h
@@ -13,25 +13,23 @@
 
 namespace rime {
 
-using TickCount = uint64_t;
+typedef uint64_t TickCount;
 
 struct UserDbValue {
-  int commits = 0;
-  double dee = 0.0;
-  TickCount tick = 0;
+  int commits;
+  double dee;
+  TickCount tick;
 
-  UserDbValue() = default;
+  UserDbValue();
   UserDbValue(const std::string& value);
-
   std::string Pack() const;
-  bool Unpack(const std::string& value);
+  bool Unpack(const std::string &value);
 };
 
 template <class BaseDb>
 class UserDb : public BaseDb {
  public:
   explicit UserDb(const std::string& name);
-
   virtual bool CreateMetadata();
   virtual bool Backup(const std::string& snapshot_file);
   virtual bool Restore(const std::string& snapshot_file);
diff --git a/include/rime/dict/user_dictionary.h b/include/rime/dict/user_dictionary.h
index be7da56..234d438 100644
--- a/include/rime/dict/user_dictionary.h
+++ b/include/rime/dict/user_dictionary.h
@@ -22,7 +22,7 @@ struct UserDictEntryCollector : std::map<size_t, DictEntryList> {
 
 class UserDictEntryIterator : public DictEntryFilterBinder {
  public:
-  UserDictEntryIterator() = default;
+  UserDictEntryIterator() : entries_(), index_(0) {}
 
   void Add(const shared_ptr<DictEntry>& entry);
   void SortRange(size_t start, size_t count);
@@ -39,7 +39,7 @@ class UserDictEntryIterator : public DictEntryFilterBinder {
 
  protected:
   shared_ptr<DictEntryList> entries_;
-  size_t index_ = 0;
+  size_t index_;
 };
 
 class Schema;
@@ -52,15 +52,15 @@ struct Ticket;
 
 class UserDictionary : public Class<UserDictionary, const Ticket&> {
  public:
-  explicit UserDictionary(const shared_ptr<Db>& db);
+  explicit UserDictionary(const shared_ptr<Db> &db);
   virtual ~UserDictionary();
 
-  void Attach(const shared_ptr<Table>& table, const shared_ptr<Prism>& prism);
+  void Attach(const shared_ptr<Table> &table, const shared_ptr<Prism> &prism);
   bool Load();
   bool loaded() const;
   bool readonly() const;
 
-  shared_ptr<UserDictEntryCollector> Lookup(const SyllableGraph& syllable_graph,
+  shared_ptr<UserDictEntryCollector> Lookup(const SyllableGraph &syllable_graph,
                                             size_t start_pos,
                                             size_t depth_limit = 0,
                                             double initial_credibility = 1.0);
@@ -90,18 +90,18 @@ class UserDictionary : public Class<UserDictionary, const Ticket&> {
  protected:
   bool Initialize();
   bool FetchTickCount();
-  bool TranslateCodeToString(const Code& code, std::string* result);
-  void DfsLookup(const SyllableGraph& syll_graph, size_t current_pos,
-                 const std::string& current_prefix,
-                 DfsState* state);
+  bool TranslateCodeToString(const Code &code, std::string *result);
+  void DfsLookup(const SyllableGraph &syll_graph, size_t current_pos,
+                 const std::string &current_prefix,
+                 DfsState *state);
 
  private:
   std::string name_;
   shared_ptr<Db> db_;
   shared_ptr<Table> table_;
   shared_ptr<Prism> prism_;
-  TickCount tick_ = 0;
-  time_t transaction_time_ = 0;
+  TickCount tick_;
+  time_t transaction_time_;
 };
 
 class UserDictionaryComponent : public UserDictionary::Component {
@@ -109,7 +109,7 @@ class UserDictionaryComponent : public UserDictionary::Component {
   UserDictionaryComponent();
   UserDictionary* Create(const Ticket& ticket);
  private:
-  std::map<std::string, weak_ptr<Db>> db_pool_;
+  std::map<std::string, weak_ptr<Db> > db_pool_;
 };
 
 }  // namespace rime
diff --git a/include/rime/dict/vocabulary.h b/include/rime/dict/vocabulary.h
index 7c77a4f..2dc5108 100644
--- a/include/rime/dict/vocabulary.h
+++ b/include/rime/dict/vocabulary.h
@@ -14,20 +14,21 @@
 #include <set>
 #include <string>
 #include <vector>
+#include <boost/function.hpp>
 #include <rime/common.h>
 
 namespace rime {
 
-using Syllabary = std::set<std::string>;
+typedef std::set<std::string> Syllabary;
 
-using SyllableId = int32_t;
+typedef int32_t SyllableId;
 
 class Code : public std::vector<SyllableId> {
  public:
   static const size_t kIndexCodeMaxLength = 3;
 
-  bool operator< (const Code& other) const;
-  bool operator== (const Code& other) const;
+  bool operator< (const Code &other) const;
+  bool operator== (const Code &other) const;
 
   void CreateIndex(Code* index_code);
 
@@ -38,23 +39,23 @@ struct DictEntry {
   std::string text;
   std::string comment;
   std::string preedit;
-  double weight = 0.0;
-  int commit_count = 0;
+  double weight;
+  int commit_count;
   Code code;  // multi-syllable code from prism
   std::string custom_code;  // user defined code
-  int remaining_code_length = 0;
+  int remaining_code_length;
 
-  DictEntry() = default;
+  DictEntry() : weight(0.0), commit_count(0), remaining_code_length(0) {}
   bool operator< (const DictEntry& other) const;
 };
 
-class DictEntryList : public std::vector<shared_ptr<DictEntry>> {
+class DictEntryList : public std::vector<shared_ptr<DictEntry> > {
  public:
   void Sort();
   void SortRange(size_t start, size_t count);
 };
 
-using DictEntryFilter = std::function<bool (shared_ptr<DictEntry> entry)>;
+typedef boost::function<bool (shared_ptr<DictEntry> entry)> DictEntryFilter;
 
 class DictEntryFilterBinder {
  public:
@@ -73,12 +74,12 @@ struct VocabularyPage {
 
 class Vocabulary : public std::map<int, VocabularyPage> {
  public:
-  DictEntryList* LocateEntries(const Code& code);
+  DictEntryList* LocateEntries(const Code &code);
   void SortHomophones();
 };
 
 // word -> { code, ... }
-using ReverseLookupTable = std::map<std::string, std::set<std::string>>;
+typedef std::map<std::string, std::set<std::string> > ReverseLookupTable;
 
 }  // namespace rime
 
diff --git a/include/rime/engine.h b/include/rime/engine.h
index 47cf832..2ef7910 100644
--- a/include/rime/engine.h
+++ b/include/rime/engine.h
@@ -19,7 +19,7 @@ class Context;
 
 class Engine : public Messenger {
  public:
-  using CommitSink = signal<void (const std::string& commit_text)>;
+  typedef signal<void (const std::string& commit_text)> CommitSink;
 
   virtual ~Engine();
   virtual bool ProcessKey(const KeyEvent& key_event) { return false; }
@@ -33,7 +33,7 @@ class Engine : public Messenger {
   Context* active_context() const {
     return active_context_ ? active_context_ : context_.get();
   }
-  void set_active_context(Context* context = nullptr) {
+  void set_active_context(Context* context = NULL) {
     active_context_ = context;
   }
 
@@ -42,10 +42,10 @@ class Engine : public Messenger {
  protected:
   Engine();
 
-  unique_ptr<Schema> schema_;
-  unique_ptr<Context> context_;
+  scoped_ptr<Schema> schema_;
+  scoped_ptr<Context> context_;
   CommitSink sink_;
-  Context* active_context_ = nullptr;
+  Context* active_context_;
 };
 
 }  // namespace rime
diff --git a/include/rime/filter.h b/include/rime/filter.h
index 79c457f..6f71e76 100644
--- a/include/rime/filter.h
+++ b/include/rime/filter.h
@@ -22,17 +22,17 @@ class Filter : public Class<Filter, const Ticket&> {
  public:
   explicit Filter(const Ticket& ticket)
       : engine_(ticket.engine), name_space_(ticket.name_space) {}
-  virtual ~Filter() = default;
+  virtual ~Filter() {}
 
-  virtual void Apply(CandidateList* recruited,
-                     CandidateList* candidates) = 0;
+  virtual void Apply(CandidateList *recruited,
+                     CandidateList *candidates) = 0;
 
   virtual bool AppliesToSegment(Segment* segment) {
     return true;
   }
 
  protected:
-  Engine* engine_;
+  Engine *engine_;
   std::string name_space_;
 };
 
diff --git a/include/rime/formatter.h b/include/rime/formatter.h
index 3e5477a..531f5b8 100644
--- a/include/rime/formatter.h
+++ b/include/rime/formatter.h
@@ -20,12 +20,12 @@ class Formatter : public Class<Formatter, const Ticket&> {
  public:
   Formatter(const Ticket& ticket)
       : engine_(ticket.engine), name_space_(ticket.name_space) {}
-  virtual ~Formatter() = default;
+  virtual ~Formatter() {}
 
   virtual void Format(std::string* text) = 0;
 
  protected:
-  Engine* engine_;
+  Engine *engine_;
   std::string name_space_;
 };
 
diff --git a/include/rime/gear/abc_segmentor.h b/include/rime/gear/abc_segmentor.h
index 70c9663..dd3a90e 100644
--- a/include/rime/gear/abc_segmentor.h
+++ b/include/rime/gear/abc_segmentor.h
@@ -17,7 +17,7 @@ class AbcSegmentor : public Segmentor {
  public:
   explicit AbcSegmentor(const Ticket& ticket);
 
-  virtual bool Proceed(Segmentation* segmentation);
+  virtual bool Proceed(Segmentation *segmentation);
 
  protected:
   std::string alphabet_;
diff --git a/include/rime/gear/affix_segmentor.h b/include/rime/gear/affix_segmentor.h
index a794b9e..0baad34 100644
--- a/include/rime/gear/affix_segmentor.h
+++ b/include/rime/gear/affix_segmentor.h
@@ -17,7 +17,7 @@ class AffixSegmentor : public Segmentor {
  public:
   explicit AffixSegmentor(const Ticket& ticket);
 
-  virtual bool Proceed(Segmentation* segmentation);
+  virtual bool Proceed(Segmentation *segmentation);
 
  protected:
   std::string tag_;
diff --git a/include/rime/gear/ascii_composer.h b/include/rime/gear/ascii_composer.h
index b467bbe..fe38a77 100644
--- a/include/rime/gear/ascii_composer.h
+++ b/include/rime/gear/ascii_composer.h
@@ -7,8 +7,8 @@
 #ifndef RIME_ASCII_COMPOSER_H_
 #define RIME_ASCII_COMPOSER_H_
 
-#include <chrono>
 #include <map>
+#include <boost/chrono.hpp>
 #include <rime/common.h>
 #include <rime/component.h>
 #include <rime/processor.h>
@@ -26,8 +26,8 @@ enum AsciiModeSwitchStyle {
   kAsciiModeSwitchClear,
 };
 
-using AsciiModeSwitchKeyBindings = std::map<int /* keycode */,
-                                            AsciiModeSwitchStyle>;
+typedef std::map<int /* keycode */,
+                 AsciiModeSwitchStyle> AsciiModeSwitchKeyBindings;
 
 class AsciiComposer : public Processor {
  public:
@@ -41,17 +41,17 @@ class AsciiComposer : public Processor {
   void LoadConfig(Schema* schema);
   bool ToggleAsciiModeWithKey(int key_code);
   void SwitchAsciiMode(bool ascii_mode, AsciiModeSwitchStyle style);
-  void OnContextUpdate(Context* ctx);
+  void OnContextUpdate(Context *ctx);
 
   // config options
   AsciiModeSwitchKeyBindings bindings_;
-  AsciiModeSwitchStyle caps_lock_switch_style_ = kAsciiModeSwitchNoop;
-  bool good_old_caps_lock_ = false;
+  AsciiModeSwitchStyle caps_lock_switch_style_;
+  bool good_old_caps_lock_;
   // state
-  bool toggle_with_caps_ = false;
-  bool shift_key_pressed_ = false;
-  bool ctrl_key_pressed_ = false;
-  using TimePoint = std::chrono::steady_clock::time_point;
+  bool toggle_with_caps_;
+  bool shift_key_pressed_;
+  bool ctrl_key_pressed_;
+  typedef boost::chrono::time_point<boost::chrono::steady_clock> TimePoint;
   TimePoint toggle_expired_;
   connection connection_;
 };
diff --git a/include/rime/gear/chord_composer.h b/include/rime/gear/chord_composer.h
index e25000a..367261c 100644
--- a/include/rime/gear/chord_composer.h
+++ b/include/rime/gear/chord_composer.h
@@ -20,7 +20,7 @@ class ChordComposer : public Processor {
   ChordComposer(const Ticket& ticket);
   ~ChordComposer();
 
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
   std::string SerializeChord();
@@ -39,8 +39,8 @@ class ChordComposer : public Processor {
 
   std::set<char> pressed_;
   std::set<char> chord_;
-  bool pass_thru_ = false;
-  bool composing_ = false;
+  bool pass_thru_;
+  bool composing_;
   std::string sequence_;
   connection update_connection_;
   connection unhandled_key_connection_;
diff --git a/include/rime/gear/echo_translator.h b/include/rime/gear/echo_translator.h
index e4c81e7..7bfeb2b 100644
--- a/include/rime/gear/echo_translator.h
+++ b/include/rime/gear/echo_translator.h
@@ -15,8 +15,8 @@ class EchoTranslator : public Translator {
  public:
   EchoTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
 };
 
diff --git a/include/rime/gear/editor.h b/include/rime/gear/editor.h
index 3748778..3fa040b 100644
--- a/include/rime/gear/editor.h
+++ b/include/rime/gear/editor.h
@@ -21,7 +21,7 @@ class Editor : public Processor {
   typedef ProcessResult CharHandler(Context* ctx, int ch);
 
   Editor(const Ticket& ticket, bool auto_commit);
-  ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
   virtual Handler OnSpace;
   virtual Handler OnBackSpace;
diff --git a/include/rime/gear/fallback_segmentor.h b/include/rime/gear/fallback_segmentor.h
index db0e780..040f1ac 100644
--- a/include/rime/gear/fallback_segmentor.h
+++ b/include/rime/gear/fallback_segmentor.h
@@ -16,7 +16,7 @@ class FallbackSegmentor : public Segmentor {
  public:
   explicit FallbackSegmentor(const Ticket& ticket);
 
-  virtual bool Proceed(Segmentation* segmentation);
+  virtual bool Proceed(Segmentation *segmentation);
 };
 
 }  // namespace rime
diff --git a/include/rime/gear/key_binder.h b/include/rime/gear/key_binder.h
index 7d840bc..2186499 100644
--- a/include/rime/gear/key_binder.h
+++ b/include/rime/gear/key_binder.h
@@ -19,14 +19,14 @@ class KeyBindings;
 class KeyBinder : public Processor {
  public:
   KeyBinder(const Ticket& ticket);
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
   void LoadConfig();
-  bool ReinterpretPagingKey(const KeyEvent& key_event);
+  bool ReinterpretPagingKey(const KeyEvent &key_event);
   void PerformKeyBinding(const KeyBinding& binding);
 
-  unique_ptr<KeyBindings> key_bindings_;
+  scoped_ptr<KeyBindings> key_bindings_;
   bool redirecting_;
   int last_key_;
 };
diff --git a/include/rime/gear/matcher.h b/include/rime/gear/matcher.h
index 424b3d4..0452680 100644
--- a/include/rime/gear/matcher.h
+++ b/include/rime/gear/matcher.h
@@ -16,7 +16,7 @@ class Matcher : public Segmentor {
  public:
   explicit Matcher(const Ticket& ticket);
 
-  virtual bool Proceed(Segmentation* segmentation);
+  virtual bool Proceed(Segmentation *segmentation);
 
  protected:
   RecognizerPatterns patterns_;
diff --git a/include/rime/gear/memory.h b/include/rime/gear/memory.h
index 3fd4994..1557a75 100644
--- a/include/rime/gear/memory.h
+++ b/include/rime/gear/memory.h
@@ -53,8 +53,8 @@ class Memory {
   void OnDeleteEntry(Context* ctx);
   void OnUnhandledKey(Context* ctx, const KeyEvent& key);
 
-  unique_ptr<Dictionary> dict_;
-  unique_ptr<UserDictionary> user_dict_;
+  scoped_ptr<Dictionary> dict_;
+  scoped_ptr<UserDictionary> user_dict_;
 
  private:
   connection commit_connection_;
diff --git a/include/rime/gear/navigator.h b/include/rime/gear/navigator.h
index 5c882df..ba1235e 100644
--- a/include/rime/gear/navigator.h
+++ b/include/rime/gear/navigator.h
@@ -17,13 +17,13 @@ class Navigator : public Processor {
  public:
   Navigator(const Ticket& ticket) : Processor(ticket) {}
 
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  private:
-  bool Left(Context* ctx);
-  bool Right(Context* ctx);
-  bool Home(Context* ctx);
-  bool End(Context* ctx);
+  bool Left(Context *ctx);
+  bool Right(Context *ctx);
+  bool Home(Context *ctx);
+  bool End(Context *ctx);
 };
 
 }  // namespace rime
diff --git a/include/rime/gear/poet.h b/include/rime/gear/poet.h
index acb81ee..36469e4 100644
--- a/include/rime/gear/poet.h
+++ b/include/rime/gear/poet.h
@@ -15,19 +15,19 @@
 
 namespace rime {
 
-using WordGraph = std::map<int, UserDictEntryCollector>;
+typedef std::map<int, UserDictEntryCollector> WordGraph;
 
 class Language;
 
 class Poet {
  public:
   Poet(Language* language) : language_(language) {}
-
+  
   shared_ptr<Sentence> MakeSentence(const WordGraph& graph,
                                     size_t total_length);
  protected:
   Language* language_;
-};
+};  
 
 }  // namespace rime
 
diff --git a/include/rime/gear/punctuator.h b/include/rime/gear/punctuator.h
index fa549ce..a18984c 100644
--- a/include/rime/gear/punctuator.h
+++ b/include/rime/gear/punctuator.h
@@ -21,7 +21,7 @@ class Engine;
 
 class PunctConfig {
  public:
-  void LoadConfig(Engine* engine, bool load_symbols = false);
+  void LoadConfig(Engine *engine, bool load_symbols = false);
   ConfigItemPtr GetPunctDefinition(const std::string key);
  protected:
   ConfigMapPtr mapping_;
@@ -34,23 +34,23 @@ class PunctConfig {
 class Punctuator : public Processor {
  public:
   Punctuator(const Ticket& ticket);
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
-  bool ConfirmUniquePunct(const ConfigItemPtr& definition);
-  bool AlternatePunct(const std::string& key, const ConfigItemPtr& definition);
-  bool AutoCommitPunct(const ConfigItemPtr& definition);
-  bool PairPunct(const ConfigItemPtr& definition);
+  bool ConfirmUniquePunct(const ConfigItemPtr &definition);
+  bool AlternatePunct(const std::string &key, const ConfigItemPtr &definition);
+  bool AutoCommitPunct(const ConfigItemPtr &definition);
+  bool PairPunct(const ConfigItemPtr &definition);
 
   PunctConfig config_;
-  bool use_space_ = false;
+  bool use_space_;
   std::map<ConfigItemPtr, int> oddness_;
 };
 
 class PunctSegmentor : public Segmentor {
  public:
   PunctSegmentor(const Ticket& ticket);
-  virtual bool Proceed(Segmentation* segmentation);
+  virtual bool Proceed(Segmentation *segmentation);
 
  protected:
   PunctConfig config_;
@@ -59,27 +59,27 @@ class PunctSegmentor : public Segmentor {
 class PunctTranslator : public Translator {
  public:
   PunctTranslator(const Ticket& ticket);
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
 
  protected:
   shared_ptr<Translation>
-  TranslateUniquePunct(const std::string& key,
-                       const Segment& segment,
-                       const ConfigValuePtr& definition);
+  TranslateUniquePunct(const std::string &key,
+                       const Segment &segment,
+                       const ConfigValuePtr &definition);
   shared_ptr<Translation>
-  TranslateAlternatingPunct(const std::string& key,
-                            const Segment& segment,
-                            const ConfigListPtr& definition);
+  TranslateAlternatingPunct(const std::string &key,
+                            const Segment &segment,
+                            const ConfigListPtr &definition);
   shared_ptr<Translation>
-  TranslateAutoCommitPunct(const std::string& key,
-                           const Segment& segment,
-                           const ConfigMapPtr& definition);
+  TranslateAutoCommitPunct(const std::string &key,
+                           const Segment &segment,
+                           const ConfigMapPtr &definition);
   shared_ptr<Translation>
-  TranslatePairedPunct(const std::string& key,
-                       const Segment& segment,
-                       const ConfigMapPtr& definition);
+  TranslatePairedPunct(const std::string &key,
+                       const Segment &segment,
+                       const ConfigMapPtr &definition);
 
   PunctConfig config_;
 };
diff --git a/include/rime/gear/recognizer.h b/include/rime/gear/recognizer.h
index 5658b99..069a8e1 100644
--- a/include/rime/gear/recognizer.h
+++ b/include/rime/gear/recognizer.h
@@ -20,27 +20,27 @@ class Segmentation;
 
 struct RecognizerMatch {
   std::string tag;
-  size_t start = 0, end = 0;
+  size_t start, end;
 
-  RecognizerMatch() = default;
-  RecognizerMatch(const std::string& a_tag, size_t a_start, size_t an_end)
-      : tag(a_tag), start(a_start), end(an_end) {}
+  RecognizerMatch() : tag(), start(0), end(0) {}
+  RecognizerMatch(const std::string &_tag, size_t _start, size_t _end)
+      : tag(_tag), start(_start), end(_end) {}
 
   bool found() const { return start < end; }
 };
 
 class RecognizerPatterns : public std::map<std::string, boost::regex> {
  public:
-  void LoadConfig(Config* config);
-  RecognizerMatch GetMatch(const std::string& input,
-                           Segmentation* segmentation) const;
+  void LoadConfig(Config *config);
+  RecognizerMatch GetMatch(const std::string &input,
+                           Segmentation *segmentation) const;
 };
 
 class Recognizer : public Processor {
  public:
   Recognizer(const Ticket& ticket);
 
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
   RecognizerPatterns patterns_;
diff --git a/include/rime/gear/reverse_lookup_filter.h b/include/rime/gear/reverse_lookup_filter.h
index f4efea7..699b53a 100644
--- a/include/rime/gear/reverse_lookup_filter.h
+++ b/include/rime/gear/reverse_lookup_filter.h
@@ -20,8 +20,8 @@ class ReverseLookupFilter : public Filter, TagMatching {
  public:
   explicit ReverseLookupFilter(const Ticket& ticket);
 
-  virtual void Apply(CandidateList* recruited,
-                     CandidateList* candidates);
+  virtual void Apply(CandidateList *recruited,
+                     CandidateList *candidates);
 
   virtual bool AppliesToSegment(Segment* segment) {
     return TagsMatch(segment);
@@ -30,10 +30,9 @@ class ReverseLookupFilter : public Filter, TagMatching {
  protected:
   void Initialize();
 
-  bool initialized_ = false;
-  unique_ptr<ReverseLookupDictionary> rev_dict_;
-  // settings
-  bool overwrite_comment_ = false;
+  bool initialized_;
+  scoped_ptr<ReverseLookupDictionary> rev_dict_;
+  bool overwrite_comment_;
   Projection comment_formatter_;
 };
 
diff --git a/include/rime/gear/reverse_lookup_translator.h b/include/rime/gear/reverse_lookup_translator.h
index a647689..2e667be 100644
--- a/include/rime/gear/reverse_lookup_translator.h
+++ b/include/rime/gear/reverse_lookup_translator.h
@@ -22,18 +22,18 @@ class ReverseLookupTranslator : public Translator {
  public:
   ReverseLookupTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
-
+  
  protected:
   void Initialize();
-
+  
   std::string tag_;
-  bool initialized_ = false;
-  unique_ptr<Dictionary> dict_;
-  unique_ptr<ReverseLookupDictionary> rev_dict_;
-  unique_ptr<TranslatorOptions> options_;
+  bool initialized_;
+  scoped_ptr<Dictionary> dict_;
+  scoped_ptr<ReverseLookupDictionary> rev_dict_;
+  scoped_ptr<TranslatorOptions> options_;
   std::string prefix_;
   std::string suffix_;
   std::string tips_;
diff --git a/include/rime/gear/schema_list_translator.h b/include/rime/gear/schema_list_translator.h
index fc8a93d..6fcffe9 100644
--- a/include/rime/gear/schema_list_translator.h
+++ b/include/rime/gear/schema_list_translator.h
@@ -15,8 +15,8 @@ class SchemaListTranslator : public Translator {
  public:
   SchemaListTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
 };
 
diff --git a/include/rime/gear/script_translator.h b/include/rime/gear/script_translator.h
index c5f6b2b..1a16802 100644
--- a/include/rime/gear/script_translator.h
+++ b/include/rime/gear/script_translator.h
@@ -30,19 +30,19 @@ class ScriptTranslator : public Translator,
  public:
   ScriptTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
   virtual bool Memorize(const CommitEntry& commit_entry);
 
-  std::string FormatPreedit(const std::string& preedit);
-  std::string Spell(const Code& code);
+  std::string FormatPreedit(const std::string &preedit);
+  std::string Spell(const Code &code);
 
   // options
   int spelling_hints() const { return spelling_hints_; }
 
  protected:
-  int spelling_hints_ = 0;
+  int spelling_hints_;
 };
 
 }  // namespace rime
diff --git a/include/rime/gear/selector.h b/include/rime/gear/selector.h
index 75bf015..2e0818c 100644
--- a/include/rime/gear/selector.h
+++ b/include/rime/gear/selector.h
@@ -17,16 +17,16 @@ class Selector : public Processor {
  public:
   Selector(const Ticket& ticket);
 
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
-  bool PageUp(Context* ctx);
-  bool PageDown(Context* ctx);
-  bool CursorUp(Context* ctx);
-  bool CursorDown(Context* ctx);
-  bool Home(Context* ctx);
-  bool End(Context* ctx);
-  bool SelectCandidateAt(Context* ctx, int index);
+  bool PageUp(Context *ctx);
+  bool PageDown(Context *ctx);
+  bool CursorUp(Context *ctx);
+  bool CursorDown(Context *ctx);
+  bool Home(Context *ctx);
+  bool End(Context *ctx);
+  bool SelectCandidateAt(Context *ctx, int index);
 };
 
 }  // namespace rime
diff --git a/include/rime/gear/simplifier.h b/include/rime/gear/simplifier.h
index 3998ee4..ce57fd9 100644
--- a/include/rime/gear/simplifier.h
+++ b/include/rime/gear/simplifier.h
@@ -20,24 +20,23 @@ class Simplifier : public Filter, TagMatching {
  public:
   explicit Simplifier(const Ticket& ticket);
 
-  virtual void Apply(CandidateList* recruited,
-                     CandidateList* candidates);
+  virtual void Apply(CandidateList *recruited,
+                     CandidateList *candidates);
 
   virtual bool AppliesToSegment(Segment* segment) {
     return TagsMatch(segment);
   }
 
  protected:
-  enum TipsLevel { kTipsNone, kTipsChar, kTipsAll };
+  typedef enum { kTipsNone, kTipsChar, kTipsAll } TipsLevel;
 
   void Initialize();
-  bool Convert(const shared_ptr<Candidate>& original,
-               CandidateList* result);
+  bool Convert(const shared_ptr<Candidate> &original,
+               CandidateList *result);
 
-  bool initialized_ = false;
-  unique_ptr<Opencc> opencc_;
-  // settings
-  TipsLevel tips_level_ =  kTipsNone;
+  bool initialized_;
+  scoped_ptr<Opencc> opencc_;
+  TipsLevel tips_level_;
   std::string option_name_;
   std::string opencc_config_;
   std::set<std::string> excluded_types_;
diff --git a/include/rime/gear/speller.h b/include/rime/gear/speller.h
index c5a9e41..5190779 100644
--- a/include/rime/gear/speller.h
+++ b/include/rime/gear/speller.h
@@ -21,7 +21,7 @@ class Speller : public Processor {
  public:
   Speller(const Ticket& ticket);
 
-  virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event);
+  virtual ProcessResult ProcessKeyEvent(const KeyEvent &key_event);
 
  protected:
   bool AutoSelectAtMaxCodeLength(Context* ctx);
@@ -33,9 +33,9 @@ class Speller : public Processor {
   std::string delimiters_;
   std::string initials_;
   std::string finals_;
-  int max_code_length_ = 0;
-  bool auto_select_ = false;
-  bool use_space_ = false;
+  int max_code_length_;
+  bool auto_select_;
+  bool use_space_;
   boost::regex auto_select_pattern_;
 };
 
diff --git a/include/rime/gear/switch_translator.h b/include/rime/gear/switch_translator.h
index 6a1a92c..bc550f6 100644
--- a/include/rime/gear/switch_translator.h
+++ b/include/rime/gear/switch_translator.h
@@ -15,8 +15,8 @@ class SwitchTranslator : public Translator {
  public:
   SwitchTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
 };
 
diff --git a/include/rime/gear/table_translator.h b/include/rime/gear/table_translator.h
index ef0c53f..998cd05 100644
--- a/include/rime/gear/table_translator.h
+++ b/include/rime/gear/table_translator.h
@@ -28,8 +28,8 @@ class TableTranslator : public Translator,
  public:
   TableTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
   virtual bool Memorize(const CommitEntry& commit_entry);
 
@@ -40,13 +40,13 @@ class TableTranslator : public Translator,
   UnityTableEncoder* encoder() const { return encoder_.get(); }
 
  protected:
-  bool enable_charset_filter_ = false;
-  bool enable_encoder_ = false;
-  bool enable_sentence_ = true;
-  bool sentence_over_completion_ = false;
-  bool encode_commit_history_ = true;
-  int max_phrase_length_ = 5;
-  unique_ptr<UnityTableEncoder> encoder_;
+  bool enable_charset_filter_;
+  bool enable_encoder_;
+  bool enable_sentence_;
+  bool sentence_over_completion_;
+  bool encode_commit_history_;
+  int max_phrase_length_;
+  scoped_ptr<UnityTableEncoder> encoder_;
 };
 
 class TableTranslation : public Translation {
diff --git a/include/rime/gear/translator_commons.h b/include/rime/gear/translator_commons.h
index 2fe00ca..e610260 100644
--- a/include/rime/gear/translator_commons.h
+++ b/include/rime/gear/translator_commons.h
@@ -32,12 +32,8 @@ class Patterns : public std::vector<boost::regex> {
 class Syllabification {
  public:
   // move the caret by syllable by returning a value different from caret_pos
-  virtual size_t PreviousStop(size_t caret_pos) const {
-    return caret_pos;
-  }
-  virtual size_t NextStop(size_t caret_pos) const {
-    return caret_pos;
-  }
+  virtual size_t PreviousStop(size_t caret_pos) const { return caret_pos; }
+  virtual size_t NextStop(size_t caret_pos) const { return caret_pos; }
 };
 
 //
@@ -48,7 +44,7 @@ class Phrase : public Candidate {
  public:
   Phrase(Language* language,
          const std::string& type, size_t start, size_t end,
-         const shared_ptr<DictEntry>& entry)
+         const shared_ptr<DictEntry> &entry)
       : Candidate(type, start, end),
         language_(language),
         entry_(entry) {
@@ -56,13 +52,13 @@ class Phrase : public Candidate {
   const std::string& text() const { return entry_->text; }
   std::string comment() const { return entry_->comment; }
   std::string preedit() const { return entry_->preedit; }
-  void set_comment(const std::string& comment) {
+  void set_comment(const std::string &comment) {
     entry_->comment = comment;
   }
-  void set_preedit(const std::string& preedit) {
+  void set_preedit(const std::string &preedit) {
     entry_->preedit = preedit;
   }
-  void set_syllabification(shared_ptr<Syllabification> s) {
+  void set_syllabification(const shared_ptr<Syllabification>& s) {
     syllabification_ = s;
   }
 
@@ -85,24 +81,22 @@ class Phrase : public Candidate {
 class Sentence : public Phrase {
  public:
   Sentence(Language* language)
-      : Phrase(language, "sentence", 0, 0, New<DictEntry>()) {
+      : Phrase(language, "sentence", 0, 0, make_shared<DictEntry>()) {
     entry_->weight = 1.0;
   }
   Sentence(const Sentence& other)
       : Phrase(other),
         components_(other.components_),
         syllable_lengths_(other.syllable_lengths_) {
-    entry_ = New<DictEntry>(other.entry());
+    entry_ = make_shared<DictEntry>(other.entry());
   }
   void Extend(const DictEntry& entry, size_t end_pos);
   void Offset(size_t offset);
 
-  const std::vector<DictEntry>& components() const {
-    return components_;
-  }
-  const std::vector<size_t>& syllable_lengths() const {
-    return syllable_lengths_;
-  }
+  const std::vector<DictEntry>& components() const
+  { return components_; }
+  const std::vector<size_t>& syllable_lengths() const
+  { return syllable_lengths_; }
 
  protected:
   std::vector<DictEntry> components_;
@@ -123,11 +117,6 @@ class CacheTranslation : public Translation {
   shared_ptr<Candidate> cache_;
 };
 
-template <class T, class... Args>
-inline shared_ptr<Translation> Cached(Args&&... args) {
-  return New<CacheTranslation>(New<T>(std::forward<Args>(args)...));
-}
-
 class CharsetFilter : public Translation {
  public:
   CharsetFilter(shared_ptr<Translation> translation);
@@ -178,10 +167,10 @@ class TranslatorOptions {
 
  protected:
   std::string delimiters_;
-  std::string tag_ = "abc";
-  bool enable_completion_ = true;
-  bool strict_spelling_ = false;
-  double initial_quality_ = 0.;
+  std::string tag_;
+  bool enable_completion_;
+  bool strict_spelling_;
+  double initial_quality_;
   Projection preedit_formatter_;
   Projection comment_formatter_;
   Patterns user_dict_disabling_patterns_;
diff --git a/include/rime/gear/uniquifier.h b/include/rime/gear/uniquifier.h
index 67dcdc3..df93d86 100644
--- a/include/rime/gear/uniquifier.h
+++ b/include/rime/gear/uniquifier.h
@@ -15,8 +15,8 @@ class Uniquifier : public Filter {
  public:
   explicit Uniquifier(const Ticket& ticket);
 
-  virtual void Apply(CandidateList* recruited,
-                     CandidateList* candidates);
+  virtual void Apply(CandidateList *recruited,
+                     CandidateList *candidates);
 };
 
 }  // namespace rime
diff --git a/include/rime/gear/unity_table_encoder.h b/include/rime/gear/unity_table_encoder.h
index 423b0cf..a6c1522 100644
--- a/include/rime/gear/unity_table_encoder.h
+++ b/include/rime/gear/unity_table_encoder.h
@@ -23,9 +23,9 @@ class UnityTableEncoder : public TableEncoder, public PhraseCollector {
 
   bool Load(const Ticket& ticket);
 
-  void CreateEntry(const std::string& word,
-                   const std::string& code_str,
-                   const std::string& weight_str);
+  void CreateEntry(const std::string &word,
+                   const std::string &code_str,
+                   const std::string &weight_str);
   bool TranslateWord(const std::string& word,
                      std::vector<std::string>* code);
 
@@ -41,7 +41,7 @@ class UnityTableEncoder : public TableEncoder, public PhraseCollector {
 
  protected:
   UserDictionary* user_dict_;
-  unique_ptr<ReverseLookupDictionary> rev_dict_;
+  scoped_ptr<ReverseLookupDictionary> rev_dict_;
 };
 
 }  // namespace rime
diff --git a/include/rime/key_event.h b/include/rime/key_event.h
index 7319949..41e9c05 100644
--- a/include/rime/key_event.h
+++ b/include/rime/key_event.h
@@ -18,10 +18,10 @@ namespace rime {
 
 class KeyEvent {
  public:
-  KeyEvent() = default;
+  KeyEvent() : keycode_(0), modifier_(0) {}
   KeyEvent(int keycode, int modifier)
       : keycode_(keycode), modifier_(modifier) {}
-  KeyEvent(const std::string& repr);
+  KeyEvent(const std::string &repr);
 
   int keycode() const { return keycode_; }
   void keycode(int value) { keycode_ = value; }
@@ -40,28 +40,28 @@ class KeyEvent {
   std::string repr() const;
 
   // 解析文字表示的按鍵
-  bool Parse(const std::string& repr);
+  bool Parse(const std::string &repr);
 
-  bool operator== (const KeyEvent& other) const {
+  bool operator== (const KeyEvent &other) const {
     return keycode_ == other.keycode_ && modifier_ == other.modifier_;
   }
 
-  bool operator< (const KeyEvent& other) const {
+  bool operator< (const KeyEvent &other) const {
     if (keycode_ != other.keycode_)
       return keycode_ < other.keycode_;
     return modifier_ < other.modifier_;
   }
 
  private:
-  int keycode_ = 0;
-  int modifier_ = 0;
+  int keycode_;
+  int modifier_;
 };
 
 // 按鍵序列
 class KeySequence : public std::vector<KeyEvent> {
  public:
-  KeySequence() = default;
-  KeySequence(const std::string& repr);
+  KeySequence() {}
+  KeySequence(const std::string &repr);
 
   // 可表示為一串文字
   // 若其中包含不產生可打印字符的按鍵，以 {鍵名} 來標記
@@ -69,15 +69,15 @@ class KeySequence : public std::vector<KeyEvent> {
   std::string repr() const;
 
   // 解析按鍵序列描述文字
-  bool Parse(const std::string& repr);
+  bool Parse(const std::string &repr);
 };
 
-inline std::ostream& operator<< (std::ostream& out, const KeyEvent& key_event) {
+inline std::ostream& operator<< (std::ostream& out, const KeyEvent &key_event) {
   out << key_event.repr();
   return out;
 }
 
-inline std::ostream& operator<< (std::ostream& out, const KeySequence& key_seq) {
+inline std::ostream& operator<< (std::ostream& out, const KeySequence &key_seq) {
   out << key_seq.repr();
   return out;
 }
diff --git a/include/rime/key_table.h b/include/rime/key_table.h
index 9c0cfb0..96d0320 100644
--- a/include/rime/key_table.h
+++ b/include/rime/key_table.h
@@ -47,7 +47,7 @@ typedef enum {
 // 给定modifier文字，返回马赛克值
 // 例如 RimeGetModifierByName("Alt") == (1 << 3)
 // 如果不认得所给的键名，返回 0
-int RimeGetModifierByName(const char* name);
+int RimeGetModifierByName(const char *name);
 
 // 给一个数值，取得最低的非0位所对应的modifier文字
 // 例如 RimeGetModifierName(12) == "Control"
@@ -56,7 +56,7 @@ const char* RimeGetModifierName(int modifier);
 
 // 由键名取得键值
 // 查无此键则返回 XK_VoidSymbol
-int RimeGetKeycodeByName(const char* name);
+int RimeGetKeycodeByName(const char *name);
 
 // 由键值取得键名
 // 不认得此键，则返回 NULL
diff --git a/include/rime/lever/custom_settings.h b/include/rime/lever/custom_settings.h
index 480a795..1def826 100644
--- a/include/rime/lever/custom_settings.h
+++ b/include/rime/lever/custom_settings.h
@@ -19,8 +19,7 @@ class CustomSettings {
   CustomSettings(Deployer* deployer,
                  const std::string& config_id,
                  const std::string& generator_id);
-  virtual ~CustomSettings() = default;
-
+  virtual ~CustomSettings() {}
   virtual bool Load();
   virtual bool Save();
   ConfigValuePtr GetValue(const std::string& key);
@@ -33,7 +32,7 @@ class CustomSettings {
 
  protected:
   Deployer* deployer_;
-  bool modified_ = false;
+  bool modified_;
   std::string config_id_;
   std::string generator_id_;
   Config config_;
diff --git a/include/rime/lever/customizer.h b/include/rime/lever/customizer.h
index 8418410..118b560 100644
--- a/include/rime/lever/customizer.h
+++ b/include/rime/lever/customizer.h
@@ -20,14 +20,14 @@ class Customizer {
       : source_path_(source_path),
         dest_path_(dest_path),
         version_key_(version_key) {}
-
+  
   bool UpdateConfigFile();
 
  protected:
   boost::filesystem::path source_path_;
   boost::filesystem::path dest_path_;
   std::string version_key_;
-};
+};  
 
 }  // namespace rime
 
diff --git a/include/rime/lever/deployment_tasks.h b/include/rime/lever/deployment_tasks.h
index 2001fbf..0a67dd4 100644
--- a/include/rime/lever/deployment_tasks.h
+++ b/include/rime/lever/deployment_tasks.h
@@ -35,14 +35,14 @@ class WorkspaceUpdate : public DeploymentTask {
 class SchemaUpdate : public DeploymentTask {
  public:
   explicit SchemaUpdate(const std::string& schema_file)
-      : schema_file_(schema_file) {}
+      : schema_file_(schema_file), verbose_(false) {}
   SchemaUpdate(TaskInitializer arg);
   bool Run(Deployer* deployer);
   void set_verbose(bool verbose) { verbose_ = verbose; }
 
  protected:
   std::string schema_file_;
-  bool verbose_ = false;
+  bool verbose_;
 };
 
 // update a specific config file
diff --git a/include/rime/lever/switcher_settings.h b/include/rime/lever/switcher_settings.h
index 8263e14..d87f6b9 100644
--- a/include/rime/lever/switcher_settings.h
+++ b/include/rime/lever/switcher_settings.h
@@ -25,13 +25,13 @@ struct SchemaInfo {
 
 class SwitcherSettings : public CustomSettings {
  public:
-  using SchemaList = std::vector<SchemaInfo>;
+  typedef std::vector<SchemaInfo> SchemaList;
   // a list of schema_ids
-  using Selection = std::vector<std::string>;
+  typedef std::vector<std::string> Selection;
   
   explicit SwitcherSettings(Deployer* deployer);
   bool Load();
-  bool Select(Selection selection);
+  bool Select(const Selection& selection);
   bool SetHotkeys(const std::string& hotkeys);
   
   const SchemaList& available() const { return available_; }
diff --git a/include/rime/lever/user_dict_manager.h b/include/rime/lever/user_dict_manager.h
index e971ad8..bc3a03a 100644
--- a/include/rime/lever/user_dict_manager.h
+++ b/include/rime/lever/user_dict_manager.h
@@ -15,7 +15,7 @@ namespace rime {
 
 class Deployer;
 
-using UserDictList = std::vector<std::string>;
+typedef std::vector<std::string> UserDictList;
 
 class UserDictManager {
  public:
diff --git a/include/rime/menu.h b/include/rime/menu.h
index 04f21ad..f175d42 100644
--- a/include/rime/menu.h
+++ b/include/rime/menu.h
@@ -7,8 +7,8 @@
 #ifndef RIME_MENU_H_
 #define RIME_MENU_H_
 
-#include <functional>
 #include <vector>
+#include <boost/function.hpp>
 #include <rime/candidate.h>
 #include <rime/common.h>
 
@@ -17,20 +17,21 @@ namespace rime {
 class Translation;
 
 struct Page {
-  int page_size = 0;
-  int page_no = 0;
-  bool is_last_page = false;
+  int page_size;
+  int page_no;
+  bool is_last_page;
   CandidateList candidates;
 };
 
 class Menu {
  public:
-  using CandidateFilter = std::function<void (CandidateList* recruited,
-                                              CandidateList* candidates)>;
+  typedef boost::function<void (CandidateList *recruited,
+                                CandidateList *candidates)>
+  CandidateFilter;
 
-  Menu() = default;
-  ~Menu() = default;
-  Menu(const CandidateFilter& filter) : filter_(filter) {}
+  Menu() {}
+  Menu(const CandidateFilter &filter) : filter_(filter) {}
+  ~Menu() {}
 
   void AddTranslation(shared_ptr<Translation> translation);
   size_t Prepare(size_t candidate_count);
@@ -46,7 +47,7 @@ class Menu {
   }
 
  private:
-  std::vector<shared_ptr<Translation>> translations_;
+  std::vector<shared_ptr<Translation> > translations_;
   CandidateList candidates_;
   CandidateFilter filter_;
 };
diff --git a/include/rime/messenger.h b/include/rime/messenger.h
index 065d782..433fc55 100644
--- a/include/rime/messenger.h
+++ b/include/rime/messenger.h
@@ -14,11 +14,11 @@ namespace rime {
 
 class Messenger {
  public:
-  using MessageSink = signal<void (const std::string& message_type,
-                                   const std::string& message_value)>;
-
+  typedef signal<void (const std::string& message_type,
+                       const std::string& message_value)> MessageSink;
+  
   MessageSink& message_sink() { return message_sink_; }
-
+  
  protected:
   MessageSink message_sink_;
 };
diff --git a/include/rime/module.h b/include/rime/module.h
index ca1a8c6..9af70f6 100644
--- a/include/rime/module.h
+++ b/include/rime/module.h
@@ -32,7 +32,7 @@ class ModuleManager {
   ModuleManager() {}
 
   // module registry
-  using ModuleMap = std::map<std::string, RimeModule*>;
+  typedef std::map<std::string, RimeModule*> ModuleMap;
   ModuleMap map_;
   // list of loaded modules
   std::vector<RimeModule*> loaded_;
diff --git a/include/rime/processor.h b/include/rime/processor.h
index 70acadd..9b60e5a 100644
--- a/include/rime/processor.h
+++ b/include/rime/processor.h
@@ -25,14 +25,14 @@ class Processor : public Class<Processor, const Ticket&> {
  public:
   explicit Processor(const Ticket& ticket)
       : engine_(ticket.engine), name_space_(ticket.name_space) {}
-  virtual ~Processor() = default;
+  virtual ~Processor() {}
 
   virtual ProcessResult ProcessKeyEvent(const KeyEvent& key_event) {
     return kNoop;
   }
 
  protected:
-  Engine* engine_;
+  Engine *engine_;
   std::string name_space_;
 };
 
diff --git a/include/rime/registry.h b/include/rime/registry.h
index a46d8a2..70c15c9 100644
--- a/include/rime/registry.h
+++ b/include/rime/registry.h
@@ -17,17 +17,17 @@ class ComponentBase;
 
 class Registry {
  public:
-  using ComponentMap = std::map<std::string, ComponentBase*>;
+  typedef std::map<std::string, ComponentBase*> ComponentMap;
 
   ComponentBase* Find(const std::string& name);
-  void Register(const std::string& name, ComponentBase* component);
+  void Register(const std::string& name, ComponentBase *component);
   void Unregister(const std::string& name);
   void Clear();
 
   static Registry& instance();
 
  private:
-  Registry() = default;
+  Registry() {}
 
   ComponentMap map_;
 };
diff --git a/include/rime/schema.h b/include/rime/schema.h
index 570001a..925e986 100644
--- a/include/rime/schema.h
+++ b/include/rime/schema.h
@@ -16,15 +16,15 @@ namespace rime {
 class Schema {
  public:
   Schema();
-  explicit Schema(const std::string& schema_id);
-  Schema(const std::string& schema_id, Config* config)
+  explicit Schema(const std::string &schema_id);
+  Schema(const std::string &schema_id, Config *config)
       : schema_id_(schema_id), config_(config) {}
 
   const std::string& schema_id() const { return schema_id_; }
   const std::string& schema_name() const { return schema_name_; }
 
   Config* config() const { return config_.get(); }
-  void set_config(Config* config) { config_.reset(config); }
+  void set_config(Config *config) { config_.reset(config); }
 
   int page_size() const { return page_size_; }
   const std::string& select_keys() const { return select_keys_; }
@@ -35,9 +35,9 @@ class Schema {
 
   std::string schema_id_;
   std::string schema_name_;
-  unique_ptr<Config> config_;
+  scoped_ptr<Config> config_;
   // frequently used config items
-  int page_size_ = 5;
+  int page_size_;
   std::string select_keys_;
 };
 
diff --git a/include/rime/segmentation.h b/include/rime/segmentation.h
index 9cca324..a51845c 100644
--- a/include/rime/segmentation.h
+++ b/include/rime/segmentation.h
@@ -24,18 +24,21 @@ struct Segment {
     kSelected,
     kConfirmed,
   };
-  Status status = kVoid;
-  size_t start = 0;
-  size_t end = 0;
+  Status status;
+  size_t start;
+  size_t end;
   std::set<std::string> tags;
   shared_ptr<Menu> menu;
-  size_t selected_index = 0;
+  size_t selected_index;
   std::string prompt;
 
-  Segment() = default;
+  Segment()
+  : status(kVoid), start(0), end(0),
+    selected_index(0) {}
 
   Segment(int start_pos, int end_pos)
-      : start(start_pos), end(end_pos) {}
+  : status(kVoid), start(start_pos), end(end_pos),
+    selected_index(0) {}
 
   void Clear() {
     status = kVoid;
@@ -45,7 +48,7 @@ struct Segment {
     prompt.clear();
   }
 
-  bool HasTag(const std::string& tag) const {
+  bool HasTag(const std::string &tag) const {
     return tags.find(tag) != tags.end();
   }
 
@@ -57,9 +60,9 @@ class Segmentation : public std::vector<Segment> {
  public:
   Segmentation();
   virtual ~Segmentation() {}
-  void Reset(const std::string& input);
+  void Reset(const std::string &input);
   void Reset(size_t num_segments);
-  bool AddSegment(const Segment& segment);
+  bool AddSegment(const Segment &segment);
 
   bool Forward();
   bool Trim();
@@ -76,7 +79,7 @@ class Segmentation : public std::vector<Segment> {
 };
 
 std::ostream& operator<< (std::ostream& out,
-                          const Segmentation& segmentation);
+                          const Segmentation &segmentation);
 
 }  // namespace rime
 
diff --git a/include/rime/segmentor.h b/include/rime/segmentor.h
index e457178..958980e 100644
--- a/include/rime/segmentor.h
+++ b/include/rime/segmentor.h
@@ -19,12 +19,12 @@ class Segmentor : public Class<Segmentor, const Ticket&> {
  public:
   explicit Segmentor(const Ticket& ticket)
       : engine_(ticket.engine), name_space_(ticket.name_space) {}
-  virtual ~Segmentor() = default;
+  virtual ~Segmentor() {}
 
-  virtual bool Proceed(Segmentation* segmentation) = 0;
+  virtual bool Proceed(Segmentation *segmentation) = 0;
 
  protected:
-  Engine* engine_;
+  Engine *engine_;
   std::string name_space_;
 };
 
diff --git a/include/rime/service.h b/include/rime/service.h
index 362c85d..c62286e 100644
--- a/include/rime/service.h
+++ b/include/rime/service.h
@@ -9,21 +9,20 @@
 
 #include <stdint.h>
 #include <time.h>
-#include <functional>
 #include <map>
-#include <mutex>
+#include <boost/thread.hpp>
 #include <rime/common.h>
 #include <rime/deployer.h>
 
 namespace rime {
 
-using SessionId = uintptr_t;
+typedef uintptr_t SessionId;
 
 static const SessionId kInvalidSessionId = 0;
 
-using NotificationHandler = std::function<void (SessionId session_id,
-                                                const char* message_type,
-                                                const char* message_value)>;
+typedef boost::function<void (SessionId session_id,
+                              const char* message_type,
+                              const char* message_value)> NotificationHandler;
 
 class Context;
 class Engine;
@@ -48,10 +47,10 @@ class Session {
   const std::string& commit_text() const { return commit_text_; }
 
  private:
-  void OnCommit(const std::string& commit_text);
+  void OnCommit(const std::string &commit_text);
 
-  unique_ptr<Engine> engine_;
-  time_t last_active_time_ = 0;
+  scoped_ptr<Engine> engine_;
+  time_t last_active_time_;
   std::string commit_text_;
 };
 
@@ -82,12 +81,12 @@ class Service {
  private:
   Service();
 
-  using SessionMap = std::map<SessionId, shared_ptr<Session>>;
+  typedef std::map<SessionId, shared_ptr<Session> > SessionMap;
   SessionMap sessions_;
   Deployer deployer_;
   NotificationHandler notification_handler_;
-  std::mutex mutex_;
-  bool started_ = false;
+  boost::mutex mutex_;
+  bool started_;
 };
 
 }  // namespace rime
diff --git a/include/rime/switcher.h b/include/rime/switcher.h
index c0eb5f3..9c725c9 100644
--- a/include/rime/switcher.h
+++ b/include/rime/switcher.h
@@ -47,17 +47,17 @@ class Switcher : public Processor, public Engine {
   void LoadSettings();
   void RestoreSavedOptions();
   void HighlightNextSchema();
-  void OnSelect(Context* ctx);
+  void OnSelect(Context *ctx);
 
-  unique_ptr<Config> user_config_;
+  scoped_ptr<Config> user_config_;
   std::string caption_;
   std::vector<KeyEvent> hotkeys_;
   std::set<std::string> save_options_;
-  bool fold_options_ = false;
+  bool fold_options_;
 
-  std::vector<shared_ptr<Processor>> processors_;
-  std::vector<shared_ptr<Translator>> translators_;
-  bool active_ = false;
+  std::vector<shared_ptr<Processor> > processors_;
+  std::vector<shared_ptr<Translator> > translators_;
+  bool active_;
 };
 
 class SwitcherCommand {
diff --git a/include/rime/ticket.h b/include/rime/ticket.h
index 3dc6999..f871a7e 100644
--- a/include/rime/ticket.h
+++ b/include/rime/ticket.h
@@ -15,12 +15,12 @@ class Engine;
 class Schema;
 
 struct Ticket {
-  Engine* engine = nullptr;
-  Schema* schema = nullptr;
+  Engine* engine;
+  Schema* schema;
   std::string name_space;
   std::string klass;
 
-  Ticket() = default;
+  Ticket();
   Ticket(Schema* s, const std::string& ns);
   // prescription: in the form of "klass" or "klass@alias"
   // where alias, if given, will override default name space
diff --git a/include/rime/translation.h b/include/rime/translation.h
index dfd5e25..c2a6191 100644
--- a/include/rime/translation.h
+++ b/include/rime/translation.h
@@ -18,8 +18,8 @@ namespace rime {
 
 class Translation {
  public:
-  Translation() = default;
-  virtual ~Translation() = default;
+  Translation() : exhausted_(false) {}
+  virtual ~Translation() {}
 
   // A translation may contain multiple results, looks
   // something like a generator of candidates.
@@ -30,7 +30,7 @@ class Translation {
   // should it provide the next candidate (negative value, zero) or
   // should it give up the chance for other translations (positive)?
   virtual int Compare(shared_ptr<Translation> other,
-                      const CandidateList& candidates);
+                      const CandidateList &candidates);
 
   bool exhausted() const { return exhausted_; }
 
@@ -38,12 +38,12 @@ class Translation {
   void set_exhausted(bool exhausted) { exhausted_ = exhausted; }
 
  private:
-  bool exhausted_ = false;
+  bool exhausted_;
 };
 
 class UniqueTranslation : public Translation {
  public:
-  UniqueTranslation(shared_ptr<Candidate> candidate)
+  UniqueTranslation(const shared_ptr<Candidate> &candidate)
       : candidate_(candidate) {
   }
 
@@ -68,8 +68,8 @@ class FifoTranslation : public Translation {
   }
 
  protected:
-  std::vector<shared_ptr<Candidate>> candies_;
-  size_t cursor_ = 0;
+  std::vector<shared_ptr<Candidate> > candies_;
+  size_t cursor_;
 };
 
 class UnionTranslation : public Translation {
@@ -82,7 +82,7 @@ class UnionTranslation : public Translation {
   UnionTranslation& operator+= (shared_ptr<Translation> t);
 
  protected:
-  std::list<shared_ptr<Translation>> translations_;
+  std::list<shared_ptr<Translation> > translations_;
 };
 
 shared_ptr<UnionTranslation> operator+ (shared_ptr<Translation> a,
diff --git a/include/rime/translator.h b/include/rime/translator.h
index 94c6a3a..7f67d55 100644
--- a/include/rime/translator.h
+++ b/include/rime/translator.h
@@ -23,14 +23,14 @@ class Translator : public Class<Translator, const Ticket&> {
  public:
   explicit Translator(const Ticket& ticket)
       : engine_(ticket.engine), name_space_(ticket.name_space) {}
-  virtual ~Translator() = default;
+  virtual ~Translator() {}
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt = NULL) = 0;
 
  protected:
-  Engine* engine_;
+  Engine *engine_;
   std::string name_space_;
 };
 
diff --git a/sample/src/trivial_translator.cc b/sample/src/trivial_translator.cc
index 3013cb5..c17ea5a 100644
--- a/sample/src/trivial_translator.cc
+++ b/sample/src/trivial_translator.cc
@@ -31,27 +31,28 @@ TrivialTranslator::TrivialTranslator(const Ticket& ticket)
   dictionary_["wan"] = "\xe8\x90\xac";  // 萬
 }
 
-shared_ptr<Translation> TrivialTranslator::Query(const std::string& input,
-                                                 const Segment& segment,
+shared_ptr<Translation> TrivialTranslator::Query(const std::string &input,
+                                                 const Segment &segment,
                                                  std::string* prompt) {
-  if (!segment.HasTag("abc"))
-    return nullptr;
+  if (!segment.HasTag(tag_))
+    return shared_ptr<Translation>();
   DLOG(INFO) << "input = '" << input
              << "', [" << segment.start << ", " << segment.end << ")";
-  std::string output = Translate(input);
+  std::string output(Translate(input));
   if (output.empty()) {
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  auto candidate = New<SimpleCandidate>(
-      "trivial",
-      segment.start,
-      segment.end,
-      output,
-      ":-)");
-  return New<UniqueTranslation>(candidate);
+  shared_ptr<Candidate> candidate =
+      boost::make_shared<SimpleCandidate>(
+          "trivial",
+          segment.start,
+          segment.end,
+          output,
+          ":-)");
+  return make_shared<UniqueTranslation>(candidate);
 }
 
-std::string TrivialTranslator::Translate(const std::string& input) {
+std::string TrivialTranslator::Translate(const std::string &input) {
   const size_t kMinPinyinLength = 2;
   const size_t kMaxPinyinLength = 6;
   std::string result;
@@ -60,7 +61,8 @@ std::string TrivialTranslator::Translate(const std::string& input) {
     int translated = 0;
     size_t len = (std::max)(kMaxPinyinLength, input_len - i);
     for ( ; len >= kMinPinyinLength; --len) {
-      auto it = dictionary_.find(input.substr(i, len));
+      TrivialDictionary::const_iterator it =
+          dictionary_.find(input.substr(i, len));
       if (it != dictionary_.end()) {
         result += it->second;
         translated = len;
diff --git a/sample/src/trivial_translator.h b/sample/src/trivial_translator.h
index dafefbc..9fbaab4 100644
--- a/sample/src/trivial_translator.h
+++ b/sample/src/trivial_translator.h
@@ -22,14 +22,14 @@ class TrivialTranslator : public Translator {
  public:
   TrivialTranslator(const Ticket& ticket);
 
-  virtual shared_ptr<Translation> Query(const std::string& input,
-                                        const Segment& segment,
+  virtual shared_ptr<Translation> Query(const std::string &input,
+                                        const Segment &segment,
                                         std::string* prompt);
 
  private:
-  std::string Translate(const std::string& input);
+  std::string Translate(const std::string &input);
 
-  using TrivialDictionary = std::map<std::string, std::string>;
+  typedef std::map<std::string, std::string> TrivialDictionary;
   TrivialDictionary dictionary_;
 };
 
diff --git a/sample/test/trivial_translator_test.cc b/sample/test/trivial_translator_test.cc
index b66913c..16ff0c7 100644
--- a/sample/test/trivial_translator_test.cc
+++ b/sample/test/trivial_translator_test.cc
@@ -17,12 +17,13 @@ using namespace rime;
 
 TEST(/*DISABLED_*/TrivialTranslatorTest, Query) {
   // make sure the component has been registered
-  auto component = Translator::Require("trivial_translator");
+  Translator::Component *component =
+      Translator::Require("trivial_translator");
   ASSERT_TRUE(component != NULL);
   Ticket ticket;
-  unique_ptr<Translator> translator(component->Create(ticket));
+  scoped_ptr<Translator> translator(component->Create(ticket));
   // make sure the dict object has been created
-  ASSERT_TRUE(bool(translator));
+  ASSERT_TRUE(translator);
   // lookup test
   const std::string test_input("yiqianerbaisanshisi");
   // 一千二百三十四
@@ -33,12 +34,14 @@ TEST(/*DISABLED_*/TrivialTranslatorTest, Query) {
                                     "\xe4\xb8\x89"
                                     "\xe5\x8d\x81"
                                     "\xe5\x9b\x9b");
-  Segment segment(0, test_input.length());
+  Segment segment;
+  segment.start = 0;
+  segment.end = test_input.length();
   segment.tags.insert("abc");
-  auto translation = translator->Query(test_input, segment);
-  ASSERT_TRUE(bool(translation));
+  shared_ptr<Translation> translation(translator->Query(test_input, segment));
+  ASSERT_TRUE(translation);
   ASSERT_FALSE(translation->exhausted());
-  auto candidate = translation->Peek();
+  shared_ptr<Candidate> candidate = translation->Peek();
   ASSERT_TRUE(bool(candidate));
   EXPECT_EQ("trivial", candidate->type());
   EXPECT_EQ(expected_output, candidate->text());
diff --git a/shell.bat b/shell.bat
index 0776a89..04c087f 100644
--- a/shell.bat
+++ b/shell.bat
@@ -4,4 +4,4 @@ set OLD_PATH=%PATH%
 if defined DEV_PATH set PATH=%OLD_PATH%;%DEV_PATH%
 rem %comspec%
 rem %comspec% /k ""C:\Program Files\Microsoft Visual Studio 9.0\VC\vcvarsall.bat"" x86
-%comspec% /k ""C:\Program Files (x86)\Microsoft Visual Studio 12.0\VC\vcvarsall.bat"" x86
+%comspec% /k ""C:\Program Files\Microsoft Visual Studio 10.0\VC\vcvarsall.bat"" x86
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index d981966..85964cb 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -20,6 +20,9 @@ endif(Gflags_FOUND)
 
 set(RIME_CORE_DEPS ${Boost_LIBRARIES} ${Glog_LIBRARY} ${YamlCpp_LIBRARY} ${CMAKE_THREAD_LIBS_INIT} ${RIME_OPTIONAL_DEPS})
 set(RIME_EXTRA_DEPS ${KyotoCabinet_LIBRARY} ${Marisa_LIBRARY} ${Opencc_LIBRARY} ${ZLIB_LIBRARY})
+if(UNIX AND NOT APPLE)
+    set(RIME_EXTRA_DEPS ${RIME_EXTRA_DEPS} rt)
+endif()
 
 if(BUILD_SEPARATE_LIBS)
   set(RIME_DEPS ${RIME_CORE_DEPS})
diff --git a/src/algo/algebra.cc b/src/algo/algebra.cc
index 0e592ee..8e74dc8 100644
--- a/src/algo/algebra.cc
+++ b/src/algo/algebra.cc
@@ -6,6 +6,7 @@
 //
 #include <algorithm>
 #include <fstream>
+#include <boost/foreach.hpp>
 #include <rime/algo/algebra.h>
 #include <rime/algo/calculus.h>
 
@@ -23,7 +24,7 @@ void Script::Merge(const std::string& s,
                    const SpellingProperties& sp,
                    const std::vector<Spelling>& v) {
   std::vector<Spelling>& m((*this)[s]);
-  for (const Spelling& x : v) {
+  BOOST_FOREACH(const Spelling& x, v) {
     Spelling y(x);
     SpellingProperties& yy(y.properties);
     {
@@ -33,7 +34,7 @@ void Script::Merge(const std::string& s,
       if (!sp.tips.empty())
         yy.tips = sp.tips;
     }
-    auto e = std::find(m.begin(), m.end(), x);
+    std::vector<Spelling>::iterator e = std::find(m.begin(), m.end(), x);
     if (e == m.end()) {
       m.push_back(y);
     }
@@ -50,9 +51,9 @@ void Script::Merge(const std::string& s,
 
 void Script::Dump(const std::string& file_name) const {
   std::ofstream out(file_name.c_str());
-  for (const value_type& v : *this) {
+  BOOST_FOREACH(const value_type& v, *this) {
     bool first = true;
-    for (const Spelling& s : v.second) {
+    BOOST_FOREACH(const Spelling& s, v.second) {
       out << (first ? v.first : "") << '\t'
           << s.str << '\t'
           << "-ac?!"[s.properties.type] << '\t'
@@ -103,7 +104,7 @@ bool Projection::Apply(std::string* value) {
     return false;
   bool modified = false;
   Spelling s(*value);
-  for (shared_ptr<Calculation>& x : calculation_) {
+  BOOST_FOREACH(shared_ptr<Calculation>& x, calculation_) {
     try {
       if (x->Apply(&s))
         modified = true;
@@ -123,11 +124,11 @@ bool Projection::Apply(Script* value) {
     return false;
   bool modified = false;
   int round = 0;
-  for (shared_ptr<Calculation>& x : calculation_) {
+  BOOST_FOREACH(shared_ptr<Calculation>& x, calculation_) {
     ++round;
     DLOG(INFO) << "round #" << round;
     Script temp;
-    for (const Script::value_type& v : *value) {
+    BOOST_FOREACH(const Script::value_type& v, *value) {
       Spelling s(v.first);
       bool applied = false;
       try {
diff --git a/src/algo/encoder.cc b/src/algo/encoder.cc
index 26612bd..ae597d8 100644
--- a/src/algo/encoder.cc
+++ b/src/algo/encoder.cc
@@ -5,6 +5,7 @@
 // 2013-07-17 GONG Chen <chen.sst@gmail.com>
 //
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <utf8.h>
 #include <rime/config.h>
 #include <rime/algo/encoder.h>
@@ -53,9 +54,9 @@ bool TableEncoder::LoadSettings(Config* config) {
 
   if (!config) return false;
 
-  if (auto rules = config->GetList("encoder/rules")) {
-    for (auto it = rules->begin(); it != rules->end(); ++it) {
-      auto rule = As<ConfigMap>(*it);
+  if (ConfigListPtr rules = config->GetList("encoder/rules")) {
+    for (ConfigList::Iterator it = rules->begin(); it != rules->end(); ++it) {
+      ConfigMapPtr rule = As<ConfigMap>(*it);
       if (!rule || !rule->HasKey("formula"))
         continue;
       const std::string formula(rule->GetValue("formula")->str());
@@ -74,7 +75,8 @@ bool TableEncoder::LoadSettings(Config* config) {
           max_phrase_length_ = length;
         }
       }
-      else if (auto range = As<ConfigList>(rule->Get("length_in_range"))) {
+      else if (ConfigListPtr range =
+               As<ConfigList>(rule->Get("length_in_range"))) {
         if (range->size() != 2 ||
             !range->GetValueAt(0) ||
             !range->GetValueAt(1) ||
@@ -94,9 +96,10 @@ bool TableEncoder::LoadSettings(Config* config) {
       max_phrase_length_ = kMaxPhraseLength;
     }
   }
-  if (auto excludes = config->GetList("encoder/exclude_patterns")) {
-    for (auto it = excludes->begin(); it != excludes->end(); ++it) {
-      auto pattern = As<ConfigValue>(*it);
+  if (ConfigListPtr excludes = config->GetList("encoder/exclude_patterns")) {
+    for (ConfigList::Iterator it = excludes->begin();
+         it != excludes->end(); ++it) {
+      ConfigValuePtr pattern = As<ConfigValue>(*it);
       if (!pattern)
         continue;
       exclude_patterns_.push_back(boost::regex(pattern->str()));
@@ -114,7 +117,8 @@ bool TableEncoder::ParseFormula(const std::string& formula,
     LOG(ERROR) << "bad formula: '%s'" << formula;
     return false;
   }
-  for (auto it = formula.cbegin(), end = formula.cend(); it != end; ) {
+  for (std::string::const_iterator it = formula.begin(), end = formula.end();
+       it != end; ) {
     CodeCoords c;
     if (*it < 'A' || *it > 'Z') {
       LOG(ERROR) << "invalid character index in formula: '%s'" << formula;
@@ -134,7 +138,7 @@ bool TableEncoder::ParseFormula(const std::string& formula,
 }
 
 bool TableEncoder::IsCodeExcluded(const std::string& code) {
-  for (const boost::regex& pattern : exclude_patterns_) {
+  BOOST_FOREACH(const boost::regex& pattern, exclude_patterns_) {
     if (boost::regex_match(code, pattern))
       return true;
   }
@@ -143,7 +147,7 @@ bool TableEncoder::IsCodeExcluded(const std::string& code) {
 
 bool TableEncoder::Encode(const RawCode& code, std::string* result) {
   int num_syllables = static_cast<int>(code.size());
-  for (const TableEncodingRule& rule : encoding_rules_) {
+  BOOST_FOREACH(const TableEncodingRule& rule, encoding_rules_) {
     if (num_syllables < rule.min_word_length ||
         num_syllables > rule.max_word_length) {
       continue;
@@ -151,7 +155,7 @@ bool TableEncoder::Encode(const RawCode& code, std::string* result) {
     result->clear();
     CodeCoords previous = {0, 0};
     CodeCoords encoded = {0, 0};
-    for (const CodeCoords& current : rule.coords) {
+    BOOST_FOREACH(const CodeCoords& current, rule.coords) {
       CodeCoords c(current);
       if (c.char_index < 0) {
         c.char_index += num_syllables;
@@ -283,7 +287,7 @@ bool TableEncoder::DfsEncode(const std::string& phrase,
   bool ret = false;
   std::vector<std::string> translations;
   if (collector_->TranslateWord(word, &translations)) {
-    for (const std::string& x : translations) {
+    BOOST_FOREACH(const std::string& x, translations) {
       if (IsCodeExcluded(x)) {
         continue;
       }
@@ -332,7 +336,7 @@ bool ScriptEncoder::DfsEncode(const std::string& phrase,
     std::string word(phrase.substr(start_pos, k));
     std::vector<std::string> translations;
     if (collector_->TranslateWord(word, &translations)) {
-      for (const std::string& x : translations) {
+      BOOST_FOREACH(const std::string& x, translations) {
         code->push_back(x);
         bool ok = DfsEncode(phrase, value, start_pos + k, code, limit);
         ret = ret || ok;
diff --git a/src/algo/syllabifier.cc b/src/algo/syllabifier.cc
index 4b4e4a0..83bba6e 100644
--- a/src/algo/syllabifier.cc
+++ b/src/algo/syllabifier.cc
@@ -5,19 +5,20 @@
 // 2011-07-12 Zou Xu <zouivex@gmail.com>
 // 2012-02-11 GONG Chen <chen.sst@gmail.com>
 //
+#include <functional>
 #include <queue>
 #include <utility>
 #include <vector>
-#include <boost/range/adaptor/reversed.hpp>
+#include <boost/foreach.hpp>
 #include <rime/dict/prism.h>
 #include <rime/algo/syllabifier.h>
 
 namespace rime {
 
-using Vertex = std::pair<size_t, SpellingType>;
-using VertexQueue = std::priority_queue<Vertex,
-                                        std::vector<Vertex>,
-                                        std::greater<Vertex>>;
+typedef std::pair<size_t, SpellingType> Vertex;
+typedef std::priority_queue<Vertex,
+                            std::vector<Vertex>,
+                            std::greater<Vertex> > VertexQueue;
 
 int Syllabifier::BuildSyllableGraph(const std::string &input,
                                     Prism &prism,
@@ -27,7 +28,7 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
 
   size_t farthest = 0;
   VertexQueue queue;
-  queue.push(Vertex{0, kNormalSpelling});  // start
+  queue.push(Vertex(0, kNormalSpelling));  // start
 
   while (!queue.empty()) {
     Vertex vertex(queue.top());
@@ -35,7 +36,8 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
     size_t current_pos = vertex.first;
 
     // record a visit to the vertex
-    if (graph->vertices.find(current_pos) == graph->vertices.end())
+    VertexMap::iterator it = graph->vertices.find(current_pos);
+    if (it == graph->vertices.end())
       graph->vertices.insert(vertex);  // preferred spelling type comes first
     else
       continue;  // discard worse spelling types
@@ -48,8 +50,8 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
     std::vector<Prism::Match> matches;
     prism.CommonPrefixSearch(input.substr(current_pos), &matches);
     if (!matches.empty()) {
-      auto& end_vertices(graph->edges[current_pos]);
-      for (const auto& m : matches) {
+      EndVertexMap &end_vertices(graph->edges[current_pos]);
+      BOOST_FOREACH(const Prism::Match &m, matches) {
         if (m.length == 0) continue;
         size_t end_pos = current_pos + m.length;
         // consume trailing delimiters
@@ -65,8 +67,8 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
         // otherwise, it resembles exactly the syllable itself.
         SpellingAccessor accessor(prism.QuerySpelling(m.value));
         while (!accessor.exhausted()) {
-          SyllableId syllable_id = accessor.syllable_id();
-          SpellingProperties props = accessor.properties();
+          SyllableId syllable_id(accessor.syllable_id());
+          SpellingProperties props(accessor.properties());
           if (strict_spelling_ &&
               matches_input &&
               props.type != kNormalSpelling) {
@@ -76,7 +78,7 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
             props.end_pos = end_pos;
             // add a syllable with properties to the edge's
             // spelling-to-syllable map
-            spellings.insert({syllable_id, props});
+            spellings.insert(SpellingMap::value_type(syllable_id, props));
             // let end_vertex_type be the best (smaller) type of spelling
             // that ends at the vertex
             if (end_vertex_type > props.type) {
@@ -96,7 +98,7 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
         if (end_vertex_type < vertex.second) {
           end_vertex_type = vertex.second;
         }
-        queue.push(Vertex{end_pos, end_vertex_type});
+        queue.push(Vertex(end_pos, end_vertex_type));
         DLOG(INFO) << "added to syllable graph, edge: ["
                    << current_pos << ", " << end_pos << ")";
       }
@@ -113,7 +115,8 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
     if (graph->vertices.find(i) == graph->vertices.end())
       continue;
     // remove stale edges
-    for (auto j = graph->edges[i].begin(); j != graph->edges[i].end(); ) {
+    for (EndVertexMap::iterator j = graph->edges[i].begin();
+         j != graph->edges[i].end(); ) {
       if (good.find(j->first) == good.end()) {
         // not connected
         graph->edges[i].erase(j++);
@@ -122,7 +125,8 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
       // remove disqualified syllables (eg. matching abbreviated spellings)
       // when there is a path of more favored type
       SpellingType edge_type = kInvalidSpelling;
-      for (auto k = j->second.begin(); k != j->second.end(); ) {
+      for (SpellingMap::iterator k = j->second.begin();
+           k != j->second.end(); ) {
         if (k->second.type > last_type) {
           j->second.erase(k++);
         }
@@ -160,24 +164,24 @@ int Syllabifier::BuildSyllableGraph(const std::string &input,
       size_t current_pos = farthest;
       size_t end_pos = input.length();
       size_t code_length = end_pos - current_pos;
-      auto& end_vertices(graph->edges[current_pos]);
-      auto& spellings(end_vertices[end_pos]);
-      for (const auto& m : keys) {
+      EndVertexMap &end_vertices(graph->edges[current_pos]);
+      SpellingMap &spellings(end_vertices[end_pos]);
+      BOOST_FOREACH(const Prism::Match &m, keys) {
         if (m.length < code_length) continue;
         // when spelling algebra is enabled,
         // a spelling evaluates to a set of syllables;
         // otherwise, it resembles exactly the syllable itself.
         SpellingAccessor accessor(prism.QuerySpelling(m.value));
         while (!accessor.exhausted()) {
-          SyllableId syllable_id = accessor.syllable_id();
-          SpellingProperties props = accessor.properties();
+          SyllableId syllable_id(accessor.syllable_id());
+          SpellingProperties props(accessor.properties());
           if (props.type < kAbbreviation) {
             props.type = kCompletion;
             props.credibility *= 0.5;
             props.end_pos = end_pos;
             // add a syllable with properties to the edge's
             // spelling-to-syllable map
-            spellings.insert({syllable_id, props});
+            spellings.insert(SpellingMap::value_type(syllable_id, props));
           }
           accessor.Next();
         }
@@ -210,16 +214,16 @@ void Syllabifier::CheckOverlappedSpellings(SyllableGraph *graph,
   if (!graph || graph->edges.find(start) == graph->edges.end())
     return;
   // if "Z" = "YX", mark the vertex between Y and X an ambiguous syllable joint
-  auto& y_end_vertices(graph->edges[start]);
+  EndVertexMap& y_end_vertices(graph->edges[start]);
   // enumerate Ys
-  for (const auto& y : y_end_vertices) {
+  BOOST_FOREACH(const EndVertexMap::value_type& y, y_end_vertices) {
     size_t joint = y.first;
     if (joint >= end) break;
     // test X
     if (graph->edges.find(joint) == graph->edges.end())
       continue;
-    auto& x_end_vertices(graph->edges[joint]);
-    for (const auto& x : x_end_vertices) {
+    EndVertexMap& x_end_vertices(graph->edges[joint]);
+    BOOST_FOREACH(const EndVertexMap::value_type& x, x_end_vertices) {
       if (x.first < end) continue;
       if (x.first == end) {
         graph->vertices[joint] = kAmbiguousSpelling;
@@ -231,10 +235,10 @@ void Syllabifier::CheckOverlappedSpellings(SyllableGraph *graph,
 }
 
 void Syllabifier::Transpose(SyllableGraph* graph) {
-  for (const auto& start : graph->edges) {
-    auto& index(graph->indices[start.first]);
-    for (const auto& end : boost::adaptors::reverse(start.second)) {
-      for (const auto& spelling : end.second) {
+  BOOST_FOREACH(const EdgeMap::value_type& start, graph->edges) {
+    SpellingIndex& index(graph->indices[start.first]);
+    BOOST_REVERSE_FOREACH(const EndVertexMap::value_type& end, start.second) {
+      BOOST_FOREACH(const SpellingMap::value_type& spelling, end.second) {
         SyllableId syll_id = spelling.first;
         index[syll_id].push_back(&spelling.second);
       }
diff --git a/src/candidate.cc b/src/candidate.cc
index 0bebbab..0a7b389 100644
--- a/src/candidate.cc
+++ b/src/candidate.cc
@@ -4,27 +4,29 @@
 //
 // 2013-01-06 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 
 namespace rime {
 
 static shared_ptr<Candidate>
-UnpackShadowCandidate(const shared_ptr<Candidate>& cand) {
-  auto shadow = As<ShadowCandidate>(cand);
+UnpackShadowCandidate(shared_ptr<Candidate> cand) {
+  shared_ptr<ShadowCandidate> shadow(As<ShadowCandidate>(cand));
   return shadow ? shadow->item() : cand;
 }
 
 shared_ptr<Candidate>
 Candidate::GetGenuineCandidate(const shared_ptr<Candidate>& cand) {
-  auto uniquified = As<UniquifiedCandidate>(cand);
+  shared_ptr<UniquifiedCandidate> uniquified(As<UniquifiedCandidate>(cand));
   return UnpackShadowCandidate(uniquified ? uniquified->items().front() : cand);
 }
 
-std::vector<shared_ptr<Candidate>>
+std::vector<shared_ptr<Candidate> >
 Candidate::GetGenuineCandidates(const shared_ptr<Candidate>& cand) {
-  std::vector<shared_ptr<Candidate>> result;
-  if (auto uniquified = As<UniquifiedCandidate>(cand)) {
-    for (const auto& item : uniquified->items()) {
+  std::vector<shared_ptr<Candidate> > result;
+  shared_ptr<UniquifiedCandidate> uniquified(As<UniquifiedCandidate>(cand));
+  if (uniquified) {
+    BOOST_FOREACH(const shared_ptr<Candidate>& item, uniquified->items()) {
       result.push_back(UnpackShadowCandidate(item));
     }
   }
diff --git a/src/commit_history.cc b/src/commit_history.cc
index 7556593..995896a 100644
--- a/src/commit_history.cc
+++ b/src/commit_history.cc
@@ -4,6 +4,7 @@
 //
 // 2012-04-27 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/commit_history.h>
 #include <rime/composition.h>
@@ -34,15 +35,16 @@ void CommitHistory::Push(const Composition& composition,
                          const std::string& input) {
   CommitRecord* last = NULL;
   size_t end = 0;
-  for (const Segment& seg : composition) {
-    if (auto cand = seg.GetSelectedCandidate()) {
+  BOOST_FOREACH(const Segment &seg, composition) {
+    shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
+    if (cand) {
       if (last && last->type == cand->type()) {
         // join adjacent text of same type
         last->text += cand->text();
       }
       else {
         // new record
-        Push({cand->type(), cand->text()});
+        Push(CommitRecord(cand->type(), cand->text()));
         last = &back();
       }
       if (seg.status >= Segment::kConfirmed) {
@@ -53,18 +55,18 @@ void CommitHistory::Push(const Composition& composition,
     }
     else {
       // no translation for the segment
-      Push({"raw", input.substr(seg.start, seg.end - seg.start)});
+      Push(CommitRecord("raw", input.substr(seg.start, seg.end - seg.start)));
       end = seg.end;
     }
   }
   if (input.length() > end) {
-    Push({"raw", input.substr(end)});
+    Push(CommitRecord("raw", input.substr(end)));
   }
 }
 
 std::string CommitHistory::repr() const {
   std::string result;
-  for (const CommitRecord& record : *this) {
+  BOOST_FOREACH(const CommitRecord& record, *this) {
     result += "[" + record.type + "]" + record.text;
   }
   return result;
diff --git a/src/composition.cc b/src/composition.cc
index b6d6f48..8c80223 100644
--- a/src/composition.cc
+++ b/src/composition.cc
@@ -4,22 +4,25 @@
 //
 // 2011-06-19 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/composition.h>
 #include <rime/menu.h>
 
 namespace rime {
 
+Composition::Composition() {
+}
+
 bool Composition::HasFinishedComposition() const {
-  if (empty())
-    return false;
+  if (empty()) return false;
   size_t k = size() - 1;
   if (k > 0 && at(k).start == at(k).end)
     --k;
   return at(k).status >= Segment::kSelected;
 }
 
-void Composition::GetPreedit(Preedit* preedit) const {
+void Composition::GetPreedit(Preedit *preedit) const {
   if (!preedit)
     return;
   preedit->text.clear();
@@ -31,7 +34,7 @@ void Composition::GetPreedit(Preedit* preedit) const {
   size_t end = 0;
   for (size_t i = 0; i < size(); ++i) {
     start = end;
-    auto cand = at(i).GetSelectedCandidate();
+    shared_ptr<Candidate> cand(at(i).GetSelectedCandidate());
     if (i < size() - 1) {  // converted
       if (cand) {
         end = cand->end();
@@ -71,8 +74,9 @@ void Composition::GetPreedit(Preedit* preedit) const {
 std::string Composition::GetCommitText() const {
   std::string result;
   size_t end = 0;
-  for (const Segment& seg : *this) {
-    if (auto cand = seg.GetSelectedCandidate()) {
+  BOOST_FOREACH(const Segment &seg, *this) {
+    shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
+    if (cand) {
       end = cand->end();
       result += cand->text();
     }
@@ -93,8 +97,8 @@ std::string Composition::GetScriptText() const {
   std::string result;
   size_t start = 0;
   size_t end = 0;
-  for (const Segment& seg : *this) {
-    auto cand = seg.GetSelectedCandidate();
+  BOOST_FOREACH(const Segment &seg, *this) {
+    shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
     start = end;
     end = cand ? cand->end() : seg.end;
     if (cand && !cand->preedit().empty())
@@ -111,13 +115,13 @@ std::string Composition::GetScriptText() const {
 std::string Composition::GetDebugText() const {
   std::string result;
   int i = 0;
-  for (const Segment& seg : *this) {
+  BOOST_FOREACH(const Segment &seg, *this) {
     if (i++ > 0)
       result += "|";
     if (!seg.tags.empty()) {
       result += "{";
       int j = 0;
-      for (const std::string& tag : seg.tags) {
+      BOOST_FOREACH(const std::string& tag, seg.tags) {
         if (j++ > 0)
           result += ",";
         result += tag;
@@ -125,7 +129,7 @@ std::string Composition::GetDebugText() const {
       result += "}";
     }
     result += input_.substr(seg.start, seg.end - seg.start);
-    if (auto cand = seg.GetSelectedCandidate()) {
+    if (shared_ptr<Candidate> cand = seg.GetSelectedCandidate()) {
       result += "=>";
       result += cand->text();
     }
diff --git a/src/config.cc b/src/config.cc
index 7aa0cbd..ef4e280 100644
--- a/src/config.cc
+++ b/src/config.cc
@@ -2,7 +2,7 @@
 // Copyleft RIME Developers
 // License: GPLv3
 //
-// 2011-04-06 Zou Xu <zouivex@gmail.com>
+// 2011-4-6 Zou xu <zouivex@gmail.com>
 //
 #include <cstdlib>
 #include <fstream>
@@ -19,14 +19,14 @@ namespace rime {
 
 class ConfigData {
  public:
-  ConfigData() = default;
+  ConfigData() : modified_(false) {}
   ~ConfigData();
 
   bool LoadFromStream(std::istream& stream);
   bool SaveToStream(std::ostream& stream);
   bool LoadFromFile(const std::string& file_name);
   bool SaveToFile(const std::string& file_name);
-  ConfigItemPtr Traverse(const std::string& key);
+  ConfigItemPtr Traverse(const std::string &key);
 
   bool modified() const { return modified_; }
   void set_modified() { modified_ = true; }
@@ -34,26 +34,26 @@ class ConfigData {
   ConfigItemPtr root;
 
  protected:
-  static ConfigItemPtr ConvertFromYaml(const YAML::Node& yaml_node);
-  static void EmitYaml(ConfigItemPtr node,
-                       YAML::Emitter* emitter,
+  static ConfigItemPtr ConvertFromYaml(const YAML::Node &yaml_node);
+  static void EmitYaml(const ConfigItemPtr &node,
+                       YAML::Emitter *emitter,
                        int depth);
-  static void EmitScalar(const std::string& str_value,
-                         YAML::Emitter* emitter);
+  static void EmitScalar(const std::string &str_value,
+                         YAML::Emitter *emitter);
 
   std::string file_name_;
-  bool modified_ = false;
+  bool modified_;
 };
 
-class ConfigDataManager : public std::map<std::string, weak_ptr<ConfigData>> {
+class ConfigDataManager : public std::map<std::string, weak_ptr<ConfigData> > {
  public:
-  shared_ptr<ConfigData> GetConfigData(const std::string& config_file_path);
-  bool ReloadConfigData(const std::string& config_file_path);
+  shared_ptr<ConfigData> GetConfigData(const std::string &config_file_path);
+  bool ReloadConfigData(const std::string &config_file_path);
 
   static ConfigDataManager& instance();
 
  private:
-  ConfigDataManager() = default;
+  ConfigDataManager() {}
 };
 
 // ConfigValue members
@@ -73,15 +73,15 @@ ConfigValue::ConfigValue(double value)
   SetDouble(value);
 }
 
-ConfigValue::ConfigValue(const char* value)
+ConfigValue::ConfigValue(const char *value)
     : ConfigItem(kScalar), value_(value) {
 }
 
-ConfigValue::ConfigValue(const std::string& value)
+ConfigValue::ConfigValue(const std::string &value)
     : ConfigItem(kScalar), value_(value) {
 }
 
-bool ConfigValue::GetBool(bool* value) const {
+bool ConfigValue::GetBool(bool *value) const {
   if (!value || value_.empty())
     return false;
   std::string bstr = value_;
@@ -98,12 +98,12 @@ bool ConfigValue::GetBool(bool* value) const {
     return false;
 }
 
-bool ConfigValue::GetInt(int* value) const {
+bool ConfigValue::GetInt(int *value) const {
   if (!value || value_.empty())
     return false;
   // try to parse hex number
   if (boost::starts_with(value_, "0x")) {
-    char* p = NULL;
+    char *p = NULL;
     unsigned int hex = std::strtoul(value_.c_str(), &p, 16);
     if (*p == '\0') {
       *value = static_cast<int>(hex);
@@ -120,7 +120,7 @@ bool ConfigValue::GetInt(int* value) const {
   return true;
 }
 
-bool ConfigValue::GetDouble(double* value) const {
+bool ConfigValue::GetDouble(double *value) const {
   if (!value || value_.empty())
     return false;
   try {
@@ -132,7 +132,7 @@ bool ConfigValue::GetDouble(double* value) const {
   return true;
 }
 
-bool ConfigValue::GetString(std::string* value) const {
+bool ConfigValue::GetString(std::string *value) const {
   if (!value) return false;
   *value = value_;
   return true;
@@ -153,12 +153,12 @@ bool ConfigValue::SetDouble(double value) {
   return true;
 }
 
-bool ConfigValue::SetString(const char* value) {
+bool ConfigValue::SetString(const char *value) {
   value_ = value;
   return true;
 }
 
-bool ConfigValue::SetString(const std::string& value) {
+bool ConfigValue::SetString(const std::string &value) {
   value_ = value;
   return true;
 }
@@ -167,7 +167,7 @@ bool ConfigValue::SetString(const std::string& value) {
 
 ConfigItemPtr ConfigList::GetAt(size_t i) const {
   if (i >= seq_.size())
-    return nullptr;
+    return ConfigItemPtr();
   else
     return seq_[i];
 }
@@ -220,23 +220,23 @@ ConfigList::Iterator ConfigList::end() {
 
 // ConfigMap members
 
-bool ConfigMap::HasKey(const std::string& key) const {
+bool ConfigMap::HasKey(const std::string &key) const {
   return bool(Get(key));
 }
 
-ConfigItemPtr ConfigMap::Get(const std::string& key) const {
-  auto it = map_.find(key);
+ConfigItemPtr ConfigMap::Get(const std::string &key) const {
+  Map::const_iterator it = map_.find(key);
   if (it == map_.end())
-    return nullptr;
+    return ConfigItemPtr();
   else
     return it->second;
 }
 
-ConfigValuePtr ConfigMap::GetValue(const std::string& key) const {
+ConfigValuePtr ConfigMap::GetValue(const std::string &key) const {
   return As<ConfigValue>(Get(key));
 }
 
-bool ConfigMap::Set(const std::string& key, ConfigItemPtr element) {
+bool ConfigMap::Set(const std::string &key, const ConfigItemPtr &element) {
   map_[key] = element;
   return true;
 }
@@ -257,66 +257,66 @@ ConfigMap::Iterator ConfigMap::end() {
 // ConfigItemRef members
 
 bool ConfigItemRef::IsNull() const {
-  auto item = GetItem();
+  ConfigItemPtr item = GetItem();
   return !item || item->type() == ConfigItem::kNull;
 }
 
 bool ConfigItemRef::IsValue() const {
-  auto item = GetItem();
+  ConfigItemPtr item = GetItem();
   return item && item->type() == ConfigItem::kScalar;
 }
 
 bool ConfigItemRef::IsList() const {
-  auto item = GetItem();
+  ConfigItemPtr item = GetItem();
   return item && item->type() == ConfigItem::kList;
 }
 
 bool ConfigItemRef::IsMap() const {
-  auto item = GetItem();
+  ConfigItemPtr item = GetItem();
   return item && item->type() == ConfigItem::kMap;
 }
 
 bool ConfigItemRef::ToBool() const {
   bool value = false;
-  if (auto item = As<ConfigValue>(GetItem())) {
+  ConfigValuePtr item = As<ConfigValue>(GetItem());
+  if (item)
     item->GetBool(&value);
-  }
   return value;
 }
 
 int ConfigItemRef::ToInt() const {
   int value = 0;
-  if (auto item = As<ConfigValue>(GetItem())) {
+  ConfigValuePtr item = As<ConfigValue>(GetItem());
+  if (item)
     item->GetInt(&value);
-  }
   return value;
 }
 
 double ConfigItemRef::ToDouble() const {
   double value = 0.0;
-  if (auto item = As<ConfigValue>(GetItem())) {
+  ConfigValuePtr item = As<ConfigValue>(GetItem());
+  if (item)
     item->GetDouble(&value);
-  }
   return value;
 }
 
 std::string ConfigItemRef::ToString() const {
   std::string value;
-  if (auto item = As<ConfigValue>(GetItem())) {
+  ConfigValuePtr item = As<ConfigValue>(GetItem());
+  if (item)
     item->GetString(&value);
-  }
   return value;
 }
 
 ConfigListPtr ConfigItemRef::AsList() {
-  auto list = As<ConfigList>(GetItem());
+  ConfigListPtr list = As<ConfigList>(GetItem());
   if (!list)
     SetItem(list = New<ConfigList>());
   return list;
 }
 
 ConfigMapPtr ConfigItemRef::AsMap() {
-  auto map = As<ConfigMap>(GetItem());
+  ConfigMapPtr map = As<ConfigMap>(GetItem());
   if (!map)
     SetItem(map = New<ConfigMap>());
   return map;
@@ -326,7 +326,7 @@ void ConfigItemRef::Clear() {
   SetItem(ConfigItemPtr());
 }
 
-bool ConfigItemRef::Append(ConfigItemPtr item) {
+bool ConfigItemRef::Append(const ConfigItemPtr& item) {
   if (AsList()->Append(item)) {
     set_modified();
     return true;
@@ -335,12 +335,12 @@ bool ConfigItemRef::Append(ConfigItemPtr item) {
 }
 
 size_t ConfigItemRef::size() const {
-  auto list = As<ConfigList>(GetItem());
+  ConfigListPtr list = As<ConfigList>(GetItem());
   return list ? list->size() : 0;
 }
 
 bool ConfigItemRef::HasKey(const std::string& key) const {
-  auto map = As<ConfigMap>(GetItem());
+  ConfigMapPtr map = As<ConfigMap>(GetItem());
   return map ? map->HasKey(key) : false;
 }
 
@@ -355,13 +355,13 @@ void ConfigItemRef::set_modified() {
 
 // Config members
 
-Config::Config() : ConfigItemRef(New<ConfigData>()) {
+Config::Config() : ConfigItemRef(make_shared<ConfigData>()) {
 }
 
 Config::~Config() {
 }
 
-Config::Config(const std::string& file_name)
+Config::Config(const std::string &file_name)
     : ConfigItemRef(ConfigDataManager::instance().GetConfigData(file_name)) {
 }
 
@@ -381,47 +381,47 @@ bool Config::SaveToFile(const std::string& file_name) {
   return data_->SaveToFile(file_name);
 }
 
-bool Config::IsNull(const std::string& key) {
-  auto p = data_->Traverse(key);
+bool Config::IsNull(const std::string &key) {
+  ConfigItemPtr p = data_->Traverse(key);
   return !p || p->type() == ConfigItem::kNull;
 }
 
-bool Config::IsValue(const std::string& key) {
-  auto p = data_->Traverse(key);
+bool Config::IsValue(const std::string &key) {
+  ConfigItemPtr p = data_->Traverse(key);
   return !p || p->type() == ConfigItem::kScalar;
 }
 
-bool Config::IsList(const std::string& key) {
-  auto p = data_->Traverse(key);
+bool Config::IsList(const std::string &key) {
+  ConfigItemPtr p = data_->Traverse(key);
   return !p || p->type() == ConfigItem::kList;
 }
 
-bool Config::IsMap(const std::string& key) {
-  auto p = data_->Traverse(key);
+bool Config::IsMap(const std::string &key) {
+  ConfigItemPtr p = data_->Traverse(key);
   return !p || p->type() == ConfigItem::kMap;
 }
 
-bool Config::GetBool(const std::string& key, bool* value) {
+bool Config::GetBool(const std::string& key, bool *value) {
   DLOG(INFO) << "read: " << key;
-  auto p = As<ConfigValue>(data_->Traverse(key));
+  ConfigValuePtr p = As<ConfigValue>(data_->Traverse(key));
   return p && p->GetBool(value);
 }
 
-bool Config::GetInt(const std::string& key, int* value) {
+bool Config::GetInt(const std::string& key, int *value) {
   DLOG(INFO) << "read: " << key;
-  auto p = As<ConfigValue>(data_->Traverse(key));
+  ConfigValuePtr p = As<ConfigValue>(data_->Traverse(key));
   return p && p->GetInt(value);
 }
 
-bool Config::GetDouble(const std::string& key, double* value) {
+bool Config::GetDouble(const std::string& key, double *value) {
   DLOG(INFO) << "read: " << key;
-  auto p = As<ConfigValue>(data_->Traverse(key));
+  ConfigValuePtr p = As<ConfigValue>(data_->Traverse(key));
   return p && p->GetDouble(value);
 }
 
-bool Config::GetString(const std::string& key, std::string* value) {
+bool Config::GetString(const std::string& key, std::string *value) {
   DLOG(INFO) << "read: " << key;
-  auto p = As<ConfigValue>(data_->Traverse(key));
+  ConfigValuePtr p = As<ConfigValue>(data_->Traverse(key));
   return p && p->GetString(value);
 }
 
@@ -445,23 +445,23 @@ ConfigMapPtr Config::GetMap(const std::string& key) {
   return As<ConfigMap>(data_->Traverse(key));
 }
 
-bool Config::SetBool(const std::string& key, bool value) {
+bool Config::SetBool(const std::string &key, bool value) {
   return SetItem(key, New<ConfigValue>(value));
 }
 
-bool Config::SetInt(const std::string& key, int value) {
+bool Config::SetInt(const std::string &key, int value) {
   return SetItem(key, New<ConfigValue>(value));
 }
 
-bool Config::SetDouble(const std::string& key, double value) {
+bool Config::SetDouble(const std::string &key, double value) {
   return SetItem(key, New<ConfigValue>(value));
 }
 
-bool Config::SetString(const std::string& key, const char* value) {
+bool Config::SetString(const std::string &key, const char *value) {
   return SetItem(key, New<ConfigValue>(value));
 }
 
-bool Config::SetString(const std::string& key, const std::string& value) {
+bool Config::SetString(const std::string &key, const std::string &value) {
   return SetItem(key, New<ConfigValue>(value));
 }
 
@@ -512,12 +512,12 @@ static size_t ResolveListIndex(ConfigItemPtr p, const std::string& key,
     index += std::strtoul(key.c_str() + cursor, NULL, 10);
   }
   if (will_insert && !read_only) {
-    list->Insert(index, nullptr);
+    list->Insert(index, ConfigItemPtr());
   }
   return index;
 }
 
-bool Config::SetItem(const std::string& key, ConfigItemPtr item) {
+bool Config::SetItem(const std::string& key, const ConfigItemPtr& item) {
   LOG(INFO) << "write: " << key;
   if (key.empty() || key == "/") {
     data_->root = item;
@@ -586,18 +586,18 @@ ConfigItemPtr Config::GetItem() const {
   return data_->root;
 }
 
-void Config::SetItem(ConfigItemPtr item) {
+void Config::SetItem(const ConfigItemPtr& item) {
   data_->root = item;
   set_modified();
 }
 
 // ConfigComponent members
 
-std::string ConfigComponent::GetConfigFilePath(const std::string& config_id) {
+std::string ConfigComponent::GetConfigFilePath(const std::string &config_id) {
   return boost::str(boost::format(pattern_) % config_id);
 }
 
-Config* ConfigComponent::Create(const std::string& config_id) {
+Config* ConfigComponent::Create(const std::string &config_id) {
   std::string path(GetConfigFilePath(config_id));
   DLOG(INFO) << "config file path: " << path;
   return new Config(path);
@@ -606,20 +606,19 @@ Config* ConfigComponent::Create(const std::string& config_id) {
 // ConfigDataManager memebers
 
 ConfigDataManager& ConfigDataManager::instance() {
-  static unique_ptr<ConfigDataManager> s_instance;
+  static scoped_ptr<ConfigDataManager> s_instance;
   if (!s_instance) {
     s_instance.reset(new ConfigDataManager);
   }
   return *s_instance;
 }
 
-shared_ptr<ConfigData>
-ConfigDataManager::GetConfigData(const std::string& config_file_path) {
+shared_ptr<ConfigData> ConfigDataManager::GetConfigData(const std::string &config_file_path) {
   shared_ptr<ConfigData> sp;
   // keep a weak reference to the shared config data in the manager
-  weak_ptr<ConfigData>& wp((*this)[config_file_path]);
+  weak_ptr<ConfigData> &wp((*this)[config_file_path]);
   if (wp.expired()) {  // create a new copy and load it
-    sp = New<ConfigData>();
+    sp = make_shared<ConfigData>();
     sp->LoadFromFile(config_file_path);
     wp = sp;
   }
@@ -629,7 +628,7 @@ ConfigDataManager::GetConfigData(const std::string& config_file_path) {
   return sp;
 }
 
-bool ConfigDataManager::ReloadConfigData(const std::string& config_file_path) {
+bool ConfigDataManager::ReloadConfigData(const std::string &config_file_path) {
   iterator it = find(config_file_path);
   if (it == end()) {  // never loaded
     return false;
@@ -717,7 +716,7 @@ bool ConfigData::SaveToFile(const std::string& file_name) {
   return SaveToStream(out);
 }
 
-ConfigItemPtr ConfigData::Traverse(const std::string& key) {
+ConfigItemPtr ConfigData::Traverse(const std::string &key) {
   DLOG(INFO) << "traverse: " << key;
   if (key.empty() || key == "/") {
     return root;
@@ -726,7 +725,9 @@ ConfigItemPtr ConfigData::Traverse(const std::string& key) {
   boost::split(keys, key, boost::is_any_of("/"));
   // find the YAML::Node, and wrap it!
   ConfigItemPtr p = root;
-  for (auto it = keys.begin(), end = keys.end(); it != end; ++it) {
+  std::vector<std::string>::iterator it = keys.begin();
+  std::vector<std::string>::iterator end = keys.end();
+  for (; it != end; ++it) {
     ConfigItem::ValueType node_type = ConfigItem::kMap;
     size_t list_index = 0;
     if (IsListItemReference(*it)) {
@@ -734,7 +735,7 @@ ConfigItemPtr ConfigData::Traverse(const std::string& key) {
       list_index = ResolveListIndex(p, *it, true);
     }
     if (!p || p->type() != node_type) {
-      return nullptr;
+      return ConfigItemPtr();
     }
     if (node_type == ConfigItem::kList) {
       p = As<ConfigList>(p)->GetAt(list_index);
@@ -746,23 +747,27 @@ ConfigItemPtr ConfigData::Traverse(const std::string& key) {
   return p;
 }
 
-ConfigItemPtr ConfigData::ConvertFromYaml(const YAML::Node& node) {
+ConfigItemPtr ConfigData::ConvertFromYaml(const YAML::Node &node) {
   if (YAML::NodeType::Null == node.Type()) {
     return ConfigItemPtr();
   }
   if (YAML::NodeType::Scalar == node.Type()) {
-    return New<ConfigValue>(node.as<std::string>());
+    return boost::make_shared<ConfigValue>(node.as<std::string>());
   }
   if (YAML::NodeType::Sequence == node.Type()) {
-    auto config_list = New<ConfigList>();
-    for (auto it = node.begin(), end = node.end(); it != end; ++it) {
+    ConfigListPtr config_list = make_shared<ConfigList>();
+    YAML::const_iterator it = node.begin();
+    YAML::const_iterator end = node.end();
+    for ( ; it != end; ++it) {
       config_list->Append(ConvertFromYaml(*it));
     }
     return config_list;
   }
   else if (YAML::NodeType::Map == node.Type()) {
-    auto config_map = New<ConfigMap>();
-    for (auto it = node.begin(), end = node.end(); it != end; ++it) {
+    ConfigMapPtr config_map = make_shared<ConfigMap>();
+    YAML::const_iterator it = node.begin();
+    YAML::const_iterator end = node.end();
+    for ( ; it != end; ++it) {
       std::string key = it->first.as<std::string>();
       config_map->Set(key, ConvertFromYaml(it->second));
     }
@@ -771,8 +776,8 @@ ConfigItemPtr ConfigData::ConvertFromYaml(const YAML::Node& node) {
   return ConfigItemPtr();
 }
 
-void ConfigData::EmitScalar(const std::string& str_value,
-                            YAML::Emitter* emitter) {
+void ConfigData::EmitScalar(const std::string &str_value,
+                            YAML::Emitter *emitter) {
   if (str_value.find_first_of("\r\n") != std::string::npos) {
     *emitter << YAML::Literal;
   }
@@ -784,32 +789,36 @@ void ConfigData::EmitScalar(const std::string& str_value,
   *emitter << str_value;
 }
 
-void ConfigData::EmitYaml(ConfigItemPtr node,
-                          YAML::Emitter* emitter,
+void ConfigData::EmitYaml(const ConfigItemPtr &node,
+                          YAML::Emitter *emitter,
                           int depth) {
   if (!node || !emitter) return;
   if (node->type() == ConfigItem::kScalar) {
-    auto value = As<ConfigValue>(node);
-    EmitScalar(value->str(), emitter);
+    ConfigValuePtr config_value(As<ConfigValue>(node));
+    EmitScalar(config_value->str(), emitter);
   }
   else if (node->type() == ConfigItem::kList) {
+    ConfigListPtr config_list(As<ConfigList>(node));
+    ConfigList::Iterator it = config_list->begin();
+    ConfigList::Iterator end = config_list->end();
     if (depth >= 3) {
       *emitter << YAML::Flow;
     }
     *emitter << YAML::BeginSeq;
-    auto list = As<ConfigList>(node);
-    for (auto it = list->begin(), end = list->end(); it != end; ++it) {
+    for ( ; it != end; ++it) {
       EmitYaml(*it, emitter, depth + 1);
     }
     *emitter << YAML::EndSeq;
   }
   else if (node->type() == ConfigItem::kMap) {
+    ConfigMapPtr config_map(As<ConfigMap>(node));
+    ConfigMap::Iterator it = config_map->begin();
+    ConfigMap::Iterator end = config_map->end();
     if (depth >= 3) {
       *emitter << YAML::Flow;
     }
     *emitter << YAML::BeginMap;
-    auto map = As<ConfigMap>(node);
-    for (auto it = map->begin(), end = map->end(); it != end; ++it) {
+    for ( ; it != end; ++it) {
       if (!it->second || it->second->type() == ConfigItem::kNull)
         continue;
       *emitter << YAML::Key;
diff --git a/src/context.cc b/src/context.cc
index ec140a0..4b22177 100644
--- a/src/context.cc
+++ b/src/context.cc
@@ -12,7 +12,7 @@
 
 namespace rime {
 
-Context::Context() : composition_(new Composition) {
+Context::Context() : input_(), caret_pos_(0), composition_(new Composition) {
 }
 
 Context::~Context() {
@@ -38,7 +38,7 @@ std::string Context::GetScriptText() const {
   return composition_->GetScriptText();
 }
 
-void Context::GetPreedit(Preedit* preedit, bool soft_cursor) const {
+void Context::GetPreedit(Preedit *preedit, bool soft_cursor) const {
   composition_->GetPreedit(preedit);
   preedit->caret_pos = preedit->text.length();
   if (IsComposing()) {
@@ -59,7 +59,7 @@ bool Context::IsComposing() const {
 bool Context::HasMenu() const {
   if (composition_->empty())
     return false;
-  const auto& menu(composition_->back().menu);
+  const shared_ptr<Menu>& menu(composition_->back().menu);
   return menu && !menu->empty();
 }
 
@@ -116,8 +116,9 @@ void Context::Clear() {
 bool Context::Select(size_t index) {
   if (composition_->empty())
     return false;
-  Segment& seg(composition_->back());
-  if (auto cand = seg.GetCandidateAt(index)) {
+  Segment &seg(composition_->back());
+  shared_ptr<Candidate> cand(seg.GetCandidateAt(index));
+  if (cand) {
     seg.selected_index = index;
     seg.status = Segment::kSelected;
     DLOG(INFO) << "Selected: '" << cand->text() << "', index = " << index;
@@ -130,8 +131,9 @@ bool Context::Select(size_t index) {
 bool Context::DeleteCurrentSelection() {
   if (composition_->empty())
     return false;
-  Segment& seg(composition_->back());
-  if (auto cand = seg.GetSelectedCandidate()) {
+  Segment &seg(composition_->back());
+  shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
+  if (cand) {
     DLOG(INFO) << "Deleting: '" << cand->text()
                << "', selected_index = " << seg.selected_index;
     delete_notifier_(this);
@@ -143,9 +145,10 @@ bool Context::DeleteCurrentSelection() {
 bool Context::ConfirmCurrentSelection() {
   if (composition_->empty())
     return false;
-  Segment& seg(composition_->back());
+  Segment &seg(composition_->back());
   seg.status = Segment::kSelected;
-  if (auto cand = seg.GetSelectedCandidate()) {
+  shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
+  if (cand) {
     DLOG(INFO) << "Confirmed: '" << cand->text()
                << "', selected_index = " << seg.selected_index;
   }
@@ -161,10 +164,9 @@ bool Context::ConfirmCurrentSelection() {
 }
 
 bool Context::ConfirmPreviousSelection() {
-  for (auto it = composition_->rbegin(); it != composition_->rend(); ++it) {
-    if (it->status > Segment::kSelected) {
-      return false;
-    }
+  for (Composition::reverse_iterator it = composition_->rbegin();
+       it != composition_->rend(); ++it) {
+    if (it->status > Segment::kSelected) return false;
     if (it->status == Segment::kSelected) {
       it->status = Segment::kConfirmed;
       return true;
@@ -176,7 +178,7 @@ bool Context::ConfirmPreviousSelection() {
 bool Context::ReopenPreviousSegment() {
   if (composition_->Trim()) {
     if (!composition_->empty() &&
-        composition_->back().status >= Segment::kSelected) {
+      composition_->back().status >= Segment::kSelected) {
       composition_->back().status = Segment::kVoid;
     }
     update_notifier_(this);
@@ -196,14 +198,13 @@ bool Context::ClearPreviousSegment() {
 }
 
 bool Context::ReopenPreviousSelection() {
-  for (auto it = composition_->rbegin(); it != composition_->rend(); ++it) {
-    if (it->status > Segment::kSelected)
-      return false;
+  for (Composition::reverse_iterator it = composition_->rbegin();
+       it != composition_->rend(); ++it) {
+    if (it->status > Segment::kSelected) return false;
     if (it->status == Segment::kSelected) {
       it->status = Segment::kVoid;
-      while (it != composition_->rbegin()) {
+      while (it != composition_->rbegin())
         composition_->pop_back();
-      }
       update_notifier_(this);
       return true;
     }
@@ -241,13 +242,13 @@ void Context::set_caret_pos(size_t caret_pos) {
   update_notifier_(this);
 }
 
-void Context::set_composition(Composition* comp) {
+void Context::set_composition(Composition *comp) {
   if (composition_.get() != comp)
     composition_.reset(comp);
   // TODO: notification
 }
 
-void Context::set_input(const std::string& value) {
+void Context::set_input(const std::string &value) {
   input_ = value;
   caret_pos_ = input_.length();
   update_notifier_(this);
@@ -261,26 +262,27 @@ const Composition* Context::composition() const {
   return composition_.get();
 }
 
-void Context::set_option(const std::string& name, bool value) {
+void Context::set_option(const std::string &name, bool value) {
   options_[name] = value;
   option_update_notifier_(this, name);
 }
 
-bool Context::get_option(const std::string& name) const {
-  auto it = options_.find(name);
+bool Context::get_option(const std::string &name) const {
+  std::map<std::string, bool>::const_iterator it = options_.find(name);
   if (it != options_.end())
     return it->second;
   else
     return false;
 }
 
-void Context::set_property(const std::string& name,
+void Context::set_property(const std::string &name,
                            const std::string& value) {
   properties_[name] = value;
 }
 
-std::string Context::get_property(const std::string& name) const {
-  auto it = properties_.find(name);
+std::string Context::get_property(const std::string &name) const {
+  std::map<std::string, std::string>::const_iterator it =
+      properties_.find(name);
   if (it != properties_.end())
     return it->second;
   else
@@ -288,15 +290,16 @@ std::string Context::get_property(const std::string& name) const {
 }
 
 void Context::ClearTransientOptions() {
-  auto opt = options_.lower_bound("_");
-  while (opt != options_.end() &&
-         !opt->first.empty() && opt->first[0] == '_') {
-    options_.erase(opt++);
+  std::map<std::string, bool>::iterator oit = options_.lower_bound("_");
+  while (oit != options_.end() &&
+         !oit->first.empty() && oit->first[0] == '_') {
+    options_.erase(oit++);
   }
-  auto prop = properties_.lower_bound("_");
-  while (prop != properties_.end() &&
-         !prop->first.empty() && prop->first[0] == '_') {
-    properties_.erase(prop++);
+  std::map<std::string, std::string>::iterator pit =
+      properties_.lower_bound("_");
+  while (pit != properties_.end() &&
+         !pit->first.empty() && pit->first[0] == '_') {
+    properties_.erase(pit++);
   }
 }
 
diff --git a/src/core_module.cc b/src/core_module.cc
index 785c22f..09c860e 100644
--- a/src/core_module.cc
+++ b/src/core_module.cc
@@ -16,14 +16,14 @@
 
 static void rime_core_initialize() {
   using namespace rime;
-  using boost::filesystem::path;
 
   LOG(INFO) << "registering core components.";
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
 
-  path user_data_dir = Service::instance().deployer().user_data_dir;
-  path config_path = user_data_dir / "%s.yaml";
-  path schema_path = user_data_dir / "%s.schema.yaml";
+  boost::filesystem::path user_data_dir =
+      Service::instance().deployer().user_data_dir;
+  boost::filesystem::path config_path = user_data_dir / "%s.yaml";
+  boost::filesystem::path schema_path = user_data_dir / "%s.schema.yaml";
 
   r.Register("config", new ConfigComponent(config_path.string()));
   r.Register("schema_config", new ConfigComponent(schema_path.string()));
diff --git a/src/deployer.cc b/src/deployer.cc
index a40d006..23ae685 100644
--- a/src/deployer.cc
+++ b/src/deployer.cc
@@ -4,8 +4,7 @@
 //
 // 2011-12-01 GONG Chen <chen.sst@gmail.com>
 //
-#include <chrono>
-#include <utility>
+#include <boost/bind.hpp>
 #include <boost/filesystem.hpp>
 #include <boost/date_time/posix_time/posix_time_types.hpp>
 #include <rime/deployer.h>
@@ -15,7 +14,8 @@ namespace rime {
 Deployer::Deployer() : shared_data_dir("."),
                        user_data_dir("."),
                        sync_dir("sync"),
-                       user_id("unknown") {
+                       user_id("unknown"),
+                       maintenance_mode_(false) {
 }
 
 Deployer::~Deployer() {
@@ -29,12 +29,12 @@ std::string Deployer::user_data_sync_dir() const {
 }
 
 bool Deployer::RunTask(const std::string& task_name, TaskInitializer arg) {
-  auto c = DeploymentTask::Require(task_name);
+  DeploymentTask::Component* c = DeploymentTask::Require(task_name);
   if (!c) {
     LOG(ERROR) << "unknown deployment task: " << task_name;
     return false;
   }
-  unique_ptr<DeploymentTask> t(c->Create(arg));
+  scoped_ptr<DeploymentTask> t(c->Create(arg));
   if (!t) {
     LOG(ERROR) << "error creating deployment task: " << task_name;
     return false;
@@ -43,7 +43,7 @@ bool Deployer::RunTask(const std::string& task_name, TaskInitializer arg) {
 }
 
 bool Deployer::ScheduleTask(const std::string& task_name, TaskInitializer arg) {
-  auto c = DeploymentTask::Require(task_name);
+  DeploymentTask::Component* c = DeploymentTask::Require(task_name);
   if (!c) {
     LOG(ERROR) << "unknown deployment task: " << task_name;
     return false;
@@ -57,40 +57,41 @@ bool Deployer::ScheduleTask(const std::string& task_name, TaskInitializer arg) {
   return true;
 }
 
-void Deployer::ScheduleTask(shared_ptr<DeploymentTask> task) {
-  std::lock_guard<std::mutex> lock(mutex_);
+void Deployer::ScheduleTask(const shared_ptr<DeploymentTask>& task) {
+  boost::lock_guard<boost::mutex> lock(mutex_);
   pending_tasks_.push(task);
 }
 
 shared_ptr<DeploymentTask> Deployer::NextTask() {
-  std::lock_guard<std::mutex> lock(mutex_);
+  boost::lock_guard<boost::mutex> lock(mutex_);
+  shared_ptr<DeploymentTask> result;
   if (!pending_tasks_.empty()) {
-    auto result = pending_tasks_.front();
+    result = pending_tasks_.front();
     pending_tasks_.pop();
-    return result;
   }
   // there is still chance that a task is added by another thread
   // right after this call... careful.
-  return nullptr;
+  return result;
 }
 
 bool Deployer::HasPendingTasks() {
-  std::lock_guard<std::mutex> lock(mutex_);
+  boost::lock_guard<boost::mutex> lock(mutex_);
   return !pending_tasks_.empty();
 }
 
 bool Deployer::Run() {
   LOG(INFO) << "running deployment tasks:";
   message_sink_("deploy", "start");
+  shared_ptr<DeploymentTask> task;
   int success = 0;
   int failure = 0;
   do {
-    while (auto task = NextTask()) {
+    while ((task = NextTask())) {
       if (task->Run(this))
         ++success;
       else
         ++failure;
-      //boost::this_thread::interruption_point();
+      boost::this_thread::interruption_point();
     }
     LOG(INFO) << success + failure << " tasks ran: "
               << success << " success, " << failure << " failure.";
@@ -113,8 +114,9 @@ bool Deployer::StartWork(bool maintenance_mode) {
   }
   LOG(INFO) << "starting work thread for "
             << pending_tasks_.size() << " tasks.";
-  work_ = std::async(std::launch::async, [this] { Run(); });
-  return work_.valid();
+  boost::thread t(boost::bind(&Deployer::Run, this));
+  work_thread_.swap(t);
+  return work_thread_.joinable();
 }
 
 bool Deployer::StartMaintenance() {
@@ -122,10 +124,9 @@ bool Deployer::StartMaintenance() {
 }
 
 bool Deployer::IsWorking() {
-  if (!work_.valid())
+  if (!work_thread_.joinable())
     return false;
-  auto status = work_.wait_for(std::chrono::milliseconds(0));
-  return status != std::future_status::ready;
+  return !work_thread_.timed_join(boost::posix_time::milliseconds(0));
 }
 
 bool Deployer::IsMaintenanceMode() {
@@ -133,8 +134,8 @@ bool Deployer::IsMaintenanceMode() {
 }
 
 void Deployer::JoinWorkThread() {
-  if (work_.valid())
-    work_.get();
+  if (work_thread_.joinable())
+    work_thread_.join();
 }
 
 void Deployer::JoinMaintenanceThread() {
diff --git a/src/dict/db.cc b/src/dict/db.cc
index b8c46a6..0671a78 100644
--- a/src/dict/db.cc
+++ b/src/dict/db.cc
@@ -15,13 +15,23 @@ namespace rime {
 
 // DbAccessor members
 
+DbAccessor::DbAccessor() {
+}
+
+DbAccessor::DbAccessor(const std::string& prefix) : prefix_(prefix) {
+}
+
+DbAccessor::~DbAccessor() {
+}
+
 bool DbAccessor::MatchesPrefix(const std::string& key) {
   return boost::starts_with(key, prefix_);
 }
 
 // Db members
 
-Db::Db(const std::string& name) : name_(name) {
+Db::Db(const std::string& name)
+    : name_(name), loaded_(false), readonly_(false), disabled_(false) {
   boost::filesystem::path path(name);
   if (path.has_parent_path()) {
     file_name_ = name;
@@ -32,6 +42,9 @@ Db::Db(const std::string& name) : name_(name) {
   }
 }
 
+Db::~Db() {
+}
+
 bool Db::Exists() const {
   return boost::filesystem::exists(file_name());
 }
diff --git a/src/dict/dict_compiler.cc b/src/dict/dict_compiler.cc
index 2bd9aa4..8892b5f 100644
--- a/src/dict/dict_compiler.cc
+++ b/src/dict/dict_compiler.cc
@@ -4,9 +4,9 @@
 //
 // 2011-11-27 GONG Chen <chen.sst@gmail.com>
 //
-#include <fstream>
 #include <map>
 #include <set>
+#include <boost/foreach.hpp>
 #include <boost/filesystem.hpp>
 #include <rime/algo/algebra.h>
 #include <rime/algo/utilities.h>
@@ -26,6 +26,7 @@ DictCompiler::DictCompiler(Dictionary *dictionary, DictFileFinder finder)
     : dict_name_(dictionary->name()),
       prism_(dictionary->prism()),
       table_(dictionary->table()),
+      options_(0),
       dict_file_finder_(finder) {
 }
 
@@ -48,8 +49,8 @@ bool DictCompiler::Compile(const std::string &schema_file) {
     LOG(INFO) << "dict version: " << settings.dict_version();
   }
   std::vector<std::string> dict_files;
-  auto tables = settings.GetTables();
-  for(auto it = tables->begin(); it != tables->end(); ++it) {
+  ConfigListPtr tables = settings.GetTables();
+  for(ConfigList::Iterator it = tables->begin(); it != tables->end(); ++it) {
     if (!Is<ConfigValue>(*it))
       continue;
     std::string dict_file(FindDictFile(As<ConfigValue>(*it)->str()));
@@ -60,7 +61,7 @@ bool DictCompiler::Compile(const std::string &schema_file) {
   uint32_t dict_file_checksum = 0;
   if (!dict_files.empty()) {
     ChecksumComputer cc;
-    for (const auto& file_name : dict_files) {
+    BOOST_FOREACH(const std::string& file_name, dict_files) {
       cc.ProcessFile(file_name);
     }
     if (settings.use_preset_vocabulary()) {
@@ -150,20 +151,20 @@ bool DictCompiler::BuildTable(DictSettings* settings,
   {
     std::map<std::string, SyllableId> syllable_to_id;
     SyllableId syllable_id = 0;
-    for (const auto& s : collector.syllabary) {
+    BOOST_FOREACH(const std::string &s, collector.syllabary) {
       syllable_to_id[s] = syllable_id++;
     }
-    for (RawDictEntry& r : collector.entries) {
+    BOOST_FOREACH(RawDictEntry &r, collector.entries) {
       Code code;
-      for (const auto& s : r.raw_code) {
+      BOOST_FOREACH(const std::string &s, r.raw_code) {
         code.push_back(syllable_to_id[s]);
       }
-      DictEntryList* ls = vocabulary.LocateEntries(code);
+      DictEntryList *ls = vocabulary.LocateEntries(code);
       if (!ls) {
         LOG(ERROR) << "Error locating entries in vocabulary.";
         continue;
       }
-      auto e = New<DictEntry>();
+      shared_ptr<DictEntry> e = make_shared<DictEntry>();
       e->code.swap(code);
       e->text.swap(r.text);
       e->weight = r.weight;
@@ -204,9 +205,9 @@ bool DictCompiler::BuildPrism(const std::string &schema_file,
   if (!schema_file.empty()) {
     Projection p;
     Config config(schema_file);
-    auto algebra = config.GetList("speller/algebra");
+    ConfigListPtr algebra = config.GetList("speller/algebra");
     if (algebra && p.Load(algebra)) {
-      for (const auto& x : syllabary) {
+      BOOST_FOREACH(Syllabary::value_type const& x, syllabary) {
         script.AddSyllable(x);
       }
       if (!p.Apply(&script)) {
diff --git a/src/dict/dict_module.cc b/src/dict/dict_module.cc
index 5f68411..5f9635b 100644
--- a/src/dict/dict_module.cc
+++ b/src/dict/dict_module.cc
@@ -21,12 +21,12 @@ static void rime_dict_initialize() {
   using namespace rime;
 
   LOG(INFO) << "registering components from module 'dict'.";
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
 
   r.Register("tabledb", new Component<TableDb>);
   r.Register("stabledb", new Component<StableDb>);
-  r.Register("plain_userdb", new Component<UserDb<TextDb>>);
-  r.Register("userdb", new Component<UserDb<TreeDb>>);
+  r.Register("plain_userdb", new Component<UserDb<TextDb> >);
+  r.Register("userdb", new Component<UserDb<TreeDb> >);
 
   r.Register("dictionary", new DictionaryComponent);
   r.Register("reverse_lookup_dictionary",
diff --git a/src/dict/dict_settings.cc b/src/dict/dict_settings.cc
index 6c86334..c986e1c 100644
--- a/src/dict/dict_settings.cc
+++ b/src/dict/dict_settings.cc
@@ -66,13 +66,13 @@ double DictSettings::min_phrase_weight() {
 }
 
 ConfigListPtr DictSettings::GetTables() {
-  auto tables = New<ConfigList>();
+  ConfigListPtr tables = New<ConfigList>();
   tables->Append((*this)["name"]);
-  auto imports = (*this)["import_tables"].AsList();
-  for (auto it = imports->begin(); it != imports->end(); ++it) {
+  ConfigListPtr imports = (*this)["import_tables"].AsList();
+  for (ConfigList::Iterator it = imports->begin(); it != imports->end(); ++it) {
     if (!Is<ConfigValue>(*it))
       continue;
-    std::string table = As<ConfigValue>(*it)->str();
+    std::string table(As<ConfigValue>(*it)->str());
     if (table == dict_name()) {
       LOG(WARNING) << "cannot import '" << table << "' from itself.";
       continue;
@@ -90,9 +90,10 @@ int DictSettings::GetColumnIndex(const std::string& column_label) {
     if (column_label == "weight") return 2;
     return -1;
   }
-  auto columns = (*this)["columns"].AsList();
+  ConfigListPtr columns = (*this)["columns"].AsList();
   int index = 0;
-  for (auto it = columns->begin(); it != columns->end(); ++it, ++index) {
+  for (ConfigList::Iterator it = columns->begin();
+       it != columns->end(); ++it, ++index) {
     if (Is<ConfigValue>(*it) && As<ConfigValue>(*it)->str() == column_label) {
       return index;
     }
diff --git a/src/dict/dictionary.cc b/src/dict/dictionary.cc
index 66306b5..16c096c 100644
--- a/src/dict/dictionary.cc
+++ b/src/dict/dictionary.cc
@@ -4,7 +4,7 @@
 //
 // 2011-07-05 GONG Chen <chen.sst@gmail.com>
 //
-#include <utility>
+#include <boost/foreach.hpp>
 #include <boost/filesystem.hpp>
 #include <rime/common.h>
 #include <rime/schema.h>
@@ -17,7 +17,7 @@ namespace rime {
 
 namespace dictionary {
 
-bool compare_chunk_by_head_element(const Chunk& a, const Chunk& b) {
+bool compare_chunk_by_head_element(const Chunk &a, const Chunk &b) {
   if (!a.entries || a.cursor >= a.size) return false;
   if (!b.entries || b.cursor >= b.size) return true;
   if (a.remaining_code.length() != b.remaining_code.length())
@@ -26,26 +26,25 @@ bool compare_chunk_by_head_element(const Chunk& a, const Chunk& b) {
          b.credibility * b.entries[b.cursor].weight;  // by weight desc
 }
 
-size_t match_extra_code(const table::Code* extra_code, size_t depth,
-                        const SyllableGraph& syll_graph, size_t current_pos) {
+size_t match_extra_code(const table::Code *extra_code, size_t depth,
+                        const SyllableGraph &syll_graph, size_t current_pos) {
   if (!extra_code || depth >= extra_code->size)
     return current_pos;  // success
   if (current_pos >= syll_graph.interpreted_length)
     return 0;  // failure (possibly success for completion in the future)
-  auto index = syll_graph.indices.find(current_pos);
+  SpellingIndices::const_iterator index = syll_graph.indices.find(current_pos);
   if (index == syll_graph.indices.end())
     return 0;
   SyllableId current_syll_id = extra_code->at[depth];
-  auto spellings = index->second.find(current_syll_id);
+  SpellingIndex::const_iterator spellings = index->second.find(current_syll_id);
   if (spellings == index->second.end())
     return 0;
   size_t best_match = 0;
-  for (const SpellingProperties* props : spellings->second) {
+  BOOST_FOREACH(const SpellingProperties* props, spellings->second) {
     size_t match_end_pos = match_extra_code(extra_code, depth + 1,
                                             syll_graph, props->end_pos);
     if (!match_end_pos) continue;
-    if (match_end_pos > best_match)
-      best_match = match_end_pos;
+    if (match_end_pos > best_match) best_match = match_end_pos;
   }
   return best_match;
 }
@@ -56,12 +55,12 @@ DictEntryIterator::DictEntryIterator()
     : Base(), table_(NULL), entry_(), entry_count_(0) {
 }
 
-DictEntryIterator::DictEntryIterator(const DictEntryIterator& other)
+DictEntryIterator::DictEntryIterator(const DictEntryIterator &other)
     : Base(other), table_(other.table_), entry_(other.entry_),
       entry_count_(other.entry_count_) {
 }
 
-DictEntryIterator& DictEntryIterator::operator= (DictEntryIterator& other) {
+DictEntryIterator& DictEntryIterator::operator= (DictEntryIterator &other) {
   DLOG(INFO) << "swapping iterator contents.";
   swap(other);
   table_ = other.table_;
@@ -74,8 +73,9 @@ bool DictEntryIterator::exhausted() const {
   return empty();
 }
 
-void DictEntryIterator::AddChunk(dictionary::Chunk&& chunk, Table* table) {
-  push_back(std::move(chunk));
+void DictEntryIterator::AddChunk(const dictionary::Chunk &chunk,
+                                 Table* table) {
+  push_back(chunk);
   entry_count_ += chunk.size;
   table_ = table;
 }
@@ -88,9 +88,9 @@ void DictEntryIterator::PrepareEntry() {
   if (empty() || !table_) {
     return;
   }
-  const auto& chunk(front());
-  entry_ = New<DictEntry>();
-  const auto& e(chunk.entries[chunk.cursor]);
+  const dictionary::Chunk &chunk(front());
+  entry_ = make_shared<DictEntry>();
+  const table::Entry &e(chunk.entries[chunk.cursor]);
   DLOG(INFO) << "creating temporary dict entry '"
              << table_->GetEntryText(e) << "'.";
   entry_->code = chunk.code;
@@ -118,7 +118,7 @@ bool DictEntryIterator::Next() {
   if (empty()) {
     return false;
   }
-  auto& chunk(front());
+  dictionary::Chunk &chunk(front());
   if (++chunk.cursor >= chunk.size) {
     pop_front();
   }
@@ -132,7 +132,7 @@ bool DictEntryIterator::Next() {
 bool DictEntryIterator::Skip(size_t num_entries) {
   while (num_entries > 0) {
     if (empty()) return false;
-    auto& chunk(front());
+    dictionary::Chunk &chunk(front());
     if (chunk.cursor + num_entries < chunk.size) {
       chunk.cursor += num_entries;
       return true;
@@ -145,9 +145,9 @@ bool DictEntryIterator::Skip(size_t num_entries) {
 
 // Dictionary members
 
-Dictionary::Dictionary(const std::string& name,
-                       const shared_ptr<Table>& table,
-                       const shared_ptr<Prism>& prism)
+Dictionary::Dictionary(const std::string &name,
+                       const shared_ptr<Table> &table,
+                       const shared_ptr<Prism> &prism)
     : name_(name), table_(table), prism_(prism) {
 }
 
@@ -155,21 +155,20 @@ Dictionary::~Dictionary() {
   // should not close shared table and prism objects
 }
 
-shared_ptr<DictEntryCollector>
-Dictionary::Lookup(const SyllableGraph& syllable_graph,
-                   size_t start_pos,
-                   double initial_credibility) {
+shared_ptr<DictEntryCollector> Dictionary::Lookup(const SyllableGraph &syllable_graph,
+                                                  size_t start_pos,
+                                                  double initial_credibility) {
   if (!loaded())
-    return nullptr;
+    return shared_ptr<DictEntryCollector>();
   TableQueryResult result;
   if (!table_->Query(syllable_graph, start_pos, &result)) {
-    return nullptr;
+    return shared_ptr<DictEntryCollector>();
   }
-  auto collector = New<DictEntryCollector>();
+  shared_ptr<DictEntryCollector> collector = make_shared<DictEntryCollector>();
   // copy result
-  for (auto& v : result) {
+  BOOST_FOREACH(TableQueryResult::value_type &v, result) {
     size_t end_pos = v.first;
-    for (TableAccessor& a : v.second) {
+    BOOST_FOREACH(TableAccessor &a, v.second) {
       double cr = initial_credibility * a.credibility();
       if (a.extra_code()) {
         do {
@@ -177,24 +176,24 @@ Dictionary::Lookup(const SyllableGraph& syllable_graph,
               a.extra_code(), 0, syllable_graph, end_pos);
           if (actual_end_pos == 0) continue;
           (*collector)[actual_end_pos].AddChunk(
-              {a.code(), a.entry(), cr}, table_.get());
+              dictionary::Chunk(a.code(), a.entry(), cr), table_.get());
         }
         while (a.Next());
       }
       else {
-        (*collector)[end_pos].AddChunk({a, cr}, table_.get());
+        (*collector)[end_pos].AddChunk(dictionary::Chunk(a, cr), table_.get());
       }
     }
   }
   // sort each group of equal code length
-  for (auto& v : *collector) {
+  BOOST_FOREACH(DictEntryCollector::value_type &v, *collector) {
     v.second.Sort();
   }
   return collector;
 }
 
-size_t Dictionary::LookupWords(DictEntryIterator* result,
-                               const std::string& str_code,
+size_t Dictionary::LookupWords(DictEntryIterator *result,
+                               const std::string &str_code,
                                bool predictive,
                                size_t expand_search_limit) {
   DLOG(INFO) << "lookup: " << str_code;
@@ -205,14 +204,14 @@ size_t Dictionary::LookupWords(DictEntryIterator* result,
     prism_->ExpandSearch(str_code, &keys, expand_search_limit);
   }
   else {
-    Prism::Match match{0, 0};
+    Prism::Match match = {0, 0};
     if (prism_->GetValue(str_code, &match.value)) {
       keys.push_back(match);
     }
   }
   DLOG(INFO) << "found " << keys.size() << " matching keys thru the prism.";
   size_t code_length(str_code.length());
-  for (auto& match : keys) {
+  BOOST_FOREACH(Prism::Match &match, keys) {
     SpellingAccessor accessor(prism_->QuerySpelling(match.value));
     while (!accessor.exhausted()) {
       SyllableId syllable_id = accessor.syllable_id();
@@ -228,18 +227,18 @@ size_t Dictionary::LookupWords(DictEntryIterator* result,
       TableAccessor a(table_->QueryWords(syllable_id));
       if (!a.exhausted()) {
         DLOG(INFO) << "remaining code: " << remaining_code;
-        result->AddChunk({a, remaining_code}, table_.get());
+        result->AddChunk(dictionary::Chunk(a, remaining_code), table_.get());
       }
     }
   }
   return keys.size();
 }
 
-bool Dictionary::Decode(const Code& code, std::vector<std::string>* result) {
+bool Dictionary::Decode(const Code &code, std::vector<std::string>* result) {
   if (!result || !table_)
     return false;
   result->clear();
-  for (SyllableId c : code) {
+  BOOST_FOREACH(SyllableId c, code) {
     std::string s = table_->GetSyllableById(c);
     if (s.empty())
       return false;
@@ -284,7 +283,7 @@ DictionaryComponent::DictionaryComponent() {
 
 Dictionary* DictionaryComponent::Create(const Ticket& ticket) {
   if (!ticket.schema) return NULL;
-  Config* config = ticket.schema->config();
+  Config *config = ticket.schema->config();
   std::string dict_name;
   if (!config->GetString(ticket.name_space + "/dictionary", &dict_name)) {
     LOG(ERROR) << ticket.name_space << "/dictionary not specified in schema '"
@@ -301,19 +300,18 @@ Dictionary* DictionaryComponent::Create(const Ticket& ticket) {
   return CreateDictionaryWithName(dict_name, prism_name);
 }
 
-Dictionary*
-DictionaryComponent::CreateDictionaryWithName(const std::string& dict_name,
-                                              const std::string& prism_name) {
+Dictionary* DictionaryComponent::CreateDictionaryWithName(
+    const std::string &dict_name, const std::string &prism_name) {
   // obtain prism and table objects
   boost::filesystem::path path(Service::instance().deployer().user_data_dir);
-  auto table = table_map_[dict_name].lock();
+  shared_ptr<Table> table(table_map_[dict_name].lock());
   if (!table) {
-    table = New<Table>((path / dict_name).string() + ".table.bin");
+    table = boost::make_shared<Table>((path / dict_name).string() + ".table.bin");
     table_map_[dict_name] = table;
   }
-  auto prism = prism_map_[prism_name].lock();
+  shared_ptr<Prism> prism(prism_map_[prism_name].lock());
   if (!prism) {
-    prism = New<Prism>((path / prism_name).string() + ".prism.bin");
+    prism = boost::make_shared<Prism>((path / prism_name).string() + ".prism.bin");
     prism_map_[prism_name] = prism;
   }
   return new Dictionary(dict_name, table, prism);
diff --git a/src/dict/entry_collector.cc b/src/dict/entry_collector.cc
index ae2c782..ee01288 100644
--- a/src/dict/entry_collector.cc
+++ b/src/dict/entry_collector.cc
@@ -6,6 +6,7 @@
 //
 #include <fstream>
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <boost/lexical_cast.hpp>
 #include <rime/dict/dict_settings.h>
 #include <rime/dict/entry_collector.h>
@@ -13,7 +14,8 @@
 
 namespace rime {
 
-EntryCollector::EntryCollector() {
+EntryCollector::EntryCollector()
+    : num_entries(0) {
 }
 
 EntryCollector::~EntryCollector() {
@@ -34,7 +36,7 @@ void EntryCollector::Configure(DictSettings* settings) {
 }
 
 void EntryCollector::Collect(const std::vector<std::string>& dict_files) {
-  for (const std::string& dict_file : dict_files) {
+  BOOST_FOREACH(const std::string& dict_file, dict_files) {
     Collect(dict_file);
   }
   Finish();
@@ -91,7 +93,7 @@ void EntryCollector::Collect(const std::string& dict_file) {
       LOG(WARNING) << "Missing entry text at #" << num_entries << ".";
       continue;
     }
-    const auto& word(row[text_column]);
+    std::string &word(row[text_column]);
     std::string code_str;
     std::string weight_str;
     std::string stem_str;
@@ -110,7 +112,7 @@ void EntryCollector::Collect(const std::string& dict_file) {
       CreateEntry(word, code_str, weight_str);
     }
     else {
-      encode_queue.push({word, weight_str});
+      encode_queue.push(std::make_pair(word, weight_str));
     }
     if (!stem_str.empty() && !code_str.empty()) {
       DLOG(INFO) << "add stem '" << word << "': "
@@ -126,8 +128,8 @@ void EntryCollector::Collect(const std::string& dict_file) {
 
 void EntryCollector::Finish() {
   while (!encode_queue.empty()) {
-    const auto& phrase(encode_queue.front().first);
-    const auto& weight_str(encode_queue.front().second);
+    const std::string &phrase(encode_queue.front().first);
+    const std::string &weight_str(encode_queue.front().second);
     if (!encoder->EncodePhrase(phrase, weight_str)) {
       LOG(ERROR) << "Encode failure: '" << phrase << "'.";
     }
@@ -181,7 +183,7 @@ void EntryCollector::CreateEntry(const std::string &word,
     }
   }
   // learn new syllables
-  for (const std::string& s : e.raw_code) {
+  BOOST_FOREACH(const std::string &s, e.raw_code) {
     if (syllabary.find(s) == syllabary.end())
       syllabary.insert(s);
   }
@@ -204,14 +206,14 @@ bool EntryCollector::TranslateWord(const std::string& word,
                                    std::vector<std::string>* result) {
   ReverseLookupTable::const_iterator s = stems.find(word);
   if (s != stems.end()) {
-    for (const std::string& stem : s->second) {
+    BOOST_FOREACH(const std::string& stem, s->second) {
       result->push_back(stem);
     }
     return true;
   }
   WordMap::const_iterator w = words.find(word);
   if (w != words.end()) {
-    for (const auto& v : w->second) {
+    BOOST_FOREACH(const WeightMap::value_type& v, w->second) {
       const double kMinimalWeight = 0.05;  // 5%
       double min_weight = total_weight[word] * kMinimalWeight;
       if (v.second < min_weight)
@@ -226,11 +228,11 @@ bool EntryCollector::TranslateWord(const std::string& word,
 void EntryCollector::Dump(const std::string& file_name) const {
   std::ofstream out(file_name.c_str());
   out << "# syllabary:" << std::endl;
-  for (const std::string& syllable : syllabary) {
+  BOOST_FOREACH(const std::string& syllable, syllabary) {
     out << "# - " << syllable << std::endl;
   }
   out << std::endl;
-  for (const RawDictEntry& e : entries) {
+  BOOST_FOREACH(const RawDictEntry &e, entries) {
     out << e.text << '\t'
         << e.raw_code.ToString() << '\t'
         << e.weight << std::endl;
diff --git a/src/dict/mapped_file.cc b/src/dict/mapped_file.cc
index 6fd21a6..d3a4bfc 100644
--- a/src/dict/mapped_file.cc
+++ b/src/dict/mapped_file.cc
@@ -47,7 +47,7 @@ class MappedFileImpl {
     kOpenReadWrite,
   };
 
-  MappedFileImpl(const std::string& file_name, OpenMode mode) {
+  MappedFileImpl(const std::string &file_name, OpenMode mode) {
     boost::interprocess::mode_t file_mapping_mode =
         (mode == kOpenReadOnly) ? boost::interprocess::read_only
                                 : boost::interprocess::read_write;
@@ -69,13 +69,15 @@ class MappedFileImpl {
   }
 
  private:
-  unique_ptr<boost::interprocess::file_mapping> file_;
-  unique_ptr<boost::interprocess::mapped_region> region_;
+  scoped_ptr<boost::interprocess::file_mapping> file_;
+  scoped_ptr<boost::interprocess::mapped_region> region_;
 
 };
 
-MappedFile::MappedFile(const std::string& file_name)
-    : file_name_(file_name) {
+MappedFile::MappedFile(const std::string &file_name)
+    : file_name_(file_name),
+      size_(0),
+      file_() {
 }
 
 MappedFile::~MappedFile() {
@@ -104,7 +106,7 @@ bool MappedFile::Create(size_t capacity) {
   LOG(INFO) << "opening file for read/write access.";
   file_.reset(new MappedFileImpl(file_name_, MappedFileImpl::kOpenReadWrite));
   size_ = 0;
-  return bool(file_);
+  return file_;
 }
 
 bool MappedFile::OpenReadOnly() {
@@ -114,7 +116,7 @@ bool MappedFile::OpenReadOnly() {
   }
   file_.reset(new MappedFileImpl(file_name_, MappedFileImpl::kOpenReadOnly));
   size_ = file_->get_size();
-  return bool(file_);
+  return file_;
 }
 
 bool MappedFile::OpenReadWrite() {
@@ -124,7 +126,7 @@ bool MappedFile::OpenReadWrite() {
   }
   file_.reset(new MappedFileImpl(file_name_, MappedFileImpl::kOpenReadWrite));
   size_ = 0;
-  return bool(file_);
+  return file_;
 }
 
 void MappedFile::Close() {
@@ -139,7 +141,7 @@ bool MappedFile::Exists() const {
 }
 
 bool MappedFile::IsOpen() const {
-  return bool(file_);
+  return file_;
 }
 
 bool MappedFile::Flush() {
@@ -172,7 +174,7 @@ bool MappedFile::Resize(size_t capacity) {
   return true;
 }
 
-String* MappedFile::CreateString(const std::string& str) {
+String* MappedFile::CreateString(const std::string &str) {
   String* ret = Allocate<String>();
   if (ret && !str.empty()) {
     CopyString(str, ret);
@@ -180,11 +182,11 @@ String* MappedFile::CreateString(const std::string& str) {
   return ret;
 }
 
-bool MappedFile::CopyString(const std::string& src, String* dest) {
+bool MappedFile::CopyString(const std::string &src, String *dest) {
   if (!dest)
     return false;
   size_t size = src.length() + 1;
-  char* ptr = Allocate<char>(size);
+  char *ptr = Allocate<char>(size);
   if (!ptr)
     return false;
   std::strncpy(ptr, src.c_str(), size);
diff --git a/src/dict/preset_vocabulary.cc b/src/dict/preset_vocabulary.cc
index f74ea58..c5bc097 100644
--- a/src/dict/preset_vocabulary.cc
+++ b/src/dict/preset_vocabulary.cc
@@ -55,7 +55,8 @@ std::string PresetVocabulary::DictFilePath() {
   return path.string();
 }
 
-PresetVocabulary::PresetVocabulary() {
+PresetVocabulary::PresetVocabulary()
+    : max_phrase_length_(0), min_phrase_weight_(0.0) {
   db_.reset(new VocabularyDb(DictFilePath()));
   if (db_ && db_->OpenReadOnly()) {
     db_->cursor = db_->QueryAll();
diff --git a/src/dict/prism.cc b/src/dict/prism.cc
index d3e0f4a..b839d94 100644
--- a/src/dict/prism.cc
+++ b/src/dict/prism.cc
@@ -16,6 +16,8 @@ namespace {
 struct node_t {
   std::string key;
   size_t node_pos;
+  node_t(const std::string& k, size_t pos) : key(k), node_pos(pos) {
+  }
 };
 
 }  // namespace
@@ -69,10 +71,6 @@ SpellingProperties SpellingAccessor::properties() const {
   return props;
 }
 
-Prism::Prism(const std::string& file_name)
-  : MappedFile(file_name), trie_(new Darts::DoubleArray) {
-}
-
 bool Prism::Load() {
   LOG(INFO) << "loading prism file: " << file_name();
 
@@ -97,7 +95,7 @@ bool Prism::Load() {
   }
   format_ = atof(&metadata_->format[kPrismFormatPrefixLen]);
 
-  char* array = metadata_->double_array.get();
+  char *array = metadata_->double_array.get();
   if (!array) {
     LOG(ERROR) << "double array image not found.";
     Close();
@@ -123,24 +121,26 @@ bool Prism::Save() {
   return ShrinkToFit();
 }
 
-bool Prism::Build(const Syllabary& syllabary,
-                  const Script* script,
+bool Prism::Build(const Syllabary &syllabary,
+                  const Script *script,
                   uint32_t dict_file_checksum,
                   uint32_t schema_file_checksum) {
   // building double-array trie
   size_t num_syllables = syllabary.size();
   size_t num_spellings = script ? script->size() : syllabary.size();
-  std::vector<const char*> keys(num_spellings);
+  std::vector<const char *> keys(num_spellings);
   size_t key_id = 0;
   size_t map_size = 0;
   if (script) {
-    for (auto it = script->begin(); it != script->end(); ++it, ++key_id) {
+    for (Script::const_iterator it = script->begin();
+         it != script->end(); ++it, ++key_id) {
       keys[key_id] = it->first.c_str();
       map_size += it->second.size();
     }
   }
   else {
-    for (auto it = syllabary.begin(); it != syllabary.end(); ++it, ++key_id) {
+    for (Syllabary::const_iterator it = syllabary.begin();
+         it != syllabary.end(); ++it, ++key_id) {
       keys[key_id] = it->c_str();
     }
   }
@@ -160,7 +160,7 @@ bool Prism::Build(const Syllabary& syllabary,
     return false;
   }
   // creating metadata
-  auto metadata = Allocate<prism::Metadata>();
+  prism::Metadata *metadata = Allocate<prism::Metadata>();
   if (!metadata) {
     LOG(ERROR) << "Error creating metadata in file '" << file_name() << "'.";
     return false;
@@ -174,16 +174,16 @@ bool Prism::Build(const Syllabary& syllabary,
   {
     std::set<char> alphabet;
     for (size_t i = 0; i < num_spellings; ++i)
-      for (const char* p = keys[i]; *p; ++p)
+      for (const char *p = keys[i]; *p; ++p)
         alphabet.insert(*p);
-    char* p = metadata->alphabet;
+    char *p = metadata->alphabet;
     std::set<char>::const_iterator c = alphabet.begin();
     for (; c != alphabet.end(); ++p, ++c)
       *p = *c;
     *p = '\0';
   }
   // saving double-array image
-  char* array = Allocate<char>(image_size);
+  char *array = Allocate<char>(image_size);
   if (!array) {
     LOG(ERROR) << "Error creating double-array image.";
     return false;
@@ -195,17 +195,19 @@ bool Prism::Build(const Syllabary& syllabary,
   if (script) {
     std::map<std::string, SyllableId> syllable_to_id;
     SyllableId syll_id = 0;
-    for (auto it = syllabary.begin(); it != syllabary.end(); ++it) {
+    for (Syllabary::const_iterator it = syllabary.begin();
+         it != syllabary.end(); ++it) {
       syllable_to_id[*it] = syll_id++;
     }
-    auto spelling_map = CreateArray<prism::SpellingMapItem>(num_spellings);
+    prism::SpellingMap* spelling_map = CreateArray<prism::SpellingMapItem>(num_spellings);
     if (!spelling_map) {
       LOG(ERROR) << "Error creating spelling map.";
       return false;
     }
-    auto i = script->begin();
-    auto item = spelling_map->begin();
-    for (; i != script->end(); ++i, ++item) {
+    Script::const_iterator i;
+    prism::SpellingMapItem* item;
+    for (i = script->begin(), item = spelling_map->begin();
+         i != script->end(); ++i, ++item) {
       size_t list_size = i->second.size();
       item->size = list_size;
       item->at = Allocate<prism::SpellingDescriptor>(list_size);
@@ -213,9 +215,10 @@ bool Prism::Build(const Syllabary& syllabary,
         LOG(ERROR) << "Error creating spelling descriptors.";
         return false;
       }
-      auto j = i->second.begin();
-      auto desc = item->begin();
-      for (; j != i->second.end(); ++j, ++desc) {
+      std::vector<Spelling>::const_iterator j;
+      prism::SpellingDescriptor* desc;
+      for (j = i->second.begin(), desc = item->begin();
+           j != i->second.end(); ++j, ++desc) {
         desc->syllable_id = syllable_to_id[j->str];
         desc->type = static_cast<int32_t>(j->properties.type);
         desc->credibility = j->properties.credibility;
@@ -230,8 +233,7 @@ bool Prism::Build(const Syllabary& syllabary,
     spelling_map_ = spelling_map;
   }
   // at last, complete the metadata
-  std::strncpy(metadata->format, kPrismFormat,
-               prism::Metadata::kFormatMaxLength);
+  std::strncpy(metadata->format, kPrismFormat, prism::Metadata::kFormatMaxLength);
   return true;
 }
 
@@ -249,22 +251,17 @@ bool Prism::GetValue(const std::string& key, int* value) {
   return true;
 }
 
-// Given a key, search all the keys in the tree that share
-// a common prefix with that key.
-void Prism::CommonPrefixSearch(const std::string& key,
-                               std::vector<Match>* result) {
+// Given a key, search all the keys in the tree which share a common prefix with that key.
+void Prism::CommonPrefixSearch(const std::string &key, std::vector<Match> *result) {
   if (!result || key.empty())
     return;
   size_t len = key.length();
   result->resize(len);
-  size_t num_results = trie_->commonPrefixSearch(key.c_str(),
-                                                 &result->front(), len, len);
+  size_t num_results = trie_->commonPrefixSearch(key.c_str(), &result->front(), len, len);
   result->resize(num_results);
 }
 
-void Prism::ExpandSearch(const std::string& key,
-                         std::vector<Match>* result,
-                         size_t limit) {
+void Prism::ExpandSearch(const std::string &key, std::vector<Match> *result, size_t limit) {
   if (!result)
     return;
   result->clear();
@@ -276,12 +273,17 @@ void Prism::ExpandSearch(const std::string& key,
   if (ret == -2)
     return;
   if (ret != -1) {
-    result->push_back(Match{ret, key_pos});
+    {
+      Match match;
+      match.value = ret;
+      match.length = key_pos;
+      result->push_back(match);
+    }
     if (limit && ++count >= limit)
       return;
   }
   std::queue<node_t> q;
-  q.push({key, node_pos});
+  q.push(node_t(key, node_pos));
   while(!q.empty()) {
     node_t node = q.front();
     q.pop();
@@ -296,11 +298,16 @@ void Prism::ExpandSearch(const std::string& key,
         //ignore
       }
       else if (ret == -1) {
-        q.push({k, n_pos});
+        q.push(node_t(k, n_pos));
       }
       else {
-        q.push({k, n_pos});
-        result->push_back(Match{ret, k_pos});
+        q.push(node_t(k, n_pos));
+        {
+          Match match;
+          match.value = ret;
+          match.length = k_pos;
+          result->push_back(match);
+        }
         if (limit && ++count >= limit)
           return;
       }
diff --git a/src/dict/reverse_lookup_dictionary.cc b/src/dict/reverse_lookup_dictionary.cc
index f035324..300b2c3 100644
--- a/src/dict/reverse_lookup_dictionary.cc
+++ b/src/dict/reverse_lookup_dictionary.cc
@@ -7,6 +7,7 @@
 //
 #include <sstream>
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <boost/filesystem.hpp>
 #include <boost/lexical_cast.hpp>
 #include <rime/schema.h>
@@ -30,7 +31,7 @@ static std::string reverse_db_file_name(const std::string& dict_name) {
 }
 
 ReverseDb::ReverseDb(const std::string& dict_name)
-    : MappedFile(reverse_db_file_name(dict_name)) {
+    : MappedFile(reverse_db_file_name(dict_name)), metadata_(NULL) {
 }
 
 bool ReverseDb::Load() {
@@ -87,12 +88,12 @@ bool ReverseDb::Build(DictSettings* settings,
   LOG(INFO) << "building reversedb...";
   ReverseLookupTable rev_table;
   int syllable_id = 0;
-  for (const std::string& syllable : syllabary) {
-    auto it = vocabulary.find(syllable_id++);
+  BOOST_FOREACH(const std::string& syllable, syllabary) {
+    Vocabulary::const_iterator it = vocabulary.find(syllable_id++);
     if (it == vocabulary.end())
       continue;
-    const auto& entries(it->second.entries);
-    for (const auto& e : entries) {
+    const DictEntryList& entries(it->second.entries);
+    BOOST_FOREACH(const shared_ptr<DictEntry>& e, entries) {
       rev_table[e->text].insert(syllable);
     }
   }
@@ -103,7 +104,7 @@ bool ReverseDb::Build(DictSettings* settings,
   std::vector<StringId> value_ids(entry_count);
   int i = 0;
   // save reverse lookup entries
-  for (const auto& v : rev_table) {
+  BOOST_FOREACH(const ReverseLookupTable::value_type& v, rev_table) {
     const std::string& key(v.first);
     std::string value(boost::algorithm::join(v.second, " "));
     key_trie_builder.Add(key, 1.0, &key_ids[i]);
@@ -111,7 +112,7 @@ bool ReverseDb::Build(DictSettings* settings,
     ++i;
   }
   // save stems
-  for (const auto& v : stems) {
+  BOOST_FOREACH(const ReverseLookupTable::value_type& v, stems) {
     std::string key(v.first + kStemKeySuffix);
     std::string value(boost::algorithm::join(v.second, " "));
     key_trie_builder.Add(key, 1.0, &key_ids[i]);
@@ -156,7 +157,7 @@ bool ReverseDb::Build(DictSettings* settings,
     }
   }
 
-  auto entries = Allocate<StringId>(entry_count);
+  StringId* entries = Allocate<StringId>(entry_count);
   if (!entries) {
     return false;
   }
@@ -225,7 +226,7 @@ shared_ptr<DictSettings> ReverseLookupDictionary::GetDictSettings() {
   if (metadata && !metadata->dict_settings.empty()) {
     std::string yaml(metadata->dict_settings.c_str());
     std::istringstream iss(yaml);
-    settings = New<DictSettings>();
+    settings = make_shared<DictSettings>();
     if (!settings->LoadFromStream(iss)) {
       settings.reset();
     }
@@ -236,19 +237,19 @@ shared_ptr<DictSettings> ReverseLookupDictionary::GetDictSettings() {
 ReverseLookupDictionaryComponent::ReverseLookupDictionaryComponent() {
 }
 
-ReverseLookupDictionary*
-ReverseLookupDictionaryComponent::Create(const Ticket& ticket) {
+ReverseLookupDictionary* ReverseLookupDictionaryComponent::Create(
+    const Ticket& ticket) {
   if (!ticket.schema) return NULL;
-  Config* config = ticket.schema->config();
+  Config *config = ticket.schema->config();
   std::string dict_name;
   if (!config->GetString(ticket.name_space + "/dictionary",
                          &dict_name)) {
     // missing!
     return NULL;
   }
-  auto db = db_pool_[dict_name].lock();
+  shared_ptr<ReverseDb> db(db_pool_[dict_name].lock());
   if (!db) {
-    db = New<ReverseDb>(dict_name);
+    db = boost::make_shared<ReverseDb>(dict_name);
     db_pool_[dict_name] = db;
   }
   return new ReverseLookupDictionary(db);
diff --git a/src/dict/string_table.cc b/src/dict/string_table.cc
index 09a4c47..4575f58 100644
--- a/src/dict/string_table.cc
+++ b/src/dict/string_table.cc
@@ -111,7 +111,7 @@ void StringTableBuilder::Dump(char* ptr, size_t size) {
   }
   namespace io = boost::iostreams;
   io::basic_array_sink<char> sink(ptr, size);
-  io::stream<io::basic_array_sink<char>> stream(sink);
+  io::stream<io::basic_array_sink<char> > stream(sink);
   stream << trie_;
 }
 
diff --git a/src/dict/table.cc b/src/dict/table.cc
index 079299b..c85cb13 100644
--- a/src/dict/table.cc
+++ b/src/dict/table.cc
@@ -10,6 +10,7 @@
 #include <queue>
 #include <vector>
 #include <utility>
+#include <boost/foreach.hpp>
 #include <rime/algo/syllabifier.h>
 #include <rime/dict/table.h>
 
@@ -25,7 +26,11 @@ const size_t kTableFormatPrefixLen = sizeof(kTableFormatPrefix) - 1;
 
 class TableQuery {
  public:
-  TableQuery(table::Index* index) : lv1_index_(index) {
+  TableQuery(table::Index* index) : level_(0),
+                                    lv1_index_(index),
+                                    lv2_index_(NULL),
+                                    lv3_index_(NULL),
+                                    lv4_index_(NULL) {
     Reset();
   }
 
@@ -44,25 +49,32 @@ class TableQuery {
   size_t level() const { return level_; }
 
  protected:
-  size_t level_ = 0;
+  size_t level_;
   Code index_code_;
   std::vector<double> credibility_;
 
  private:
   bool Walk(SyllableId syllable_id);
 
-  table::HeadIndex* lv1_index_ = nullptr;
-  table::TrunkIndex* lv2_index_ = nullptr;
-  table::TrunkIndex* lv3_index_ = nullptr;
-  table::TailIndex* lv4_index_ = nullptr;
+  table::HeadIndex* lv1_index_;
+  table::TrunkIndex* lv2_index_;
+  table::TrunkIndex* lv3_index_;
+  table::TailIndex* lv4_index_;
 };
 
+TableAccessor::TableAccessor()
+    : entries_(NULL), long_entries_(NULL),
+      size_(0), cursor_(0), credibility_(1.0) {
+}
+
 TableAccessor::TableAccessor(const Code& index_code,
                              const List<table::Entry>* list,
                              double credibility)
     : index_code_(index_code),
       entries_(list->at.get()),
+      long_entries_(NULL),
       size_(list->size),
+      cursor_(0),
       credibility_(credibility) {
 }
 
@@ -71,16 +83,20 @@ TableAccessor::TableAccessor(const Code& index_code,
                              double credibility)
     : index_code_(index_code),
       entries_(array->at),
+      long_entries_(NULL),
       size_(array->size),
+      cursor_(0),
       credibility_(credibility) {
 }
 
-TableAccessor::TableAccessor(const Code& index_code,
-                             const table::TailIndex* code_map,
+TableAccessor::TableAccessor(const Code &index_code,
+                             const table::TailIndex *code_map,
                              double credibility)
     : index_code_(index_code),
+      entries_(NULL),
       long_entries_(code_map->at),
       size_(code_map->size),
+      cursor_(0),
       credibility_(credibility) {
 }
 
@@ -114,12 +130,12 @@ const table::Code* TableAccessor::extra_code() const {
 }
 
 Code TableAccessor::code() const {
-  auto extra = extra_code();
+  const table::Code *extra = extra_code();
   if (!extra) {
     return index_code();
   }
   Code code(index_code());
-  for (auto p = extra->begin(); p != extra->end(); ++p) {
+  for (const SyllableId *p = extra->begin(); p != extra->end(); ++p) {
     code.push_back(*p);
   }
   return code;
@@ -170,7 +186,7 @@ static table::TrunkIndexNode* find_node(table::TrunkIndexNode* first,
                                         const SyllableId& key) {
   table::TrunkIndexNode target;
   target.key = key;
-  auto it = std::lower_bound(first, last, target, node_less);
+  table::TrunkIndexNode* it = std::lower_bound(first, last, target, node_less);
   return it == last || key < it->key ? last : it;
 }
 
@@ -180,30 +196,34 @@ bool TableQuery::Walk(SyllableId syllable_id) {
         syllable_id < 0 ||
         syllable_id >= static_cast<SyllableId>(lv1_index_->size))
       return false;
-    auto node = &lv1_index_->at[syllable_id];
+    table::HeadIndexNode* node = &lv1_index_->at[syllable_id];
     if (!node->next_level)
       return false;
-    lv2_index_ = &node->next_level->trunk;
+    lv2_index_ = reinterpret_cast<table::TrunkIndex*>(node->next_level.get());
   }
   else if (level_ == 1) {
     if (!lv2_index_)
       return false;
-    auto node = find_node(lv2_index_->begin(), lv2_index_->end(), syllable_id);
+    table::TrunkIndexNode *node = find_node(lv2_index_->begin(),
+                                            lv2_index_->end(),
+                                            syllable_id);
     if (node == lv2_index_->end())
       return false;
     if (!node->next_level)
       return false;
-    lv3_index_ = &node->next_level->trunk;
+    lv3_index_ = reinterpret_cast<table::TrunkIndex*>(node->next_level.get());
   }
   else if (level_ == 2) {
     if (!lv3_index_)
       return false;
-    auto node = find_node(lv3_index_->begin(), lv3_index_->end(), syllable_id);
+    table::TrunkIndexNode *node = find_node(lv3_index_->begin(),
+                                            lv3_index_->end(),
+                                            syllable_id);
     if (node == lv3_index_->end())
       return false;
     if (!node->next_level)
       return false;
-    lv4_index_ = &node->next_level->tail;
+    lv4_index_ = reinterpret_cast<table::TailIndex*>(node->next_level.get());
   }
   else {
     return false;
@@ -224,15 +244,15 @@ TableAccessor TableQuery::Access(SyllableId syllable_id,
         syllable_id < 0 ||
         syllable_id >= static_cast<SyllableId>(lv1_index_->size))
       return TableAccessor();
-    auto node = &lv1_index_->at[syllable_id];
+    table::HeadIndexNode* node = &lv1_index_->at[syllable_id];
     return TableAccessor(add_syllable(index_code_, syllable_id),
                          &node->entries, credibility);
   }
   else if (level_ == 1 || level_ == 2) {
-    auto index = (level_ == 1) ? lv2_index_ : lv3_index_;
+    table::TrunkIndex* index = (level_ == 1) ? lv2_index_ : lv3_index_;
     if (!index)
       return TableAccessor();
-    auto node = find_node(index->begin(), index->end(), syllable_id);
+    table::TrunkIndexNode* node = find_node(index->begin(), index->end(), syllable_id);
     if (node == index->end())
       return TableAccessor();
     return TableAccessor(add_syllable(index_code_, syllable_id),
@@ -247,12 +267,12 @@ TableAccessor TableQuery::Access(SyllableId syllable_id,
 }
 
 std::string Table::GetString_v1(const table::StringType& x) {
- return x.str.c_str();
+ return reinterpret_cast<const String*>(&x.offset)->c_str();
 }
 
 bool Table::AddString_v1(const std::string& src, table::StringType* dest,
                          double /*weight*/) {
-  return CopyString(src, &dest->str);
+  return CopyString(src, reinterpret_cast<String*>(&dest->offset));
 }
 
 std::string Table::GetString_v2(const table::StringType& x) {
@@ -304,13 +324,17 @@ void Table::SelectTableFormat(double format_version) {
     format_.format_name = kTableFormat_v1;
     format_.GetString = &Table::GetString_v1;
     format_.AddString = &Table::AddString_v1;
-    format_.OnBuildStart = nullptr;
-    format_.OnBuildFinish = nullptr;
-    format_.OnLoad = nullptr;
+    format_.OnBuildStart = NULL;
+    format_.OnBuildFinish = NULL;
+    format_.OnLoad = NULL;
   }
 }
 
-Table::Table(const std::string& file_name) : MappedFile(file_name) {
+Table::Table(const std::string& file_name)
+    : MappedFile(file_name),
+      metadata_(NULL),
+      syllabary_(NULL),
+      index_(NULL) {
 }
 
 Table::~Table() {
@@ -414,7 +438,7 @@ bool Table::Build(const Syllabary& syllabary, const Vocabulary& vocabulary,
   }
   else {
     size_t i = 0;
-    for (const std::string& syllable : syllabary) {
+    BOOST_FOREACH(const std::string &syllable, syllabary) {
       RIME_THIS_CALL(format_.AddString)(syllable, &syllabary_->at[i++], 0.0);
     }
   }
@@ -446,25 +470,25 @@ table::Index* Table::BuildIndex(const Vocabulary& vocabulary,
 
 table::HeadIndex* Table::BuildHeadIndex(const Vocabulary& vocabulary,
                                         size_t num_syllables) {
-  auto index = CreateArray<table::HeadIndexNode>(num_syllables);
+  table::HeadIndex* index = CreateArray<table::HeadIndexNode>(num_syllables);
   if (!index) {
     return NULL;
   }
-  for (const auto& v : vocabulary) {
+  BOOST_FOREACH(const Vocabulary::value_type &v, vocabulary) {
     int syllable_id = v.first;
-    auto& node(index->at[syllable_id]);
-    const auto& entries(v.second.entries);
+    table::HeadIndexNode &node(index->at[syllable_id]);
+    const DictEntryList &entries(v.second.entries);
     if (!BuildEntryList(entries, &node.entries)) {
         return NULL;
     }
     if (v.second.next_level) {
       Code code;
       code.push_back(syllable_id);
-      auto next_level_index = BuildTrunkIndex(code, *v.second.next_level);
+      table::TrunkIndex *next_level_index = BuildTrunkIndex(code, *v.second.next_level);
       if (!next_level_index) {
         return NULL;
       }
-      node.next_level = reinterpret_cast<table::PhraseIndex*>(next_level_index);
+      node.next_level = reinterpret_cast<char*>(next_level_index);
     }
   }
   return index;
@@ -472,16 +496,16 @@ table::HeadIndex* Table::BuildHeadIndex(const Vocabulary& vocabulary,
 
 table::TrunkIndex* Table::BuildTrunkIndex(const Code& prefix,
                                           const Vocabulary& vocabulary) {
-  auto index = CreateArray<table::TrunkIndexNode>(vocabulary.size());
+  table::TrunkIndex *index = CreateArray<table::TrunkIndexNode>(vocabulary.size());
   if (!index) {
     return NULL;
   }
   size_t count = 0;
-  for (const auto& v : vocabulary) {
+  BOOST_FOREACH(const Vocabulary::value_type &v, vocabulary) {
     int syllable_id = v.first;
-    auto& node(index->at[count++]);
+    table::TrunkIndexNode &node(index->at[count++]);
     node.key = syllable_id;
-    const auto& entries(v.second.entries);
+    const DictEntryList &entries(v.second.entries);
     if (!BuildEntryList(entries, &node.entries)) {
         return NULL;
     }
@@ -489,19 +513,18 @@ table::TrunkIndex* Table::BuildTrunkIndex(const Code& prefix,
       Code code(prefix);
       code.push_back(syllable_id);
       if (code.size() < Code::kIndexCodeMaxLength) {
-        auto next_level_index = BuildTrunkIndex(code, *v.second.next_level);
+        table::TrunkIndex *next_level_index = BuildTrunkIndex(code, *v.second.next_level);
         if (!next_level_index) {
           return NULL;
         }
-        node.next_level =
-            reinterpret_cast<table::PhraseIndex*>(next_level_index);
+        node.next_level = reinterpret_cast<char*>(next_level_index);
       }
       else {
-        auto tail_index = BuildTailIndex(code, *v.second.next_level);
+        table::TailIndex *tail_index = BuildTailIndex(code, *v.second.next_level);
         if (!tail_index) {
           return NULL;
         }
-        node.next_level = reinterpret_cast<table::PhraseIndex*>(tail_index);
+        node.next_level = reinterpret_cast<char*>(tail_index);
       }
     }
   }
@@ -513,17 +536,17 @@ table::TailIndex* Table::BuildTailIndex(const Code& prefix,
   if (vocabulary.find(-1) == vocabulary.end()) {
     return NULL;
   }
-  const auto& page(vocabulary.find(-1)->second);
+  const VocabularyPage &page(vocabulary.find(-1)->second);
   DLOG(INFO) << "page size: " << page.entries.size();
-  auto index = CreateArray<table::LongEntry>(page.entries.size());
+  table::TailIndex *index = CreateArray<table::LongEntry>(page.entries.size());
   if (!index) {
     return NULL;
   }
   size_t count = 0;
-  for (const auto& src : page.entries) {
+  BOOST_FOREACH(const DictEntryList::value_type &src, page.entries) {
     DLOG(INFO) << "count: " << count;
     DLOG(INFO) << "entry: " << src->text;
-    auto& dest(index->at[count++]);
+    table::LongEntry &dest(index->at[count++]);
     size_t extra_code_length = src->code.size() - Code::kIndexCodeMaxLength;
     DLOG(INFO) << "extra code length: " << extra_code_length;
     dest.extra_code.size = extra_code_length;
@@ -541,7 +564,7 @@ table::TailIndex* Table::BuildTailIndex(const Code& prefix,
 }
 
 Array<table::Entry>* Table::BuildEntryArray(const DictEntryList& entries) {
-  auto array = CreateArray<table::Entry>(entries.size());
+  Array<table::Entry>* array = CreateArray<table::Entry>(entries.size());
   if (!array) {
     return NULL;
   }
@@ -564,14 +587,14 @@ bool Table::BuildEntryList(const DictEntryList& src,
     return false;
   }
   size_t i = 0;
-  for (auto d = src.begin(); d != src.end(); ++d, ++i) {
+  for (DictEntryList::const_iterator d = src.begin(); d != src.end(); ++d, ++i) {
     if (!BuildEntry(**d, &dest->at[i]))
       return false;
   }
   return true;
 }
 
-bool Table::BuildEntry(const DictEntry& dict_entry, table::Entry* entry) {
+bool Table::BuildEntry(const DictEntry &dict_entry, table::Entry *entry) {
   if (!entry)
     return false;
   if (!RIME_THIS_CALL(format_.AddString)(dict_entry.text, &entry->text,
@@ -584,7 +607,7 @@ bool Table::BuildEntry(const DictEntry& dict_entry, table::Entry* entry) {
   return true;
 }
 
-bool Table::GetSyllabary(Syllabary* result) {
+bool Table::GetSyllabary(Syllabary *result) {
   if (!result || !syllabary_)
     return false;
   for (size_t i = 0; i < syllabary_->size; ++i) {
@@ -618,21 +641,21 @@ TableAccessor Table::QueryPhrases(const Code& code) {
   return query.Access(-1);
 }
 
-bool Table::Query(const SyllableGraph& syll_graph, size_t start_pos,
-                  TableQueryResult* result) {
+bool Table::Query(const SyllableGraph &syll_graph, size_t start_pos,
+                  TableQueryResult *result) {
   if (!result ||
       !index_ ||
       start_pos >= syll_graph.interpreted_length)
     return false;
   result->clear();
-  std::queue<std::pair<size_t, TableQuery>> q;
+  std::queue<std::pair<size_t, TableQuery> > q;
   TableQuery initial_state(index_);
-  q.push({start_pos, initial_state});
+  q.push(std::make_pair(start_pos, initial_state));
   while (!q.empty()) {
     size_t current_pos = q.front().first;
     TableQuery query(q.front().second);
     q.pop();
-    auto index = syll_graph.indices.find(current_pos);
+    SpellingIndices::const_iterator index = syll_graph.indices.find(current_pos);
     if (index == syll_graph.indices.end()) {
       continue;
     }
@@ -643,17 +666,17 @@ bool Table::Query(const SyllableGraph& syll_graph, size_t start_pos,
       }
       continue;
     }
-    for (const auto& spellings : index->second) {
+    BOOST_FOREACH(const SpellingIndex::value_type& spellings, index->second) {
       SyllableId syll_id = spellings.first;
       TableAccessor accessor(query.Access(syll_id));
-      for (auto props : spellings.second) {
+      BOOST_FOREACH(const SpellingProperties* props, spellings.second) {
         size_t end_pos = props->end_pos;
         if (!accessor.exhausted()) {
           (*result)[end_pos].push_back(accessor);
         }
         if (end_pos < syll_graph.interpreted_length &&
             query.Advance(syll_id, props->credibility)) {
-          q.push({end_pos, query});
+          q.push(std::make_pair(end_pos, query));
           query.Backdate();
         }
       }
diff --git a/src/dict/text_db.cc b/src/dict/text_db.cc
index 9e8711d..7556346 100644
--- a/src/dict/text_db.cc
+++ b/src/dict/text_db.cc
@@ -25,12 +25,12 @@ bool TextDbAccessor::Reset() {
   return iter_ != data_.end();
 }
 
-bool TextDbAccessor::Jump(const std::string& key) {
+bool TextDbAccessor::Jump(const std::string &key) {
   iter_ = data_.lower_bound(key);
   return iter_ != data_.end();
 }
 
-bool TextDbAccessor::GetNextRecord(std::string* key, std::string* value) {
+bool TextDbAccessor::GetNextRecord(std::string *key, std::string *value) {
   if (!key || !value || exhausted())
     return false;
   *key = iter_->first;
@@ -48,7 +48,10 @@ bool TextDbAccessor::exhausted() {
 TextDb::TextDb(const std::string& name,
                const std::string& db_type,
                TextFormat format)
-    : Db(name), db_type_(db_type), format_(format) {
+    : Db(name),
+      db_type_(db_type),
+      format_(format),
+      modified_(false) {
 }
 
 TextDb::~TextDb() {
@@ -58,21 +61,21 @@ TextDb::~TextDb() {
 
 shared_ptr<DbAccessor> TextDb::QueryMetadata() {
   if (!loaded())
-    return nullptr;
-  return New<TextDbAccessor>(metadata_, "");
+    return shared_ptr<DbAccessor>();
+  return boost::make_shared<TextDbAccessor>(metadata_, "");
 }
 
 shared_ptr<DbAccessor> TextDb::QueryAll() {
   return Query("");
 }
 
-shared_ptr<DbAccessor> TextDb::Query(const std::string& key) {
+shared_ptr<DbAccessor> TextDb::Query(const std::string &key) {
   if (!loaded())
-    return nullptr;
-  return New<TextDbAccessor>(data_, key);
+    return shared_ptr<DbAccessor>();
+  return boost::make_shared<TextDbAccessor>(data_, key);
 }
 
-bool TextDb::Fetch(const std::string& key, std::string* value) {
+bool TextDb::Fetch(const std::string &key, std::string *value) {
   if (!value || !loaded())
     return false;
   TextDbData::const_iterator it = data_.find(key);
@@ -82,18 +85,16 @@ bool TextDb::Fetch(const std::string& key, std::string* value) {
   return true;
 }
 
-bool TextDb::Update(const std::string& key, const std::string& value) {
-  if (!loaded() || readonly())
-    return false;
+bool TextDb::Update(const std::string &key, const std::string &value) {
+  if (!loaded() || readonly()) return false;
   DLOG(INFO) << "update db entry: " << key << " => " << value;
   data_[key] = value;
   modified_ = true;
   return true;
 }
 
-bool TextDb::Erase(const std::string& key) {
-  if (!loaded() || readonly())
-    return false;
+bool TextDb::Erase(const std::string &key) {
+  if (!loaded() || readonly()) return false;
   DLOG(INFO) << "erase db entry: " << key;
   if (data_.erase(key) == 0)
     return false;
@@ -102,8 +103,7 @@ bool TextDb::Erase(const std::string& key) {
 }
 
 bool TextDb::Open() {
-  if (loaded())
-    return false;
+  if (loaded()) return false;
   loaded_ = true;
   readonly_ = false;
   loaded_ = !Exists() || LoadFromFile(file_name());
@@ -124,8 +124,7 @@ bool TextDb::Open() {
 }
 
 bool TextDb::OpenReadOnly() {
-  if (loaded())
-    return false;
+  if (loaded()) return false;
   loaded_ = true;
   readonly_ = false;
   loaded_ = Exists() && LoadFromFile(file_name());
@@ -157,8 +156,7 @@ void TextDb::Clear() {
 }
 
 bool TextDb::Backup(const std::string& snapshot_file) {
-  if (!loaded())
-    return false;
+  if (!loaded()) return false;
   LOG(INFO) << "backing up db '" << name() << "' to " << snapshot_file;
   if (!SaveToFile(snapshot_file)) {
     LOG(ERROR) << "failed to create snapshot file '" << snapshot_file
@@ -169,8 +167,7 @@ bool TextDb::Backup(const std::string& snapshot_file) {
 }
 
 bool TextDb::Restore(const std::string& snapshot_file) {
-  if (!loaded() || readonly())
-    return false;
+  if (!loaded() || readonly()) return false;
   if (!LoadFromFile(snapshot_file)) {
     LOG(ERROR) << "failed to restore db '" << name()
                << "' from '" << snapshot_file << "'.";
@@ -185,7 +182,7 @@ bool TextDb::CreateMetadata() {
       MetaUpdate("/db_type", db_type_);
 }
 
-bool TextDb::MetaFetch(const std::string& key, std::string* value) {
+bool TextDb::MetaFetch(const std::string &key, std::string *value) {
   if (!value || !loaded())
     return false;
   TextDbData::const_iterator it = metadata_.find(key);
@@ -195,9 +192,8 @@ bool TextDb::MetaFetch(const std::string& key, std::string* value) {
   return true;
 }
 
-bool TextDb::MetaUpdate(const std::string& key, const std::string& value) {
-  if (!loaded() || readonly())
-    return false;
+bool TextDb::MetaUpdate(const std::string &key, const std::string &value) {
+  if (!loaded() || readonly()) return false;
   DLOG(INFO) << "update db metadata: " << key << " => " << value;
   metadata_[key] = value;
   modified_ = true;
diff --git a/src/dict/tree_db.cc b/src/dict/tree_db.cc
index 4b6ed2e..04d00f0 100644
--- a/src/dict/tree_db.cc
+++ b/src/dict/tree_db.cc
@@ -5,16 +5,6 @@
 // 2011-11-02 GONG Chen <chen.sst@gmail.com>
 //
 #include <boost/filesystem.hpp>
-#if defined(_MSC_VER)
-#pragma warning(disable: 4244)
-#pragma warning(disable: 4351)
-#endif
-#include <kchashdb.h>
-#if defined(_MSC_VER)
-#pragma warning(default: 4351)
-#pragma warning(default: 4244)
-#endif
-
 #include <rime/common.h>
 #include <rime/service.h>
 #include <rime/dict/tree_db.h>
@@ -23,40 +13,12 @@ namespace rime {
 
 static const char* kMetaCharacter = "\x01";
 
-struct TreeDbCursor {
-  TreeDbCursor(kyotocabinet::DB::Cursor* cursor)
-      : kcursor(cursor) {
-  }
-
-  unique_ptr<kyotocabinet::DB::Cursor> kcursor;
-};
-
-struct TreeDbWrapper {
-  TreeDbWrapper();
-
-  TreeDbCursor* GetCursor() {
-    if (auto cursor = kcdb.cursor())
-      return new TreeDbCursor(cursor);
-    else
-      return nullptr;
-  }
-
-  kyotocabinet::TreeDB kcdb;
-};
-
-TreeDbWrapper::TreeDbWrapper() {
-  kcdb.tune_options(kyotocabinet::TreeDB::TSMALL |
-                    kyotocabinet::TreeDB::TLINEAR);
-  kcdb.tune_map(4LL << 20);
-  kcdb.tune_defrag(8);
-}
-
 // TreeDbAccessor memebers
 
 TreeDbAccessor::TreeDbAccessor() {
 }
 
-TreeDbAccessor::TreeDbAccessor(TreeDbCursor* cursor,
+TreeDbAccessor::TreeDbAccessor(kyotocabinet::DB::Cursor* cursor,
                                const std::string& prefix)
     : DbAccessor(prefix), cursor_(cursor) {
   Reset();
@@ -67,17 +29,17 @@ TreeDbAccessor::~TreeDbAccessor() {
 }
 
 bool TreeDbAccessor::Reset() {
-  return cursor_ && cursor_->kcursor->jump(prefix_);
+  return cursor_ && cursor_->jump(prefix_);
 }
 
-bool TreeDbAccessor::Jump(const std::string& key) {
-  return cursor_ && cursor_->kcursor->jump(key);
+bool TreeDbAccessor::Jump(const std::string &key) {
+  return cursor_ && cursor_->jump(key);
 }
 
-bool TreeDbAccessor::GetNextRecord(std::string* key, std::string* value) {
+bool TreeDbAccessor::GetNextRecord(std::string *key, std::string *value) {
   if (!cursor_ || !key || !value)
     return false;
-  bool got = cursor_->kcursor->get(key, value, true) && MatchesPrefix(*key);
+  bool got = cursor_->get(key, value, true) && MatchesPrefix(*key);
   if (got && prefix_ == kMetaCharacter) {
     key->erase(0, 1);  // remove meta character
   }
@@ -86,7 +48,7 @@ bool TreeDbAccessor::GetNextRecord(std::string* key, std::string* value) {
 
 bool TreeDbAccessor::exhausted() {
   std::string key;
-  return !cursor_->kcursor->get_key(&key, false) || !MatchesPrefix(key);
+  return !cursor_->get_key(&key, false) || !MatchesPrefix(key);
 }
 
 // TreeDb members
@@ -101,7 +63,11 @@ TreeDb::~TreeDb() {
 }
 
 void TreeDb::Initialize() {
-  db_.reset(new TreeDbWrapper);
+  db_.reset(new kyotocabinet::TreeDB);
+  db_->tune_options(kyotocabinet::TreeDB::TSMALL |
+                    kyotocabinet::TreeDB::TLINEAR);
+  db_->tune_map(4LL << 20);
+  db_->tune_defrag(8);
 }
 
 shared_ptr<DbAccessor> TreeDb::QueryMetadata() {
@@ -115,37 +81,34 @@ shared_ptr<DbAccessor> TreeDb::QueryAll() {
   return all;
 }
 
-shared_ptr<DbAccessor> TreeDb::Query(const std::string& key) {
+shared_ptr<DbAccessor> TreeDb::Query(const std::string &key) {
   if (!loaded())
-    return nullptr;
-  return New<TreeDbAccessor>(db_->GetCursor(), key);
+    return shared_ptr<DbAccessor>();
+  return boost::make_shared<TreeDbAccessor>(db_->cursor(), key);
 }
 
-bool TreeDb::Fetch(const std::string& key, std::string* value) {
+bool TreeDb::Fetch(const std::string &key, std::string *value) {
   if (!value || !loaded())
     return false;
-  return db_->kcdb.get(key, value);
+  return db_->get(key, value);
 }
 
-bool TreeDb::Update(const std::string& key, const std::string& value) {
-  if (!loaded() || readonly())
-    return false;
+bool TreeDb::Update(const std::string &key, const std::string &value) {
+  if (!loaded() || readonly()) return false;
   DLOG(INFO) << "update db entry: " << key << " => " << value;
-  return db_->kcdb.set(key, value);
+  return db_->set(key, value);
 }
 
-bool TreeDb::Erase(const std::string& key) {
-  if (!loaded() || readonly())
-    return false;
+bool TreeDb::Erase(const std::string &key) {
+  if (!loaded() || readonly()) return false;
   DLOG(INFO) << "erase db entry: " << key;
-  return db_->kcdb.remove(key);
+  return db_->remove(key);
 }
 
 bool TreeDb::Backup(const std::string& snapshot_file) {
-  if (!loaded())
-    return false;
+  if (!loaded()) return false;
   LOG(INFO) << "backing up db '" << name() << "' to " << snapshot_file;
-  bool success = db_->kcdb.dump_snapshot(snapshot_file);
+  bool success = db_->dump_snapshot(snapshot_file);
   if (!success) {
     LOG(ERROR) << "failed to create snapshot file '" << snapshot_file
                << "' for db '" << name() << "'.";
@@ -154,9 +117,8 @@ bool TreeDb::Backup(const std::string& snapshot_file) {
 }
 
 bool TreeDb::Restore(const std::string& snapshot_file) {
-  if (!loaded() || readonly())
-    return false;
-  bool success = db_->kcdb.load_snapshot(snapshot_file);
+  if (!loaded() || readonly()) return false;
+  bool success = db_->load_snapshot(snapshot_file);
   if (!success) {
     LOG(ERROR) << "failed to restore db '" << name()
                << "' from '" << snapshot_file << "'.";
@@ -179,15 +141,14 @@ bool TreeDb::Recover() {
 }
 
 bool TreeDb::Open() {
-  if (loaded())
-    return false;
+  if (loaded()) return false;
   Initialize();
   readonly_ = false;
-  loaded_ = db_->kcdb.open(file_name(),
-                           kyotocabinet::TreeDB::OWRITER |
-                           kyotocabinet::TreeDB::OCREATE |
-                           kyotocabinet::TreeDB::OTRYLOCK |
-                           kyotocabinet::TreeDB::ONOREPAIR);
+  loaded_ = db_->open(file_name(),
+                      kyotocabinet::TreeDB::OWRITER |
+                      kyotocabinet::TreeDB::OCREATE |
+                      kyotocabinet::TreeDB::OTRYLOCK |
+                      kyotocabinet::TreeDB::ONOREPAIR);
   if (loaded_) {
     std::string db_name;
     if (!MetaFetch("/db_name", &db_name)) {
@@ -204,13 +165,12 @@ bool TreeDb::Open() {
 }
 
 bool TreeDb::OpenReadOnly() {
-  if (loaded())
-    return false;
+  if (loaded()) return false;
   Initialize();
   readonly_ = true;
-  loaded_ = db_->kcdb.open(file_name(),
-                           kyotocabinet::TreeDB::OREADER |
-                           kyotocabinet::TreeDB::OTRYLOCK);
+  loaded_ = db_->open(file_name(),
+                      kyotocabinet::TreeDB::OREADER |
+                      kyotocabinet::TreeDB::OTRYLOCK);
   if (!loaded_) {
     LOG(ERROR) << "Error opening db '" << name_ << "' read-only.";
   }
@@ -218,9 +178,8 @@ bool TreeDb::OpenReadOnly() {
 }
 
 bool TreeDb::Close() {
-  if (!loaded())
-    return false;
-  db_->kcdb.close();
+  if (!loaded()) return false;
+  db_->close();
   LOG(INFO) << "closed db '" << name_ << "'.";
   loaded_ = false;
   readonly_ = false;
@@ -233,32 +192,29 @@ bool TreeDb::CreateMetadata() {
       MetaUpdate("/db_type", db_type_);
 }
 
-bool TreeDb::MetaFetch(const std::string& key, std::string* value) {
+bool TreeDb::MetaFetch(const std::string &key, std::string *value) {
   return Fetch(kMetaCharacter + key, value);
 }
 
-bool TreeDb::MetaUpdate(const std::string& key, const std::string& value) {
+bool TreeDb::MetaUpdate(const std::string &key, const std::string &value) {
   return Update(kMetaCharacter + key, value);
 }
 
 bool TreeDb::BeginTransaction() {
-  if (!loaded())
-    return false;
-  in_transaction_ = db_->kcdb.begin_transaction();
+  if (!loaded()) return false;
+  in_transaction_ = db_->begin_transaction();
   return in_transaction_;
 }
 
 bool TreeDb::AbortTransaction() {
-  if (!loaded() || !in_transaction())
-    return false;
-  in_transaction_ = !db_->kcdb.end_transaction(false);
+  if (!loaded() || !in_transaction()) return false;
+  in_transaction_ = !db_->end_transaction(false);
   return !in_transaction_;
 }
 
 bool TreeDb::CommitTransaction() {
-  if (!loaded() || !in_transaction())
-    return false;
-  in_transaction_ = !db_->kcdb.end_transaction(true);
+  if (!loaded() || !in_transaction()) return false;
+  in_transaction_ = !db_->end_transaction(true);
   return !in_transaction_;
 }
 
diff --git a/src/dict/tsv.cc b/src/dict/tsv.cc
index 88d6d06..68cfd85 100644
--- a/src/dict/tsv.cc
+++ b/src/dict/tsv.cc
@@ -73,8 +73,8 @@ int TsvWriter::operator() (Source* source) {
   while (source->Get(&key, &value)) {
     row.clear();
     if (formatter_(key, value, &row) && !row.empty()) {
-      for (auto it = row.cbegin(); it != row.cend(); ++it) {
-        if (it != row.cbegin())
+      for (Tsv::const_iterator it = row.begin(); it != row.end(); ++it) {
+        if (it != row.begin())
           fout << '\t';
         fout << *it;
       }
diff --git a/src/dict/user_db.cc b/src/dict/user_db.cc
index ebc2786..fffccb0 100644
--- a/src/dict/user_db.cc
+++ b/src/dict/user_db.cc
@@ -7,6 +7,7 @@
 #include <cstdlib>
 #include <vector>
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <boost/format.hpp>
 #include <boost/lexical_cast.hpp>
 #include <rime/service.h>
@@ -17,7 +18,12 @@
 
 namespace rime {
 
-UserDbValue::UserDbValue(const std::string& value) {
+UserDbValue::UserDbValue()
+    : commits(0), dee(0.0), tick(0) {
+}
+
+UserDbValue::UserDbValue(const std::string& value)
+    : commits(0), dee(0.0), tick(0) {
   Unpack(value);
 }
 
@@ -26,10 +32,10 @@ std::string UserDbValue::Pack() const {
                     commits % dee % tick);
 }
 
-bool UserDbValue::Unpack(const std::string& value) {
+bool UserDbValue::Unpack(const std::string &value) {
   std::vector<std::string> kv;
   boost::split(kv, value, boost::is_any_of(" "));
-  for (const std::string& k_eq_v : kv) {
+  BOOST_FOREACH(const std::string &k_eq_v, kv) {
     size_t eq = k_eq_v.find('=');
     if (eq == std::string::npos)
       continue;
diff --git a/src/dict/user_dictionary.cc b/src/dict/user_dictionary.cc
index 6500a5e..f866e7c 100644
--- a/src/dict/user_dictionary.cc
+++ b/src/dict/user_dictionary.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <map>
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <boost/lexical_cast.hpp>
 #include <boost/scope_exit.hpp>
 #include <rime/common.h>
@@ -31,10 +32,10 @@ struct DfsState {
   std::string key;
   std::string value;
 
-  bool IsExactMatch(const std::string& prefix) {
+  bool IsExactMatch(const std::string &prefix) {
     return boost::starts_with(key, prefix + '\t');
   }
-  bool IsPrefixMatch(const std::string& prefix) {
+  bool IsPrefixMatch(const std::string &prefix) {
     return boost::starts_with(key, prefix);
   }
   void RecruitEntry(size_t pos);
@@ -46,13 +47,13 @@ struct DfsState {
     }
     return true;
   }
-  bool ForwardScan(const std::string& prefix) {
+  bool ForwardScan(const std::string &prefix) {
     if (!accessor->Jump(prefix)) {
       return false;
     }
     return NextEntry();
   }
-  bool Backdate(const std::string& prefix) {
+  bool Backdate(const std::string &prefix) {
     DLOG(INFO) << "backdate; prefix: " << prefix;
     if (!accessor->Reset()) {
       LOG(WARNING) << "backdating failed for '" << prefix << "'.";
@@ -63,8 +64,9 @@ struct DfsState {
 };
 
 void DfsState::RecruitEntry(size_t pos) {
-  auto e = UserDictionary::CreateDictEntry(key, value, present_tick,
-                                           credibility.back());
+  shared_ptr<DictEntry> e =
+      UserDictionary::CreateDictEntry(key, value, present_tick,
+                                      credibility.back());
   if (e) {
     e->code = code;
     DLOG(INFO) << "add entry at pos " << pos;
@@ -76,7 +78,7 @@ void DfsState::RecruitEntry(size_t pos) {
 
 void UserDictEntryIterator::Add(const shared_ptr<DictEntry>& entry) {
   if (!entries_) {
-    entries_ = New<DictEntryList>();
+    entries_ = make_shared<DictEntryList>();
   }
   entries_->push_back(entry);
 }
@@ -96,6 +98,7 @@ bool UserDictEntryIterator::Release(DictEntryList* receiver) {
   return true;
 }
 
+
 shared_ptr<DictEntry> UserDictEntryIterator::Peek() {
   shared_ptr<DictEntry> result;
   while (!result && !exhausted()) {
@@ -117,8 +120,8 @@ bool UserDictEntryIterator::Next() {
 
 // UserDictionary members
 
-UserDictionary::UserDictionary(const shared_ptr<Db>& db)
-    : db_(db) {
+UserDictionary::UserDictionary(const shared_ptr<Db> &db)
+    : db_(db), tick_(0), transaction_time_(0) {
 }
 
 UserDictionary::~UserDictionary() {
@@ -127,8 +130,8 @@ UserDictionary::~UserDictionary() {
   }
 }
 
-void UserDictionary::Attach(const shared_ptr<Table>& table,
-                            const shared_ptr<Prism>& prism) {
+void UserDictionary::Attach(const shared_ptr<Table> &table,
+                            const shared_ptr<Prism> &prism) {
   table_ = table;
   prism_ = prism;
 }
@@ -138,8 +141,9 @@ bool UserDictionary::Load() {
     return false;
   if (!db_->loaded() && !db_->Open()) {
     // try to recover managed db in available work thread
+    DeploymentTask::Component* task =
+        DeploymentTask::Require("userdb_recovery_task");
     Deployer& deployer(Service::instance().deployer());
-    auto task = DeploymentTask::Require("userdb_recovery_task");
     if (task && Is<Recoverable>(db_) && !deployer.IsWorking()) {
       deployer.ScheduleTask(shared_ptr<DeploymentTask>(task->Create(db_)));
       deployer.StartWork();
@@ -182,37 +186,34 @@ bool UserDictionary::readonly() const {
 // note that backdating works only for normal or fuzzy spellings, but not for
 // abbreviations such as 'shsh' in the previous example.
 
-void UserDictionary::DfsLookup(const SyllableGraph& syll_graph,
+void UserDictionary::DfsLookup(const SyllableGraph &syll_graph,
                                size_t current_pos,
-                               const std::string& current_prefix,
-                               DfsState* state) {
-  auto index = syll_graph.indices.find(current_pos);
+                               const std::string &current_prefix,
+                               DfsState *state) {
+  SpellingIndices::const_iterator index = syll_graph.indices.find(current_pos);
   if (index == syll_graph.indices.end()) {
     return;
   }
   DLOG(INFO) << "dfs lookup starts from " << current_pos;
   std::string prefix;
-  for (const auto& spelling : index->second) {
+  BOOST_FOREACH(const SpellingIndex::value_type& spelling, index->second) {
     DLOG(INFO) << "prefix: '" << current_prefix << "'"
                << ", syll_id: " << spelling.first
                << ", num_spellings: " << spelling.second.size();
     state->code.push_back(spelling.first);
     BOOST_SCOPE_EXIT( (&state) ) {
       state->code.pop_back();
-    }
-    BOOST_SCOPE_EXIT_END
+    } BOOST_SCOPE_EXIT_END
     if (!TranslateCodeToString(state->code, &prefix))
       continue;
     for (size_t i = 0; i < spelling.second.size(); ++i) {
-      auto props = spelling.second[i];
-      if (i > 0 && props->type >= kAbbreviation)
-        continue;
+      const SpellingProperties* props = spelling.second[i];
+      if (i > 0 && props->type >= kAbbreviation) continue;
       state->credibility.push_back(
           state->credibility.back() * props->credibility);
       BOOST_SCOPE_EXIT( (&state) ) {
         state->credibility.pop_back();
-      }
-      BOOST_SCOPE_EXIT_END
+      } BOOST_SCOPE_EXIT_END
       size_t end_pos = props->end_pos;
       DLOG(INFO) << "edge: [" << current_pos << ", " << end_pos << ")";
       if (prefix != state->key) {  // 'a b c |d ' > 'a b c \tabracadabra'
@@ -227,8 +228,8 @@ void UserDictionary::DfsLookup(const SyllableGraph& syll_graph,
           break;
       }
       // the caller can limit the number of syllables to look up
-      if ((!state->depth_limit || state->code.size() < state->depth_limit) &&
-          state->IsPrefixMatch(prefix)) {  // 'b |e ' vs. 'b e f \tBefore'
+      if ((!state->depth_limit || state->code.size() < state->depth_limit)
+          && state->IsPrefixMatch(prefix)) {  // 'b |e ' vs. 'b e f \tBefore'
         DfsLookup(syll_graph, end_pos, prefix, state);
       }
     }
@@ -239,27 +240,27 @@ void UserDictionary::DfsLookup(const SyllableGraph& syll_graph,
 }
 
 shared_ptr<UserDictEntryCollector>
-UserDictionary::Lookup(const SyllableGraph& syll_graph,
+UserDictionary::Lookup(const SyllableGraph &syll_graph,
                        size_t start_pos,
                        size_t depth_limit,
                        double initial_credibility) {
   if (!table_ || !prism_ || !loaded() ||
       start_pos >= syll_graph.interpreted_length)
-    return nullptr;
+    return shared_ptr<UserDictEntryCollector>();
   DfsState state;
   state.depth_limit = depth_limit;
   FetchTickCount();
   state.present_tick = tick_ + 1;
   state.credibility.push_back(initial_credibility);
-  state.collector = New<UserDictEntryCollector>();
+  state.collector = make_shared<UserDictEntryCollector>();
   state.accessor = db_->Query("");
   state.accessor->Jump(" ");  // skip metadata
   std::string prefix;
   DfsLookup(syll_graph, start_pos, prefix, &state);
   if (state.collector->empty())
-    return nullptr;
+    return shared_ptr<UserDictEntryCollector>();
   // sort each group of homophones by weight
-  for (auto& v : *state.collector) {
+  BOOST_FOREACH(UserDictEntryCollector::value_type &v, *state.collector) {
     v.second.Sort();
   }
   return state.collector;
@@ -279,22 +280,22 @@ size_t UserDictionary::LookupWords(UserDictEntryIterator* result,
   std::string key;
   std::string value;
   std::string full_code;
-  auto accessor = db_->Query(input);
-  if (!accessor || accessor->exhausted()) {
+  shared_ptr<DbAccessor> a = db_->Query(input);
+  if (!a || a->exhausted()) {
     if (resume_key)
       *resume_key = kEnd;
     return 0;
   }
   if (resume_key && !resume_key->empty()) {
-    if (!accessor->Jump(*resume_key) ||
-        !accessor->GetNextRecord(&key, &value)) {
+    if (!a->Jump(*resume_key) ||
+        !a->GetNextRecord(&key, &value)) {
       *resume_key = kEnd;
       return 0;
     }
     DLOG(INFO) << "resume lookup after: " << key;
   }
   std::string last_key(key);
-  while (accessor->GetNextRecord(&key, &value)) {
+  while (a->GetNextRecord(&key, &value)) {
     DLOG(INFO) << "key : " << key << ", value: " << value;
     bool is_exact_match = (len < key.length() && key[len] == ' ');
     if (!is_exact_match && !predictive) {
@@ -302,7 +303,8 @@ size_t UserDictionary::LookupWords(UserDictEntryIterator* result,
       break;
     }
     last_key = key;
-    auto e = CreateDictEntry(key, value, present_tick, 1.0, &full_code);
+    shared_ptr<DictEntry> e =
+        CreateDictEntry(key, value, present_tick, 1.0, &full_code);
     if (!e)
       continue;
     e->custom_code = full_code;
@@ -399,7 +401,7 @@ bool UserDictionary::FetchTickCount() {
 }
 
 bool UserDictionary::NewTransaction() {
-  auto db = As<Transactional>(db_);
+  shared_ptr<Transactional> db = As<Transactional>(db_);
   if (!db)
     return false;
   CommitPendingTransaction();
@@ -408,7 +410,7 @@ bool UserDictionary::NewTransaction() {
 }
 
 bool UserDictionary::RevertRecentTransaction() {
-  auto db = As<Transactional>(db_);
+  shared_ptr<Transactional> db = As<Transactional>(db_);
   if (!db || !db->in_transaction())
     return false;
   if (time(NULL) - transaction_time_ > 3/*seconds*/)
@@ -417,18 +419,18 @@ bool UserDictionary::RevertRecentTransaction() {
 }
 
 bool UserDictionary::CommitPendingTransaction() {
-  auto db = As<Transactional>(db_);
+  shared_ptr<Transactional> db = As<Transactional>(db_);
   if (db && db->in_transaction()) {
     return db->CommitTransaction();
   }
   return false;
 }
 
-bool UserDictionary::TranslateCodeToString(const Code& code,
+bool UserDictionary::TranslateCodeToString(const Code &code,
                                            std::string* result) {
   if (!table_ || !result) return false;
   result->clear();
-  for (const SyllableId& syllable_id : code) {
+  BOOST_FOREACH(const SyllableId& syllable_id, code) {
     std::string spelling = table_->GetSyllableById(syllable_id);
     if (spelling.empty()) {
       LOG(ERROR) << "Error translating syllable_id '" << syllable_id << "'.";
@@ -458,7 +460,7 @@ shared_ptr<DictEntry> UserDictionary::CreateDictEntry(const std::string& key,
   if (v.tick < present_tick)
     v.dee = algo::formula_d(0, (double)present_tick, v.dee, (double)v.tick);
   // create!
-  e = New<DictEntry>();
+  e = make_shared<DictEntry>();
   e->text = key.substr(separator_pos + 1);
   e->commit_count = v.commits;
   // TODO: argument s not defined...
@@ -483,9 +485,8 @@ UserDictionaryComponent::UserDictionaryComponent() {
 }
 
 UserDictionary* UserDictionaryComponent::Create(const Ticket& ticket) {
-  if (!ticket.schema)
-    return NULL;
-  Config* config = ticket.schema->config();
+  if (!ticket.schema) return NULL;
+  Config *config = ticket.schema->config();
   bool enable_user_dict = true;
   config->GetBool(ticket.name_space + "/enable_user_dict", &enable_user_dict);
   if (!enable_user_dict)
@@ -510,14 +511,14 @@ UserDictionary* UserDictionaryComponent::Create(const Ticket& ticket) {
     // user specified db class
   }
   // obtain userdb object
-  auto db = db_pool_[dict_name].lock();
+  shared_ptr<Db> db(db_pool_[dict_name].lock());
   if (!db) {
-    auto component = Db::Require(db_class);
-    if (!component) {
+    Db::Component* c = Db::Require(db_class);
+    if (!c) {
       LOG(ERROR) << "undefined db class '" << db_class << "'.";
       return NULL;
     }
-    db.reset(component->Create(dict_name));
+    db.reset(c->Create(dict_name));
     db_pool_[dict_name] = db;
   }
   return new UserDictionary(db);
diff --git a/src/dict/vocabulary.cc b/src/dict/vocabulary.cc
index 94f930c..02ba0e8 100644
--- a/src/dict/vocabulary.cc
+++ b/src/dict/vocabulary.cc
@@ -5,13 +5,14 @@
 // 2011-07-24 GONG Chen <chen.sst@gmail.com>
 //
 #include <algorithm>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <sstream>
-#include <utility>
 #include <rime/dict/vocabulary.h>
 
 namespace rime {
 
-bool Code::operator< (const Code& other) const {
+bool Code::operator< (const Code &other) const {
   if (size() != other.size())
     return size() < other.size();
   for (size_t i = 0; i < size(); ++i) {
@@ -21,7 +22,7 @@ bool Code::operator< (const Code& other) const {
   return false;
 }
 
-bool Code::operator== (const Code& other) const {
+bool Code::operator== (const Code &other) const {
   if (size() != other.size())
     return false;
   for (size_t i = 0; i < size(); ++i) {
@@ -31,7 +32,7 @@ bool Code::operator== (const Code& other) const {
   return true;
 }
 
-void Code::CreateIndex(Code* index_code) {
+void Code::CreateIndex(Code *index_code) {
   if (!index_code)
     return;
   size_t index_code_size = Code::kIndexCodeMaxLength;
@@ -47,7 +48,7 @@ void Code::CreateIndex(Code* index_code) {
 std::string Code::ToString() const {
   std::stringstream stream;
   bool first = true;
-  for (SyllableId syllable_id : *this) {
+  BOOST_FOREACH(SyllableId syllable_id, *this) {
     if (first) {
       first = false;
     }
@@ -68,7 +69,7 @@ bool DictEntry::operator< (const DictEntry& other) const {
 }
 
 template <class T>
-inline bool dereference_less(const T& a, const T& b) {
+inline bool dereference_less(const T &a, const T &b) {
   return *a < *b;
 }
 
@@ -89,27 +90,24 @@ void DictEntryFilterBinder::AddFilter(DictEntryFilter filter) {
     filter_.swap(filter);
   }
   else {
-    DictEntryFilter previous_filter(std::move(filter_));
-    filter_ = [previous_filter, filter](shared_ptr<DictEntry> e) {
-      return previous_filter(e) && filter(e);
-    };
+    filter_ = boost::bind(filter_, _1) && boost::bind(filter, _1);
   }
 }
 
-DictEntryList* Vocabulary::LocateEntries(const Code& code) {
-  Vocabulary* v = this;
+DictEntryList* Vocabulary::LocateEntries(const Code &code) {
+  Vocabulary *v = this;
   size_t n = code.size();
   for (size_t i = 0; i < n; ++i) {
     int key = -1;
     if (i < Code::kIndexCodeMaxLength)
       key = code[i];
-    auto& page((*v)[key]);
+    VocabularyPage &page((*v)[key]);
     if (i == n - 1 || i == Code::kIndexCodeMaxLength) {
       return &page.entries;
     }
     else {
       if (!page.next_level) {
-        page.next_level = New<Vocabulary>();
+        page.next_level = make_shared<Vocabulary>();
       }
       v = page.next_level.get();
     }
@@ -118,8 +116,8 @@ DictEntryList* Vocabulary::LocateEntries(const Code& code) {
 }
 
 void Vocabulary::SortHomophones() {
-  for (auto& v : *this) {
-    auto& page(v.second);
+  BOOST_FOREACH(Vocabulary::value_type &v, *this) {
+    VocabularyPage &page(v.second);
     page.entries.Sort();
     if (page.next_level)
       page.next_level->SortHomophones();
diff --git a/src/engine.cc b/src/engine.cc
index c1494b8..4eb1de4 100644
--- a/src/engine.cc
+++ b/src/engine.cc
@@ -5,9 +5,10 @@
 // 2011-04-24 GONG Chen <chen.sst@gmail.com>
 //
 #include <cctype>
-#include <functional>
 #include <string>
 #include <vector>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/context.h>
@@ -25,8 +26,6 @@
 #include <rime/translation.h>
 #include <rime/translator.h>
 
-using namespace std::placeholders;
-
 namespace rime {
 
 class ConcreteEngine : public Engine {
@@ -40,24 +39,24 @@ class ConcreteEngine : public Engine {
  protected:
   void InitializeComponents();
   void InitializeOptions();
-  void Compose(Context* ctx);
-  void CalculateSegmentation(Composition* comp);
-  void TranslateSegments(Composition* comp);
+  void Compose(Context *ctx);
+  void CalculateSegmentation(Composition *comp);
+  void TranslateSegments(Composition *comp);
   void FilterCandidates(Segment* segment,
-                        CandidateList* recruited,
-                        CandidateList* candidates);
+                        CandidateList *recruited,
+                        CandidateList *candidates);
   void FormatText(std::string* text);
-  void OnCommit(Context* ctx);
-  void OnSelect(Context* ctx);
-  void OnContextUpdate(Context* ctx);
-  void OnOptionUpdate(Context* ctx, const std::string& option);
+  void OnCommit(Context *ctx);
+  void OnSelect(Context *ctx);
+  void OnContextUpdate(Context *ctx);
+  void OnOptionUpdate(Context *ctx, const std::string &option);
 
-  std::vector<shared_ptr<Processor>> processors_;
-  std::vector<shared_ptr<Segmentor>> segmentors_;
-  std::vector<shared_ptr<Translator>> translators_;
-  std::vector<shared_ptr<Filter>> filters_;
-  std::vector<shared_ptr<Formatter>> formatters_;
-  std::vector<shared_ptr<Processor>> post_processors_;
+  std::vector<shared_ptr<Processor> > processors_;
+  std::vector<shared_ptr<Segmentor> > segmentors_;
+  std::vector<shared_ptr<Translator> > translators_;
+  std::vector<shared_ptr<Filter> > filters_;
+  std::vector<shared_ptr<Formatter> > formatters_;
+  std::vector<shared_ptr<Processor> > post_processors_;
 };
 
 // implementations
@@ -66,7 +65,9 @@ Engine* Engine::Create() {
   return new ConcreteEngine;
 }
 
-Engine::Engine() : schema_(new Schema), context_(new Context) {
+Engine::Engine()
+    : schema_(new Schema), context_(new Context),
+      active_context_(NULL) {
 }
 
 Engine::~Engine() {
@@ -78,15 +79,13 @@ ConcreteEngine::ConcreteEngine() {
   LOG(INFO) << "starting engine.";
   // receive context notifications
   context_->commit_notifier().connect(
-      [this](Context* ctx) { OnCommit(ctx); });
+      boost::bind(&ConcreteEngine::OnCommit, this, _1));
   context_->select_notifier().connect(
-      [this](Context* ctx) { OnSelect(ctx); });
+      boost::bind(&ConcreteEngine::OnSelect, this, _1));
   context_->update_notifier().connect(
-      [this](Context* ctx) { OnContextUpdate(ctx); });
+      boost::bind(&ConcreteEngine::OnContextUpdate, this, _1));
   context_->option_update_notifier().connect(
-      [this](Context* ctx, const std::string& option) {
-        OnOptionUpdate(ctx, option);
-      });
+      boost::bind(&ConcreteEngine::OnOptionUpdate, this, _1, _2));
   InitializeComponents();
   InitializeOptions();
 }
@@ -101,16 +100,16 @@ ConcreteEngine::~ConcreteEngine() {
 bool ConcreteEngine::ProcessKey(const KeyEvent& key_event) {
   DLOG(INFO) << "process key: " << key_event;
   ProcessResult ret = kNoop;
-  for (auto& processor : processors_) {
-    ret = processor->ProcessKeyEvent(key_event);
+  BOOST_FOREACH(shared_ptr<Processor>& p, processors_) {
+    ret = p->ProcessKeyEvent(key_event);
     if (ret == kRejected) break;
     if (ret == kAccepted) return true;
   }
   // record unhandled keys, eg. spaces, numbers, bksp's.
   context_->commit_history().Push(key_event);
   // post-processing
-  for (auto& processor : post_processors_) {
-    ret = processor->ProcessKeyEvent(key_event);
+  BOOST_FOREACH(shared_ptr<Processor>& p, post_processors_) {
+    ret = p->ProcessKeyEvent(key_event);
     if (ret == kRejected) break;
     if (ret == kAccepted) return true;
   }
@@ -119,12 +118,12 @@ bool ConcreteEngine::ProcessKey(const KeyEvent& key_event) {
   return false;
 }
 
-void ConcreteEngine::OnContextUpdate(Context* ctx) {
+void ConcreteEngine::OnContextUpdate(Context *ctx) {
   if (!ctx) return;
   Compose(ctx);
 }
 
-void ConcreteEngine::OnOptionUpdate(Context* ctx, const std::string& option) {
+void ConcreteEngine::OnOptionUpdate(Context *ctx, const std::string &option) {
   if (!ctx) return;
   LOG(INFO) << "updated option: " << option;
   // apply new option to active segment
@@ -137,9 +136,9 @@ void ConcreteEngine::OnOptionUpdate(Context* ctx, const std::string& option) {
   message_sink_("option", msg);
 }
 
-void ConcreteEngine::Compose(Context* ctx) {
+void ConcreteEngine::Compose(Context *ctx) {
   if (!ctx) return;
-  Composition* comp = ctx->composition();
+  Composition *comp = ctx->composition();
   std::string active_input(ctx->input().substr(0, ctx->caret_pos()));
   DLOG(INFO) << "active input: " << active_input;
   comp->Reset(active_input);
@@ -149,14 +148,14 @@ void ConcreteEngine::Compose(Context* ctx) {
   ctx->set_composition(comp);
 }
 
-void ConcreteEngine::CalculateSegmentation(Composition* comp) {
+void ConcreteEngine::CalculateSegmentation(Composition *comp) {
   while (!comp->HasFinishedSegmentation()) {
     size_t start_pos = comp->GetCurrentStartPosition();
     size_t end_pos = comp->GetCurrentEndPosition();
     DLOG(INFO) << "start pos: " << start_pos;
     DLOG(INFO) << "end pos: " << end_pos;
     // recognize a segment by calling the segmentors in turn
-    for (auto& segmentor : segmentors_) {
+    BOOST_FOREACH(shared_ptr<Segmentor> &segmentor, segmentors_) {
       if (!segmentor->Proceed(comp))
         break;
     }
@@ -174,20 +173,21 @@ void ConcreteEngine::CalculateSegmentation(Composition* comp) {
     comp->Forward();
 }
 
-void ConcreteEngine::TranslateSegments(Composition* comp) {
-  for (Segment& segment : *comp) {
+void ConcreteEngine::TranslateSegments(Composition *comp) {
+  BOOST_FOREACH(Segment& segment, *comp) {
     if (segment.status >= Segment::kGuess)
       continue;
     size_t len = segment.end - segment.start;
-    if (len == 0)
-      continue;
-    std::string input = comp->input().substr(segment.start, len);
+    if (len == 0) continue;
+    std::string input(comp->input().substr(segment.start, len));
     DLOG(INFO) << "translating segment: " << input;
     Menu::CandidateFilter cand_filter(
-        std::bind(&ConcreteEngine::FilterCandidates, this, &segment, _1, _2));
-    auto menu = New<Menu>(cand_filter);
-    for (auto& translator : translators_) {
-      auto translation = translator->Query(input, segment, &segment.prompt);
+        boost::bind(&ConcreteEngine::FilterCandidates,
+                    this, &segment, _1, _2));
+    shared_ptr<Menu> menu = boost::make_shared<Menu>(cand_filter);
+    BOOST_FOREACH(shared_ptr<Translator>& translator, translators_) {
+      shared_ptr<Translation> translation =
+          translator->Query(input, segment, &segment.prompt);
       if (!translation)
         continue;
       if (translation->exhausted()) {
@@ -205,10 +205,9 @@ void ConcreteEngine::TranslateSegments(Composition* comp) {
 void ConcreteEngine::FilterCandidates(Segment* segment,
                                       CandidateList* recruited,
                                       CandidateList* candidates) {
-  if (filters_.empty())
-    return;
+  if (filters_.empty()) return;
   DLOG(INFO) << "applying filters.";
-  for (auto& filter : filters_) {
+  BOOST_FOREACH(shared_ptr<Filter> filter, filters_) {
     if (filter->AppliesToSegment(segment)) {
       filter->Apply(recruited, candidates);
     }
@@ -216,22 +215,21 @@ void ConcreteEngine::FilterCandidates(Segment* segment,
 }
 
 void ConcreteEngine::FormatText(std::string* text) {
-  if (formatters_.empty())
-    return;
+  if (formatters_.empty()) return;
   DLOG(INFO) << "applying formatters.";
-  for (auto& formatter : formatters_) {
+  BOOST_FOREACH(shared_ptr<Formatter> formatter, formatters_) {
     formatter->Format(text);
   }
 }
 
 void ConcreteEngine::CommitText(std::string text) {
-  context_->commit_history().Push(CommitRecord{"raw", text});
+  context_->commit_history().Push(CommitRecord("raw", text));
   FormatText(&text);
   DLOG(INFO) << "committing text: " << text;
   sink_(text);
 }
 
-void ConcreteEngine::OnCommit(Context* ctx) {
+void ConcreteEngine::OnCommit(Context *ctx) {
   context_->commit_history().Push(*ctx->composition(), ctx->input());
   std::string text = ctx->GetCommitText();
   FormatText(&text);
@@ -239,9 +237,9 @@ void ConcreteEngine::OnCommit(Context* ctx) {
   sink_(text);
 }
 
-void ConcreteEngine::OnSelect(Context* ctx) {
-  Segment& seg(ctx->composition()->back());
-  auto cand =seg.GetSelectedCandidate();
+void ConcreteEngine::OnSelect(Context *ctx) {
+  Segment &seg(ctx->composition()->back());
+  shared_ptr<Candidate> cand(seg.GetSelectedCandidate());
   if (cand && cand->end() < seg.end) {
     // having selected a partially matched candidate, split it into 2 segments
     seg.end = cand->end();
@@ -287,7 +285,7 @@ void ConcreteEngine::InitializeComponents() {
   translators_.clear();
   filters_.clear();
 
-  if (auto switcher = New<Switcher>(this)) {
+  if (shared_ptr<Switcher> switcher = New<Switcher>(this)) {
     processors_.push_back(switcher);
     if (schema_->schema_id() == ".default") {
       if (Schema* schema = switcher->CreateSchema()) {
@@ -300,112 +298,120 @@ void ConcreteEngine::InitializeComponents() {
   if (!config)
     return;
   // create processors
-  if (auto processor_list = config->GetList("engine/processors")) {
+  ConfigListPtr processor_list(config->GetList("engine/processors"));
+  if (processor_list) {
     size_t n = processor_list->size();
     for (size_t i = 0; i < n; ++i) {
-      auto prescription = As<ConfigValue>(processor_list->GetAt(i));
-      if (!prescription)
-        continue;
-      Ticket ticket{this, "processor", prescription->str()};
-      if (auto c = Processor::Require(ticket.klass)) {
-        shared_ptr<Processor> p(c->Create(ticket));
-        processors_.push_back(p);
+      ConfigValuePtr prescription = As<ConfigValue>(processor_list->GetAt(i));
+      if (!prescription) continue;
+      Ticket ticket(this, "processor", prescription->str());
+      Processor::Component *c = Processor::Require(ticket.klass);
+      if (!c) {
+        LOG(ERROR) << "error creating processor: '" << ticket.klass << "'";
       }
       else {
-        LOG(ERROR) << "error creating processor: '" << ticket.klass << "'";
+        shared_ptr<Processor> p(c->Create(ticket));
+        processors_.push_back(p);
       }
     }
   }
   // create segmentors
-  if (auto segmentor_list = config->GetList("engine/segmentors")) {
+  ConfigListPtr segmentor_list(config->GetList("engine/segmentors"));
+  if (segmentor_list) {
     size_t n = segmentor_list->size();
     for (size_t i = 0; i < n; ++i) {
-      auto prescription = As<ConfigValue>(segmentor_list->GetAt(i));
-      if (!prescription)
-        continue;
-      Ticket ticket{this, "segmentor", prescription->str()};
-      if (auto c = Segmentor::Require(ticket.klass)) {
-        shared_ptr<Segmentor> s(c->Create(ticket));
-        segmentors_.push_back(s);
+      ConfigValuePtr prescription = As<ConfigValue>(segmentor_list->GetAt(i));
+      if (!prescription) continue;
+      Ticket ticket(this, "segmentor", prescription->str());
+      Segmentor::Component *c = Segmentor::Require(ticket.klass);
+      if (!c) {
+        LOG(ERROR) << "error creating segmentor: '" << ticket.klass << "'";
       }
       else {
-        LOG(ERROR) << "error creating segmentor: '" << ticket.klass << "'";
+        shared_ptr<Segmentor> s(c->Create(ticket));
+        segmentors_.push_back(s);
       }
     }
   }
   // create translators
-  if (auto translator_list = config->GetList("engine/translators")) {
+  ConfigListPtr translator_list(config->GetList("engine/translators"));
+  if (translator_list) {
     size_t n = translator_list->size();
     for (size_t i = 0; i < n; ++i) {
-      auto prescription = As<ConfigValue>(translator_list->GetAt(i));
-      if (!prescription)
-        continue;
-      Ticket ticket{this, "translator", prescription->str()};
-      if (auto c = Translator::Require(ticket.klass)) {
-        shared_ptr<Translator> t(c->Create(ticket));
-        translators_.push_back(t);
+      ConfigValuePtr prescription = As<ConfigValue>(translator_list->GetAt(i));
+      if (!prescription) continue;
+      Ticket ticket(this, "translator", prescription->str());
+      Translator::Component *c = Translator::Require(ticket.klass);
+      if (!c) {
+        LOG(ERROR) << "error creating translator: '" << ticket.klass << "'";
       }
       else {
-        LOG(ERROR) << "error creating translator: '" << ticket.klass << "'";
+        shared_ptr<Translator> d(c->Create(ticket));
+        translators_.push_back(d);
       }
     }
   }
   // create filters
-  if (auto filter_list = config->GetList("engine/filters")) {
+  ConfigListPtr filter_list(config->GetList("engine/filters"));
+  if (filter_list) {
     size_t n = filter_list->size();
     for (size_t i = 0; i < n; ++i) {
-      auto prescription = As<ConfigValue>(filter_list->GetAt(i));
-      if (!prescription)
-        continue;
-      Ticket ticket{this, "filter", prescription->str()};
-      if (auto c = Filter::Require(ticket.klass)) {
-        shared_ptr<Filter> f(c->Create(ticket));
-        filters_.push_back(f);
+      ConfigValuePtr prescription = As<ConfigValue>(filter_list->GetAt(i));
+      if (!prescription) continue;
+      Ticket ticket(this, "filter", prescription->str());
+      Filter::Component *c = Filter::Require(ticket.klass);
+      if (!c) {
+        LOG(ERROR) << "error creating filter: '" << ticket.klass << "'";
       }
       else {
-        LOG(ERROR) << "error creating filter: '" << ticket.klass << "'";
+        shared_ptr<Filter> d(c->Create(ticket));
+        filters_.push_back(d);
       }
     }
   }
   // create formatters
-  if (auto c = Formatter::Require("shape_formatter")) {
-    shared_ptr<Formatter> f(c->Create(Ticket(this)));
-    formatters_.push_back(f);
-  }
-  else {
-    LOG(WARNING) << "shape_formatter not available.";
+  {
+    Formatter::Component* c = Formatter::Require("shape_formatter");
+    if (!c) {
+      LOG(WARNING) << "shape_formatter not available.";
+    }
+    else {
+      shared_ptr<Formatter> f(c->Create(Ticket(this)));
+      formatters_.push_back(f);
+    }
   }
   // create post-processors
-  if (auto c = Processor::Require("shape_processor")) {
-    shared_ptr<Processor> p(c->Create(Ticket(this)));
-    post_processors_.push_back(p);
-  }
-  else {
-    LOG(WARNING) << "shape_processor not available.";
+  {
+    Processor::Component* c = Processor::Require("shape_processor");
+    if (!c) {
+      LOG(WARNING) << "shape_processor not available.";
+    }
+    else {
+      shared_ptr<Processor> p(c->Create(Ticket(this)));
+      post_processors_.push_back(p);
+    }
   }
 }
 
 void ConcreteEngine::InitializeOptions() {
   // reset custom switches
-  Config* config = schema_->config();
-  if (auto switches = config->GetList("switches")) {
+  Config *config = schema_->config();
+  if (ConfigListPtr switches = config->GetList("switches")) {
     for (size_t i = 0; i < switches->size(); ++i) {
-      auto item = As<ConfigMap>(switches->GetAt(i));
-      if (!item)
-        continue;
-      auto reset_value = item->GetValue("reset");
-      if (!reset_value)
-        continue;
+      ConfigMapPtr item = As<ConfigMap>(switches->GetAt(i));
+      if (!item) continue;
+      ConfigValuePtr reset_value = item->GetValue("reset");
+      if (!reset_value) continue;
       int value = 0;
       reset_value->GetInt(&value);
-      if (auto option_name = item->GetValue("name")) {
+      if (ConfigValuePtr option_name = item->GetValue("name")) {
         // toggle
         context_->set_option(option_name->str(), (value != 0));
       }
-      else if (auto options = As<ConfigList>(item->Get("options"))) {
+      else if (ConfigListPtr options = As<ConfigList>(item->Get("options"))) {
         // radio
         for (size_t i = 0; i < options->size(); ++i) {
-          if (auto option_name = options->GetValueAt(i)) {
+          if (ConfigValuePtr option_name = options->GetValueAt(i)) {
             context_->set_option(option_name->str(),
                                  static_cast<int>(i) == value);
           }
diff --git a/src/gear/abc_segmentor.cc b/src/gear/abc_segmentor.cc
index bce24f2..85146b2 100644
--- a/src/gear/abc_segmentor.cc
+++ b/src/gear/abc_segmentor.cc
@@ -4,6 +4,7 @@
 //
 // 2011-05-15 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/config.h>
 #include <rime/schema.h>
@@ -16,18 +17,19 @@ namespace rime {
 
 AbcSegmentor::AbcSegmentor(const Ticket& ticket)
     : Segmentor(ticket), alphabet_(kRimeAlphabet) {
-  if (!ticket.schema)
-    return;
-  if (Config* config = ticket.schema->config()) {
+  // read schema settings
+  if (!ticket.schema) return;
+  if (Config *config = ticket.schema->config()) {
     config->GetString("speller/alphabet", &alphabet_);
     config->GetString("speller/delimiter", &delimiter_);
     config->GetString("speller/initials", &initials_);
     config->GetString("speller/finals", &finals_);
-    if (auto extra_tags = config->GetList("abc_segmentor/extra_tags")) {
+    ConfigListPtr extra_tags = config->GetList("abc_segmentor/extra_tags");
+    if (extra_tags) {
       for (size_t i = 0; i < extra_tags->size(); ++i) {
-        if (auto value = As<ConfigValue>(extra_tags->GetAt(i))) {
+        ConfigValuePtr value = As<ConfigValue>(extra_tags->GetAt(i));
+        if (value)
           extra_tags_.insert(value->str());
-        }
       }
     }
   }
@@ -36,8 +38,8 @@ AbcSegmentor::AbcSegmentor(const Ticket& ticket)
   }
 }
 
-bool AbcSegmentor::Proceed(Segmentation* segmentation) {
-  const std::string& input(segmentation->input());
+bool AbcSegmentor::Proceed(Segmentation *segmentation) {
+  const std::string &input(segmentation->input());
   DLOG(INFO) << "abc_segmentor: " << input;
   size_t j = segmentation->GetCurrentStartPosition();
   size_t k = j;
@@ -58,9 +60,11 @@ bool AbcSegmentor::Proceed(Segmentation* segmentation) {
   }
   DLOG(INFO) << "[" << j << ", " << k << ")";
   if (j < k) {
-    Segment segment(j, k);
+    Segment segment;
+    segment.start = j;
+    segment.end = k;
     segment.tags.insert("abc");
-    for (const std::string& tag : extra_tags_) {
+    BOOST_FOREACH(const std::string& tag, extra_tags_) {
       segment.tags.insert(tag);
     }
     segmentation->AddSegment(segment);
diff --git a/src/gear/affix_segmentor.cc b/src/gear/affix_segmentor.cc
index 8e4b925..c356626 100644
--- a/src/gear/affix_segmentor.cc
+++ b/src/gear/affix_segmentor.cc
@@ -5,6 +5,7 @@
 // 2013-10-30 GONG Chen <chen.sst@gmail.com>
 //
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/schema.h>
 #include <rime/segmentation.h>
@@ -14,17 +15,18 @@ namespace rime {
 
 AffixSegmentor::AffixSegmentor(const Ticket& ticket)
     : Segmentor(ticket), tag_("abc") {
-  if (!ticket.schema)
-    return;
-  if (Config* config = ticket.schema->config()) {
+  // read schema settings
+  if (!ticket.schema) return;
+  if (Config *config = ticket.schema->config()) {
     config->GetString(name_space_ + "/tag", &tag_);
     config->GetString(name_space_ + "/prefix", &prefix_);
     config->GetString(name_space_ + "/suffix", &suffix_);
     config->GetString(name_space_ + "/tips", &tips_);
     config->GetString(name_space_ + "/closing_tips", &closing_tips_);
-    if (auto extra_tags = config->GetList(name_space_ + "/extra_tags")) {
+    if (ConfigListPtr extra_tags =
+        config->GetList(name_space_ + "/extra_tags")) {
       for (size_t i = 0; i < extra_tags->size(); ++i) {
-        if (auto value = extra_tags->GetValueAt(i)) {
+        if (ConfigValuePtr value = extra_tags->GetValueAt(i)) {
           extra_tags_.insert(value->str());
         }
       }
@@ -60,7 +62,7 @@ bool AffixSegmentor::Proceed(Segmentation* segmentation) {
   DLOG(INFO) << "segmentation: " << *segmentation;
   // just prefix
   if (active_input.length() == prefix_.length()) {
-    Segment& prefix_segment(segmentation->back());
+    Segment &prefix_segment(segmentation->back());
     prefix_segment.tags.erase(tag_);
     prefix_segment.prompt = tips_;
     prefix_segment.tags.insert(tag_ + "_prefix");
@@ -81,7 +83,7 @@ bool AffixSegmentor::Proceed(Segmentation* segmentation) {
   j += prefix_.length();
   Segment code_segment(j, k);
   code_segment.tags.insert(tag_);
-  for (const std::string& tag : extra_tags_) {
+  BOOST_FOREACH(const std::string& tag, extra_tags_) {
     code_segment.tags.insert(tag);
   }
   segmentation->Forward();
diff --git a/src/gear/ascii_composer.cc b/src/gear/ascii_composer.cc
index 4673323..7f9ca96 100644
--- a/src/gear/ascii_composer.cc
+++ b/src/gear/ascii_composer.cc
@@ -4,6 +4,7 @@
 //
 // 2011-12-18 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/bind.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/config.h>
@@ -26,15 +27,14 @@ static struct AsciiModeSwitchStyleDefinition {
   { NULL, kAsciiModeSwitchNoop }
 };
 
-static void load_bindings(const ConfigMapPtr& src,
+static void load_bindings(const ConfigMapPtr &src,
                           AsciiModeSwitchKeyBindings* dest) {
-  if (!src)
-    return;
-  for (auto it = src->begin(); it != src->end(); ++it) {
-    auto value = As<ConfigValue>(it->second);
-    if (!value)
-      continue;
-    auto* p = ascii_mode_switch_styles;
+  if (!src) return;
+  for (ConfigMap::Iterator it = src->begin();
+       it != src->end(); ++it) {
+    ConfigValuePtr value(As<ConfigValue>(it->second));
+    if (!value) continue;
+    AsciiModeSwitchStyleDefinition* p = ascii_mode_switch_styles;
     while (p->repr && p->repr != value->str())
       ++p;
     if (p->style == kAsciiModeSwitchNoop)
@@ -50,7 +50,12 @@ static void load_bindings(const ConfigMapPtr& src,
 }
 
 AsciiComposer::AsciiComposer(const Ticket& ticket)
-    : Processor(ticket) {
+    : Processor(ticket),
+      caps_lock_switch_style_(kAsciiModeSwitchNoop),
+      good_old_caps_lock_(false),
+      toggle_with_caps_(false),
+      shift_key_pressed_(false),
+      ctrl_key_pressed_(false) {
   LoadConfig(ticket.schema);
 }
 
@@ -85,7 +90,8 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
   if (is_shift || is_ctrl) {
     if (key_event.release()) {
       if (shift_key_pressed_ || ctrl_key_pressed_) {
-        auto now = std::chrono::steady_clock::now();
+        boost::chrono::steady_clock::time_point now =
+            boost::chrono::steady_clock::now();
         if (now < toggle_expired_) {
           ToggleAsciiModeWithKey(ch);
         }
@@ -99,8 +105,10 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
       else
         ctrl_key_pressed_ = true;
       // will not toggle unless the toggle key is released shortly
-      const auto toggle_duration_limit = std::chrono::milliseconds(500);
-      auto now = std::chrono::steady_clock::now();
+      const boost::chrono::milliseconds toggle_duration_limit =
+          boost::chrono::milliseconds(500);
+      boost::chrono::steady_clock::time_point now =
+          boost::chrono::steady_clock::now();
       toggle_expired_= now + toggle_duration_limit;
     }
     return kNoop;
@@ -110,7 +118,7 @@ ProcessResult AsciiComposer::ProcessKeyEvent(const KeyEvent& key_event) {
   if (key_event.ctrl()) {
     return kNoop;  // possible key binding Control+x
   }
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   bool ascii_mode = ctx->get_option("ascii_mode");
   if (ascii_mode) {
     if (!ctx->IsComposing()) {
@@ -133,7 +141,7 @@ ProcessResult AsciiComposer::ProcessCapsLock(const KeyEvent& key_event) {
       // temprarily disable good-old (uppercase) Caps Lock as mode switch key
       // in case the user switched to ascii mode with other keys, eg. with Shift
       if (good_old_caps_lock_ && !toggle_with_caps_) {
-        Context* ctx = engine_->context();
+        Context *ctx = engine_->context();
         bool ascii_mode = ctx->get_option("ascii_mode");
         if (ascii_mode) {
           return kRejected;
@@ -174,16 +182,15 @@ void AsciiComposer::LoadConfig(Schema* schema) {
   bindings_.clear();
   caps_lock_switch_style_ = kAsciiModeSwitchNoop;
   good_old_caps_lock_ = false;
-  if (!schema)
-    return;
-  unique_ptr<Config> preset_config(
+  if (!schema) return;
+  scoped_ptr<Config> preset_config(
       Config::Require("config")->Create("default"));
   if (preset_config) {
     preset_config->GetBool("ascii_composer/good_old_caps_lock",
                            &good_old_caps_lock_);
   }
-  Config* config = schema->config();
-  auto bindings = config->GetMap("ascii_composer/switch_key");
+  Config *config = schema->config();
+  ConfigMapPtr  bindings = config->GetMap("ascii_composer/switch_key");
   if (!bindings) {
     if (!preset_config) {
       LOG(ERROR) << "Error importing preset ascii bindings.";
@@ -196,21 +203,21 @@ void AsciiComposer::LoadConfig(Schema* schema) {
     }
   }
   load_bindings(bindings, &bindings_);
-  auto it = bindings_.find(XK_Caps_Lock);
+  AsciiModeSwitchKeyBindings::const_iterator it = bindings_.find(XK_Caps_Lock);
   if (it != bindings_.end()) {
     caps_lock_switch_style_ = it->second;
-    if (caps_lock_switch_style_ == kAsciiModeSwitchInline) {  // can't do that
+    if (caps_lock_switch_style_ == kAsciiModeSwitchInline) {  // cannot do that
       caps_lock_switch_style_ = kAsciiModeSwitchClear;
     }
   }
 }
 
 bool AsciiComposer::ToggleAsciiModeWithKey(int key_code) {
-  auto it = bindings_.find(key_code);
+  AsciiModeSwitchKeyBindings::const_iterator it = bindings_.find(key_code);
   if (it == bindings_.end())
     return false;
   AsciiModeSwitchStyle style = it->second;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   bool ascii_mode = !ctx->get_option("ascii_mode");
   SwitchAsciiMode(ascii_mode, style);
   toggle_with_caps_ = (key_code == XK_Caps_Lock);
@@ -220,7 +227,7 @@ bool AsciiComposer::ToggleAsciiModeWithKey(int key_code) {
 void AsciiComposer::SwitchAsciiMode(bool ascii_mode,
                                     AsciiModeSwitchStyle style) {
   DLOG(INFO) << "ascii mode: " << ascii_mode << ", switch style: " << style;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   if (ctx->IsComposing()) {
     connection_.disconnect();
     // temporary ascii mode in desired manner
@@ -229,7 +236,7 @@ void AsciiComposer::SwitchAsciiMode(bool ascii_mode,
                 << (ascii_mode ? "ascii" : "non-ascii") << " mode.";
       if (ascii_mode) {
         connection_ = ctx->update_notifier().connect(
-            [this](Context* ctx) { OnContextUpdate(ctx); });
+            boost::bind(&AsciiComposer::OnContextUpdate, this, _1));
       }
     }
     else if (style == kAsciiModeSwitchCommitText) {
@@ -247,7 +254,7 @@ void AsciiComposer::SwitchAsciiMode(bool ascii_mode,
   ctx->set_option("ascii_mode", ascii_mode);
 }
 
-void AsciiComposer::OnContextUpdate(Context* ctx) {
+void AsciiComposer::OnContextUpdate(Context *ctx) {
   if (!ctx->IsComposing()) {
     connection_.disconnect();
     // quit temporary ascii mode
diff --git a/src/gear/ascii_segmentor.cc b/src/gear/ascii_segmentor.cc
index 6b1b26c..996cf5c 100644
--- a/src/gear/ascii_segmentor.cc
+++ b/src/gear/ascii_segmentor.cc
@@ -17,13 +17,15 @@ namespace rime {
 AsciiSegmentor::AsciiSegmentor(const Ticket& ticket) : Segmentor(ticket) {
 }
 
-bool AsciiSegmentor::Proceed(Segmentation* segmentation) {
+bool AsciiSegmentor::Proceed(Segmentation *segmentation) {
   if (!engine_->context()->get_option("ascii_mode"))
     return true;
-  const std::string& input = segmentation->input();
+  const std::string &input = segmentation->input();
   size_t j = segmentation->GetCurrentStartPosition();
   if (j < input.length()) {
-    Segment segment(j, input.length());
+    Segment segment;
+    segment.start = j;
+    segment.end = input.length();
     segment.tags.insert("raw");
     segmentation->AddSegment(segment);
   }
diff --git a/src/gear/chord_composer.cc b/src/gear/chord_composer.cc
index 15812ad..5635c43 100644
--- a/src/gear/chord_composer.cc
+++ b/src/gear/chord_composer.cc
@@ -4,6 +4,7 @@
 //
 // 2012-06-05 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/config.h>
@@ -19,10 +20,11 @@ static const char* kZeroWidthSpace = "\xef\xbb\xbf";  //"\xe2\x80\x8b";
 namespace rime {
 
 
-ChordComposer::ChordComposer(const Ticket& ticket) : Processor(ticket) {
-  if (!engine_)
-    return;
-  if (Config* config = engine_->schema()->config()) {
+ChordComposer::ChordComposer(const Ticket& ticket) : Processor(ticket),
+                                                     pass_thru_(false),
+                                                     composing_(false) {
+  if (!engine_) return;
+  if (Config *config = engine_->schema()->config()) {
     config->GetString("chord_composer/alphabet", &alphabet_);
     config->GetString("speller/delimiter", &delimiter_);
     algebra_.Load(config->GetList("chord_composer/algebra"));
@@ -32,9 +34,9 @@ ChordComposer::ChordComposer(const Ticket& ticket) : Processor(ticket) {
   Context* ctx = engine_->context();
   ctx->set_option("_chord_typing", true);
   update_connection_ = ctx->update_notifier().connect(
-      [this](Context* ctx) { OnContextUpdate(ctx); });
+      boost::bind(&ChordComposer::OnContextUpdate, this, _1));
   unhandled_key_connection_ = ctx->unhandled_key_notifier().connect(
-      [this](Context* ctx, const KeyEvent& key) { OnUnhandledKey(ctx, key); });
+      boost::bind(&ChordComposer::OnUnhandledKey, this, _1, _2));
 }
 
 ChordComposer::~ChordComposer() {
@@ -105,7 +107,7 @@ ProcessResult ChordComposer::ProcessKeyEvent(const KeyEvent& key_event) {
 
 std::string ChordComposer::SerializeChord() {
   std::string code;
-  for (char ch : alphabet_) {
+  BOOST_FOREACH(char ch, alphabet_) {
     if (chord_.find(ch) != chord_.end())
       code.push_back(ch);
   }
@@ -114,11 +116,10 @@ std::string ChordComposer::SerializeChord() {
 }
 
 void ChordComposer::UpdateChord() {
-  if (!engine_)
-    return;
+  if (!engine_) return;
   Context* ctx = engine_->context();
   Composition* comp = ctx->composition();
-  std::string code = SerializeChord();
+  std::string code(SerializeChord());
   prompt_format_.Apply(&code);
   if (comp->empty()) {
     // add an invisbile place holder segment
@@ -136,16 +137,15 @@ void ChordComposer::UpdateChord() {
 }
 
 void ChordComposer::FinishChord() {
-  if (!engine_)
-    return;
-  std::string code = SerializeChord();
+  if (!engine_) return;
+  std::string code(SerializeChord());
   output_format_.Apply(&code);
   ClearChord();
 
   KeySequence sequence;
   if (sequence.Parse(code) && !sequence.empty()) {
     pass_thru_ = true;
-    for (const KeyEvent& key : sequence) {
+    BOOST_FOREACH(const KeyEvent& key, sequence) {
       if (!engine_->ProcessKey(key)) {
         // direct commit
         engine_->CommitText(std::string(1, key.keycode()));
@@ -160,8 +160,7 @@ void ChordComposer::FinishChord() {
 void ChordComposer::ClearChord() {
   pressed_.clear();
   chord_.clear();
-  if (!engine_)
-    return;
+  if (!engine_) return;
   Context* ctx = engine_->context();
   Composition* comp = ctx->composition();
   if (comp->empty()) {
diff --git a/src/gear/cjk_minifier.cc b/src/gear/cjk_minifier.cc
index c6d909d..61f19c0 100644
--- a/src/gear/cjk_minifier.cc
+++ b/src/gear/cjk_minifier.cc
@@ -52,9 +52,10 @@ void CJKMinifier::Apply(CandidateList* recruited,
   if (!candidates || candidates->empty())
     return;
 
-  for (auto it = candidates->rbegin(); it != candidates->rend(); ++it) {
+  for (CandidateList::reverse_iterator it = candidates->rbegin();
+       it != candidates->rend(); ++it) {
     if (contains_extended_cjk((*it)->text())) {
-      candidates->erase(std::next(it).base());
+      candidates->erase((it + 1).base());
     }
   }
 }
diff --git a/src/gear/echo_translator.cc b/src/gear/echo_translator.cc
index ec5c7f2..0263596 100644
--- a/src/gear/echo_translator.cc
+++ b/src/gear/echo_translator.cc
@@ -15,11 +15,11 @@ namespace rime {
 
 class EchoTranslation : public UniqueTranslation {
  public:
-  EchoTranslation(const shared_ptr<Candidate>& candidate)
+  EchoTranslation(const shared_ptr<Candidate> &candidate)
       : UniqueTranslation(candidate) {
   }
   virtual int Compare(shared_ptr<Translation> other,
-                      const CandidateList& candidates) {
+                      const CandidateList &candidates) {
     if (!candidates.empty() || (other && other->Peek())) {
       set_exhausted(true);
       return 1;
@@ -37,14 +37,15 @@ shared_ptr<Translation> EchoTranslator::Query(const std::string& input,
                                               std::string* prompt) {
   DLOG(INFO) << "input = '" << input
              << "', [" << segment.start << ", " << segment.end << ")";
-  auto candidate = New<SimpleCandidate>("raw",
-                                        segment.start,
-                                        segment.end,
-                                        input);
+  shared_ptr<Candidate> candidate =
+      boost::make_shared<SimpleCandidate>("raw",
+                                          segment.start,
+                                          segment.end,
+                                          input);
   if (candidate) {
     candidate->set_quality(-100);  // lowest priority
   }
-  return New<EchoTranslation>(candidate);
+  return make_shared<EchoTranslation>(candidate);
 }
 
 }  // namespace rime
diff --git a/src/gear/editor.cc b/src/gear/editor.cc
index ea0c26e..4653965 100644
--- a/src/gear/editor.cc
+++ b/src/gear/editor.cc
@@ -20,13 +20,13 @@ Editor::Editor(const Ticket& ticket, bool auto_commit) : Processor(ticket) {
   engine_->context()->set_option("_auto_commit", auto_commit);
 }
 
-ProcessResult Editor::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult Editor::ProcessKeyEvent(const KeyEvent &key_event) {
   if (key_event.release() || key_event.alt())
     return kRejected;
   int ch = key_event.keycode();
   if (key_event.ctrl() && !WorkWithCtrl(ch))
     return kNoop;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   if (ch == XK_space) {
     if (ctx->IsComposing()) {
       OnSpace(ctx);
@@ -120,8 +120,9 @@ void Editor::DropPreviousSyllable(Context* ctx) {
     return;
   const Composition* comp = ctx->composition();
   if (comp && !comp->empty()) {
-    auto cand = comp->back().GetSelectedCandidate();
-    auto phrase = As<Phrase>(Candidate::GetGenuineCandidate(cand));
+    shared_ptr<Candidate> cand = comp->back().GetSelectedCandidate();
+    shared_ptr<Phrase> phrase =
+        As<Phrase>(Candidate::GetGenuineCandidate(cand));
     if (phrase && phrase->syllabification()) {
       size_t stop = phrase->syllabification()->PreviousStop(caret_pos);
       if (stop != caret_pos) {
diff --git a/src/gear/fallback_segmentor.cc b/src/gear/fallback_segmentor.cc
index b80c234..27c5639 100644
--- a/src/gear/fallback_segmentor.cc
+++ b/src/gear/fallback_segmentor.cc
@@ -14,13 +14,13 @@ FallbackSegmentor::FallbackSegmentor(const Ticket& ticket)
     : Segmentor(ticket) {
 }
 
-bool FallbackSegmentor::Proceed(Segmentation* segmentation) {
+bool FallbackSegmentor::Proceed(Segmentation *segmentation) {
   int len = segmentation->GetCurrentSegmentLength();
   DLOG(INFO) << "current segment length: " << len;
   if (len > 0)
     return false;
 
-  const std::string& input(segmentation->input());
+  const std::string &input = segmentation->input();
   int k = segmentation->GetCurrentStartPosition();
   DLOG(INFO) << "current start pos: " << k;
   if (k == input.length())
@@ -28,12 +28,11 @@ bool FallbackSegmentor::Proceed(Segmentation* segmentation) {
 
   DLOG(INFO) << "segmentation: " << *segmentation;
   if (!segmentation->empty() &&
-      segmentation->back().start == segmentation->back().end) {
+      segmentation->back().start == segmentation->back().end)
     segmentation->pop_back();
-  }
-
+  
   if (!segmentation->empty()) {
-    Segment& last(segmentation->back());
+    Segment &last(segmentation->back());
     // append one character to the last raw segment
     if (last.HasTag("raw")) {
       last.end = k + 1;
@@ -46,7 +45,9 @@ bool FallbackSegmentor::Proceed(Segmentation* segmentation) {
     }
   }
   {
-    Segment segment(k, k + 1);
+    Segment segment;
+    segment.start = k;
+    segment.end = k + 1;
     DLOG(INFO) << "add a raw segment ["
                << segment.start << ", " << segment.end << ")";
     segment.tags.insert("raw");
diff --git a/src/gear/filter_commons.cc b/src/gear/filter_commons.cc
index 05257ce..dcd5dfa 100644
--- a/src/gear/filter_commons.cc
+++ b/src/gear/filter_commons.cc
@@ -4,6 +4,7 @@
 //
 // 2013-11-05 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/schema.h>
 #include <rime/segmentation.h>
 #include <rime/ticket.h>
@@ -12,11 +13,10 @@
 namespace rime {
 
 TagMatching::TagMatching(const Ticket& ticket) {
-  if (!ticket.schema)
-    return;
+  if (!ticket.schema) return;
   Config* config = ticket.schema->config();
-  if (auto tags = config->GetList(ticket.name_space + "/tags")) {
-    for (auto it = tags->begin(); it != tags->end(); ++it) {
+  if (ConfigListPtr tags = config->GetList(ticket.name_space + "/tags")) {
+    for (ConfigList::Iterator it = tags->begin(); it != tags->end(); ++it) {
       if (Is<ConfigValue>(*it)) {
         tags_.push_back(As<ConfigValue>(*it)->str());
       }
@@ -29,7 +29,7 @@ bool TagMatching::TagsMatch(Segment* segment) {
     return false;
   if (tags_.empty())  // match any
     return true;
-  for (const std::string& tag : tags_) {
+  BOOST_FOREACH(const std::string& tag, tags_) {
     if (segment->HasTag(tag))
       return true;
   }
diff --git a/src/gear/gears_module.cc b/src/gear/gears_module.cc
index 3c288a5..1a9b2e2 100644
--- a/src/gear/gears_module.cc
+++ b/src/gear/gears_module.cc
@@ -39,7 +39,7 @@ static void rime_gears_initialize() {
   using namespace rime;
 
   LOG(INFO) << "registering components from module 'gears'.";
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
 
   // processors
   r.Register("ascii_composer", new Component<AsciiComposer>);
diff --git a/src/gear/key_binder.cc b/src/gear/key_binder.cc
index 200824b..6405e78 100644
--- a/src/gear/key_binder.cc
+++ b/src/gear/key_binder.cc
@@ -5,11 +5,13 @@
 // 2011-11-23 GONG Chen <chen.sst@gmail.com>
 //
 #include <algorithm>
-#include <functional>
 #include <map>
 #include <set>
 #include <string>
 #include <vector>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
+#include <boost/function.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/context.h>
@@ -20,8 +22,6 @@
 #include <rime/switcher.h>
 #include <rime/gear/key_binder.h>
 
-using namespace std::placeholders;
-
 namespace rime {
 
 enum KeyBindingCondition {
@@ -44,7 +44,7 @@ static struct KeyBindingConditionDef {
 };
 
 static KeyBindingCondition translate_condition(const std::string& str) {
-  for (auto* d = condition_definitions; d->name; ++d) {
+  for (KeyBindingConditionDef* d = condition_definitions; d->name; ++d) {
     if (str == d->name)
       return d->condition;
   }
@@ -54,7 +54,7 @@ static KeyBindingCondition translate_condition(const std::string& str) {
 struct KeyBinding {
   KeyBindingCondition whence;
   KeyEvent target;
-  std::function<void (Engine* engine)> action;
+  boost::function<void (Engine* engine)> action;
 
   bool operator< (const KeyBinding& o) const {
     return whence < o.whence;
@@ -62,15 +62,14 @@ struct KeyBinding {
 };
 
 class KeyBindings : public std::map<KeyEvent,
-                                    std::vector<KeyBinding>> {
+                                    std::vector<KeyBinding> > {
  public:
-  void LoadBindings(const ConfigListPtr& bindings);
+  void LoadBindings(const ConfigListPtr &bindings);
   void Bind(const KeyEvent& key, const KeyBinding& binding);
 };
 
 static void toggle_option(Engine* engine, const std::string& option) {
-  if (!engine)
-    return;
+  if (!engine) return;
   Context* ctx = engine->context();
   ctx->set_option(option, !ctx->get_option(option));
 }
@@ -87,19 +86,15 @@ static void select_schema(Engine* engine, const std::string& schema) {
   }
 }
 
-void KeyBindings::LoadBindings(const ConfigListPtr& bindings) {
-  if (!bindings)
-    return;
+void KeyBindings::LoadBindings(const ConfigListPtr &bindings) {
+  if (!bindings) return;
   for (size_t i = 0; i < bindings->size(); ++i) {
-    auto map = As<ConfigMap>(bindings->GetAt(i));
-    if (!map)
-      continue;
-    auto whence = map->GetValue("when");
-    if (!whence)
-      continue;
-    auto pattern = map->GetValue("accept");
-    if (!pattern)
-      continue;
+    ConfigMapPtr map = As<ConfigMap>(bindings->GetAt(i));
+    if (!map) continue;
+    ConfigValuePtr whence = map->GetValue("when");
+    if (!whence) continue;
+    ConfigValuePtr pattern = map->GetValue("accept");
+    if (!pattern) continue;
     KeyBinding binding;
     binding.whence = translate_condition(whence->str());
     if (binding.whence == kNever) {
@@ -110,17 +105,17 @@ void KeyBindings::LoadBindings(const ConfigListPtr& bindings) {
       LOG(WARNING) << "invalid key binding #" << i << ".";
       continue;
     }
-    if (auto target = map->GetValue("send")) {
+    if (ConfigValuePtr target = map->GetValue("send")) {
       if (!binding.target.Parse(target->str())) {
         LOG(WARNING) << "invalid key binding #" << i << ".";
         continue;
       }
     }
-    else if (auto option = map->GetValue("toggle")) {
-      binding.action = std::bind(&toggle_option, _1, option->str());
+    else if (ConfigValuePtr option = map->GetValue("toggle")) {
+      binding.action = boost::bind(&toggle_option, _1, option->str());
     }
-    else if (auto schema = map->GetValue("select")) {
-      binding.action = std::bind(&select_schema, _1, schema->str());
+    else if (ConfigValuePtr schema = map->GetValue("select")) {
+      binding.action = boost::bind(&select_schema, _1, schema->str());
     }
     else {
       LOG(WARNING) << "invalid key binding #" << i << ".";
@@ -131,10 +126,11 @@ void KeyBindings::LoadBindings(const ConfigListPtr& bindings) {
 }
 
 void KeyBindings::Bind(const KeyEvent& key, const KeyBinding& binding) {
-  auto& vec = (*this)[key];
+  std::vector<KeyBinding>& v = (*this)[key];
   // insert before existing binding of the same condition
-  auto lb = std::lower_bound(vec.begin(), vec.end(), binding);
-  vec.insert(lb, binding);
+  std::vector<KeyBinding>::iterator lb =
+      std::lower_bound(v.begin(), v.end(), binding);
+  v.insert(lb, binding);
 }
 
 KeyBinder::KeyBinder(const Ticket& ticket) : Processor(ticket),
@@ -144,37 +140,38 @@ KeyBinder::KeyBinder(const Ticket& ticket) : Processor(ticket),
   LoadConfig();
 }
 
-class KeyBindingConditions : public std::set<KeyBindingCondition> {
- public:
-  explicit KeyBindingConditions(Context* ctx);
-};
+typedef std::set<KeyBindingCondition> Conditions;
 
-KeyBindingConditions::KeyBindingConditions(Context* ctx) {
-  insert(kAlways);
+static void calculate_conditions(Context *ctx, Conditions *conditions) {
+  // prevent duplicated evaluation
+  if (!conditions->empty()) return;
+
+  conditions->insert(kAlways);
 
   if (ctx->IsComposing()) {
-    insert(kWhenComposing);
+    conditions->insert(kWhenComposing);
   }
 
   if (ctx->HasMenu() && !ctx->get_option("ascii_mode")) {
-    insert(kWhenHasMenu);
+    conditions->insert(kWhenHasMenu);
   }
 
-  Composition* comp = ctx->composition();
+  Composition *comp = ctx->composition();
   if (!comp->empty() && comp->back().HasTag("paging")) {
-    insert(kWhenPaging);
+    conditions->insert(kWhenPaging);
   }
 }
 
-ProcessResult KeyBinder::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult KeyBinder::ProcessKeyEvent(const KeyEvent &key_event) {
   if (redirecting_ || !key_bindings_ || key_bindings_->empty())
     return kNoop;
   if (ReinterpretPagingKey(key_event))
     return kNoop;
   if (key_bindings_->find(key_event) == key_bindings_->end())
     return kNoop;
-  KeyBindingConditions conditions(engine_->context());
-  for (const KeyBinding& binding : (*key_bindings_)[key_event]) {
+  Conditions conditions;
+  calculate_conditions(engine_->context(), &conditions);
+  BOOST_FOREACH(const KeyBinding& binding, (*key_bindings_)[key_event]) {
     if (conditions.find(binding.whence) == conditions.end())
       continue;
     PerformKeyBinding(binding);
@@ -196,29 +193,29 @@ void KeyBinder::PerformKeyBinding(const KeyBinding& binding) {
 }
 
 void KeyBinder::LoadConfig() {
-  if (!engine_)
-    return;
-  Config* config = engine_->schema()->config();
+  if (!engine_) return;
+  Config *config = engine_->schema()->config();
   std::string preset;
   if (config->GetString("key_binder/import_preset", &preset)) {
-    unique_ptr<Config> preset_config(Config::Require("config")->Create(preset));
+    scoped_ptr<Config> preset_config(Config::Require("config")->Create(preset));
     if (!preset_config) {
       LOG(ERROR) << "Error importing preset key bindings '" << preset << "'.";
       return;
     }
-    if (auto bindings = preset_config->GetList("key_binder/bindings"))
+    ConfigListPtr bindings = preset_config->GetList("key_binder/bindings");
+    if (bindings)
       key_bindings_->LoadBindings(bindings);
     else
       LOG(WARNING) << "missing preset key bindings.";
   }
   // per schema configuration, overriding preset bindings
-  if (auto bindings = config->GetList("key_binder/bindings"))
+  ConfigListPtr bindings = config->GetList("key_binder/bindings");
+  if (bindings)
     key_bindings_->LoadBindings(bindings);
 }
 
-bool KeyBinder::ReinterpretPagingKey(const KeyEvent& key_event) {
-  if (key_event.release())
-    return false;
+bool KeyBinder::ReinterpretPagingKey(const KeyEvent &key_event) {
+  if (key_event.release()) return false;
   bool ret = false;
   int ch = (key_event.modifier() == 0) ? key_event.keycode() : 0;
   // reinterpret period key followed by alphabetic keys
@@ -228,8 +225,8 @@ bool KeyBinder::ReinterpretPagingKey(const KeyEvent& key_event) {
     return ret;
   }
   if (last_key_ == '.' && ch >= 'a' && ch <= 'z') {
-    Context* ctx = engine_->context();
-    const std::string& input(ctx->input());
+    Context *ctx = engine_->context();
+    const std::string &input(ctx->input());
     if (!input.empty() && input[input.length() - 1] != '.') {
       LOG(INFO) << "reinterpreted key: '" << last_key_
                 << "', successor: '" << (char)ch << "'";
diff --git a/src/gear/matcher.cc b/src/gear/matcher.cc
index 00a86f0..2d3fb43 100644
--- a/src/gear/matcher.cc
+++ b/src/gear/matcher.cc
@@ -4,6 +4,7 @@
 //
 // 2012-01-01 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/config.h>
 #include <rime/schema.h>
@@ -14,23 +15,23 @@ namespace rime {
 
 Matcher::Matcher(const Ticket& ticket) : Segmentor(ticket) {
   // read schema settings
-  if (!ticket.schema)
-    return;
-  Config* config = ticket.schema->config();
+  if (!ticket.schema) return;
+  Config *config = ticket.schema->config();
   patterns_.LoadConfig(config);
 }
 
-bool Matcher::Proceed(Segmentation* segmentation) {
-  if (patterns_.empty())
-    return true;
-  auto match = patterns_.GetMatch(segmentation->input(), segmentation);
-  if (match.found()) {
-    DLOG(INFO) << "match: " << match.tag
-               << " [" << match.start << ", " << match.end << ")";
-    while (segmentation->GetCurrentStartPosition() > match.start)
+bool Matcher::Proceed(Segmentation *segmentation) {
+  if (patterns_.empty()) return true;
+  RecognizerMatch m = patterns_.GetMatch(segmentation->input(), segmentation);
+  if (m.found()) {
+    DLOG(INFO) << "match: " << m.tag
+               << " [" << m.start << ", " << m.end << ")";
+    while (segmentation->GetCurrentStartPosition() > m.start)
       segmentation->pop_back();
-    Segment segment(match.start, match.end);
-    segment.tags.insert(match.tag);
+    Segment segment;
+    segment.start = m.start;
+    segment.end = m.end;
+    segment.tags.insert(m.tag);
     segmentation->AddSegment(segment);
     // terminate this round?
     //return false;
diff --git a/src/gear/memory.cc b/src/gear/memory.cc
index 5769cea..11e5fd8 100644
--- a/src/gear/memory.cc
+++ b/src/gear/memory.cc
@@ -4,6 +4,8 @@
 //
 // 2013-01-02 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/context.h>
 #include <rime/composition.h>
@@ -26,10 +28,10 @@ void CommitEntry::Clear() {
 
 void CommitEntry::AppendPhrase(const shared_ptr<Phrase>& phrase) {
   text += phrase->text();
-  code.insert(code.end(),
-              phrase->code().begin(), phrase->code().end());
-  if (auto sentence = As<Sentence>(phrase)) {
-    for (const DictEntry& e : sentence->components()) {
+  code.insert(code.end(), phrase->code().begin(), phrase->code().end());
+  shared_ptr<Sentence> sentence = As<Sentence>(phrase);
+  if (sentence) {
+    BOOST_FOREACH(const DictEntry& e, sentence->components()) {
       elements.push_back(&e);
     }
   }
@@ -47,16 +49,18 @@ bool CommitEntry::Save() const {
 }
 
 Memory::Memory(const Ticket& ticket) {
-  if (!ticket.engine)
-    return;
+  if (!ticket.engine) return;
 
-  if (auto dictionary = Dictionary::Require("dictionary")) {
+  Dictionary::Component *dictionary = Dictionary::Require("dictionary");
+  if (dictionary) {
     dict_.reset(dictionary->Create(ticket));
     if (dict_)
       dict_->Load();
   }
 
-  if (auto user_dictionary = UserDictionary::Require("user_dictionary")) {
+  UserDictionary::Component *user_dictionary =
+      UserDictionary::Require("user_dictionary");
+  if (user_dictionary) {
     user_dict_.reset(user_dictionary->Create(ticket));
     if (user_dict_) {
       user_dict_->Load();
@@ -67,11 +71,11 @@ Memory::Memory(const Ticket& ticket) {
 
   Context* ctx = ticket.engine->context();
   commit_connection_ = ctx->commit_notifier().connect(
-      [this](Context* ctx) { OnCommit(ctx); });
+      boost::bind(&Memory::OnCommit, this, _1));
   delete_connection_ = ctx->delete_notifier().connect(
-      [this](Context* ctx) { OnDeleteEntry(ctx); });
+      boost::bind(&Memory::OnDeleteEntry, this, _1));
   unhandled_key_connection_ = ctx->unhandled_key_notifier().connect(
-      [this](Context* ctx, const KeyEvent& key) { OnUnhandledKey(ctx, key); });
+      boost::bind(&Memory::OnUnhandledKey, this, _1, _2));
 }
 
 Memory::~Memory() {
@@ -86,9 +90,9 @@ void Memory::OnCommit(Context* ctx) {
   user_dict_->NewTransaction();
 
   CommitEntry commit_entry(this);
-  for (auto& seg : *ctx->composition()) {
-    auto phrase = As<Phrase>(Candidate::GetGenuineCandidate(
-            seg.GetSelectedCandidate()));
+  BOOST_FOREACH(Composition::value_type &seg, *ctx->composition()) {
+    shared_ptr<Phrase> phrase =
+        As<Phrase>(Candidate::GetGenuineCandidate(seg.GetSelectedCandidate()));
     bool recognized = phrase && phrase->language() == language();
     if (recognized) {
       commit_entry.AppendPhrase(phrase);
@@ -106,9 +110,9 @@ void Memory::OnDeleteEntry(Context* ctx) {
       !ctx ||
       ctx->composition()->empty())
     return;
-  Segment& seg(ctx->composition()->back());
-  auto phrase = As<Phrase>(Candidate::GetGenuineCandidate(
-          seg.GetSelectedCandidate()));
+  Segment &seg(ctx->composition()->back());
+  shared_ptr<Phrase> phrase =
+      As<Phrase>(Candidate::GetGenuineCandidate(seg.GetSelectedCandidate()));
   bool recognized = phrase && phrase->language() == language();
   if (recognized) {
     const DictEntry& entry(phrase->entry());
diff --git a/src/gear/navigator.cc b/src/gear/navigator.cc
index c224319..b00efe0 100644
--- a/src/gear/navigator.cc
+++ b/src/gear/navigator.cc
@@ -4,7 +4,7 @@
 //
 // 2011-11-20 GONG Chen <chen.sst@gmail.com>
 //
-#include <boost/range/adaptor/reversed.hpp>
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/context.h>
@@ -16,10 +16,10 @@
 
 namespace rime {
 
-ProcessResult Navigator::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult Navigator::ProcessKeyEvent(const KeyEvent &key_event) {
   if (key_event.release())
     return kNoop;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   if (!ctx->IsComposing())
     return kNoop;
   int ch = key_event.keycode();
@@ -47,15 +47,16 @@ ProcessResult Navigator::ProcessKeyEvent(const KeyEvent& key_event) {
   return kNoop;
 }
 
-bool Navigator::Left(Context* ctx) {
+bool Navigator::Left(Context *ctx) {
   DLOG(INFO) << "navigate left.";
   size_t caret_pos = ctx->caret_pos();
   if (caret_pos == 0)
     return End(ctx);
   const Composition* comp = ctx->composition();
   if (comp && !comp->empty()) {
-    auto cand = comp->back().GetSelectedCandidate();
-    auto phrase = As<Phrase>(Candidate::GetGenuineCandidate(cand));
+    shared_ptr<Candidate> cand = comp->back().GetSelectedCandidate();
+    shared_ptr<Phrase> phrase =
+        As<Phrase>(Candidate::GetGenuineCandidate(cand));
     if (phrase && phrase->syllabification()) {
       size_t stop = phrase->syllabification()->PreviousStop(caret_pos);
       if (stop != caret_pos) {
@@ -68,7 +69,7 @@ bool Navigator::Left(Context* ctx) {
   return true;
 }
 
-bool Navigator::Right(Context* ctx) {
+bool Navigator::Right(Context *ctx) {
   DLOG(INFO) << "navigate right.";
   size_t caret_pos = ctx->caret_pos();
   if (caret_pos >= ctx->input().length())
@@ -77,13 +78,13 @@ bool Navigator::Right(Context* ctx) {
   return true;
 }
 
-bool Navigator::Home(Context* ctx) {
+bool Navigator::Home(Context *ctx) {
   DLOG(INFO) << "navigate home.";
   size_t caret_pos = ctx->caret_pos();
-  const Composition* comp = ctx->composition();
+  Composition *comp = ctx->composition();
   if (!comp->empty()) {
     size_t confirmed_pos = caret_pos;
-    for (const Segment& seg : boost::adaptors::reverse(*comp)) {
+    BOOST_REVERSE_FOREACH(const Segment &seg, *comp) {
       if (seg.status >= Segment::kSelected) {
         break;
       }
@@ -98,7 +99,7 @@ bool Navigator::Home(Context* ctx) {
   return true;
 }
 
-bool Navigator::End(Context* ctx) {
+bool Navigator::End(Context *ctx) {
   DLOG(INFO) << "navigate end.";
   size_t end_pos = ctx->input().length();
   if (ctx->caret_pos() != end_pos) {
diff --git a/src/gear/poet.cc b/src/gear/poet.cc
index cb7da6a..d8e17d5 100644
--- a/src/gear/poet.cc
+++ b/src/gear/poet.cc
@@ -8,6 +8,7 @@
 //
 #include <map>
 #include <vector>
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/candidate.h>
 #include <rime/dict/vocabulary.h>
@@ -18,24 +19,24 @@ namespace rime {
 shared_ptr<Sentence> Poet::MakeSentence(const WordGraph& graph,
                                         size_t total_length) {
   const int kMaxHomophonesInMind = 1;
-  std::map<int, shared_ptr<Sentence>> sentences;
-  sentences[0] = New<Sentence>(language_);
+  std::map<int, shared_ptr<Sentence> > sentences;
+  sentences[0] = make_shared<Sentence>(language_);
   // dynamic programming
-  for (const auto& w : graph) {
+  BOOST_FOREACH(const WordGraph::value_type& w, graph) {
     size_t start_pos = w.first;
     DLOG(INFO) << "start pos: " << start_pos;
     if (sentences.find(start_pos) == sentences.end())
       continue;
-    for (const auto& x : w.second) {
+    BOOST_FOREACH(const UserDictEntryCollector::value_type& x, w.second) {
       size_t end_pos = x.first;
       if (start_pos == 0 && end_pos == total_length)
         continue;  // exclude single words from the result
       DLOG(INFO) << "end pos: " << end_pos;
-      const DictEntryList& entries(x.second);
+      const DictEntryList &entries(x.second);
       for (size_t i = 0; i < kMaxHomophonesInMind && i < entries.size(); ++i) {
-        const auto& entry(entries[i]);
-        auto new_sentence = New<Sentence>(*sentences[start_pos]);
-        new_sentence->Extend(*entry, end_pos);
+        const shared_ptr<DictEntry> &e(entries[i]);
+        shared_ptr<Sentence> new_sentence = make_shared<Sentence>(*sentences[start_pos]);
+        new_sentence->Extend(*e, end_pos);
         if (sentences.find(end_pos) == sentences.end() ||
             sentences[end_pos]->weight() < new_sentence->weight()) {
           DLOG(INFO) << "updated sentences " << end_pos << ") with '"
@@ -46,7 +47,7 @@ shared_ptr<Sentence> Poet::MakeSentence(const WordGraph& graph,
     }
   }
   if (sentences.find(total_length) == sentences.end())
-    return nullptr;
+    return shared_ptr<Sentence>();
   else
     return sentences[total_length];
 }
diff --git a/src/gear/punctuator.cc b/src/gear/punctuator.cc
index e4f5daa..e4a6ae3 100644
--- a/src/gear/punctuator.cc
+++ b/src/gear/punctuator.cc
@@ -5,6 +5,7 @@
 //
 // 2011-11-21 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <utf8.h>
 #include <rime/commit_history.h>
 #include <rime/common.h>
@@ -20,17 +21,15 @@
 
 namespace rime {
 
-void PunctConfig::LoadConfig(Engine* engine, bool load_symbols) {
+void PunctConfig::LoadConfig(Engine *engine, bool load_symbols) {
   bool full_shape = engine->context()->get_option("full_shape");
   std::string shape(full_shape ? "full_shape" : "half_shape");
-  if (shape_ == shape)
-    return;
+  if (shape_ == shape) return;
   shape_ = shape;
-  Config* config = engine->schema()->config();
+  Config *config = engine->schema()->config();
   std::string preset;
   if (config->GetString("punctuator/import_preset", &preset)) {
-    unique_ptr<Config> preset_config(
-        Config::Require("config")->Create(preset));
+    scoped_ptr<Config> preset_config(Config::Require("config")->Create(preset));
     if (!preset_config) {
       LOG(ERROR) << "Error importing preset punctuation '" << preset << "'.";
       return;
@@ -74,8 +73,9 @@ ConfigItemPtr PunctConfig::GetPunctDefinition(const std::string key) {
   return punct_definition;
 }
 
-Punctuator::Punctuator(const Ticket& ticket) : Processor(ticket) {
-  Config* config = engine_->schema()->config();
+Punctuator::Punctuator(const Ticket& ticket) : Processor(ticket),
+                                               use_space_(false) {
+  Config *config = engine_->schema()->config();
   if (config) {
     config->GetBool("punctuator/use_space", &use_space_);
   }
@@ -87,7 +87,7 @@ static bool punctuation_is_translated(Context* ctx) {
   if (comp->empty() || !comp->back().HasTag("punct")) {
     return false;
   }
-  auto cand = comp->back().GetSelectedCandidate();
+  shared_ptr<Candidate> cand = comp->back().GetSelectedCandidate();
   return cand && cand->type() == "punct";
 }
 
@@ -108,15 +108,14 @@ ProcessResult Punctuator::ProcessKeyEvent(const KeyEvent& key_event) {
     const CommitHistory& history(ctx->commit_history());
     if (!history.empty()) {
       const CommitRecord& cr(history.back());
-      if (cr.type == "thru" &&
-          cr.text.length() == 1 && isdigit(cr.text[0])) {
+      if (cr.type == "thru" && cr.text.length() == 1 && isdigit(cr.text[0])) {
         return kRejected;
       }
     }
   }
   config_.LoadConfig(engine_);
   std::string punct_key(1, ch);
-  auto punct_definition = config_.GetPunctDefinition(punct_key);
+  ConfigItemPtr punct_definition(config_.GetPunctDefinition(punct_key));
   if (!punct_definition)
     return kNoop;
   DLOG(INFO) << "punct key: '" << punct_key << "'";
@@ -130,20 +129,18 @@ ProcessResult Punctuator::ProcessKeyEvent(const KeyEvent& key_event) {
   return kAccepted;
 }
 
-bool Punctuator::AlternatePunct(const std::string& key,
-                                const ConfigItemPtr& definition) {
+bool Punctuator::AlternatePunct(const std::string &key,
+                                const ConfigItemPtr &definition) {
   if (!As<ConfigList>(definition))
     return false;
-  Context* ctx = engine_->context();
-  Composition* comp = ctx->composition();
+  Context *ctx = engine_->context();
+  Composition *comp = ctx->composition();
   if (comp->empty())
     return false;
-  Segment& segment(comp->back());
-  if (segment.status > Segment::kVoid &&
-      segment.HasTag("punct") &&
+  Segment &segment(comp->back());
+  if (segment.status > Segment::kVoid && segment.HasTag("punct") &&
       key == ctx->input().substr(segment.start, segment.end - segment.start)) {
-    if (!segment.menu ||
-        segment.menu->Prepare(segment.selected_index + 2) == 0) {
+    if (!segment.menu || segment.menu->Prepare(segment.selected_index + 2) == 0) {
       LOG(ERROR) << "missing candidate for punctuation '" << key << "'.";
       return false;
     }
@@ -155,37 +152,39 @@ bool Punctuator::AlternatePunct(const std::string& key,
   return false;
 }
 
-bool Punctuator::ConfirmUniquePunct(const ConfigItemPtr& definition) {
+bool Punctuator::ConfirmUniquePunct(const ConfigItemPtr &definition) {
   if (!As<ConfigValue>(definition))
     return false;
-  engine_->context()->ConfirmCurrentSelection();
+  Context *ctx = engine_->context();
+  ctx->ConfirmCurrentSelection();
   return true;
 }
 
-bool Punctuator::AutoCommitPunct(const ConfigItemPtr& definition) {
-  auto map = As<ConfigMap>(definition);
+bool Punctuator::AutoCommitPunct(const ConfigItemPtr &definition) {
+  ConfigMapPtr map(As<ConfigMap>(definition));
   if (!map || !map->HasKey("commit"))
     return false;
-  engine_->context()->Commit();
+  Context *ctx = engine_->context();
+  ctx->Commit();
   return true;
 }
 
-bool Punctuator::PairPunct(const ConfigItemPtr& definition) {
-  auto map = As<ConfigMap>(definition);
+bool Punctuator::PairPunct(const ConfigItemPtr &definition) {
+  ConfigMapPtr map(As<ConfigMap>(definition));
   if (!map || !map->HasKey("pair"))
     return false;
-  Context* ctx = engine_->context();
-  Composition* comp = ctx->composition();
+  Context *ctx = engine_->context();
+  Composition *comp = ctx->composition();
   if (comp->empty())
     return false;
-  Segment& segment(comp->back());
+  Segment &segment(comp->back());
   if (segment.status > Segment::kVoid && segment.HasTag("punct")) {
     if (!segment.menu || segment.menu->Prepare(2) < 2) {
       LOG(ERROR) << "missing candidate for paired punctuation.";
       return false;
     }
     DLOG(INFO) << "alternating paired punctuation.";
-    auto& oddness(oddness_[definition]);
+    int& oddness(oddness_[definition]);
     (segment.selected_index += oddness) %= 2;
     oddness = 1 - oddness;
     ctx->ConfirmCurrentSelection();
@@ -198,8 +197,8 @@ PunctSegmentor::PunctSegmentor(const Ticket& ticket) : Segmentor(ticket) {
   config_.LoadConfig(engine_);
 }
 
-bool PunctSegmentor::Proceed(Segmentation* segmentation) {
-  const std::string& input = segmentation->input();
+bool PunctSegmentor::Proceed(Segmentation *segmentation) {
+  const std::string &input = segmentation->input();
   int k = segmentation->GetCurrentStartPosition();
   if (k == input.length())
     return false;  // no chance for others too
@@ -208,11 +207,13 @@ bool PunctSegmentor::Proceed(Segmentation* segmentation) {
     return true;
   config_.LoadConfig(engine_);
   std::string punct_key(1, ch);
-  auto punct_definition = config_.GetPunctDefinition(punct_key);
+  ConfigItemPtr punct_definition(config_.GetPunctDefinition(punct_key));
   if (!punct_definition)
     return true;
   {
-    Segment segment(k, k + 1);
+    Segment segment;
+    segment.start = k;
+    segment.end = k + 1;
     DLOG(INFO) << "add a punctuation segment ["
                << segment.start << ", " << segment.end << ")";
     segment.tags.insert("punct");
@@ -227,12 +228,9 @@ PunctTranslator::PunctTranslator(const Ticket& ticket)
   config_.LoadConfig(engine_, load_symbols);
 }
 
-shared_ptr<Candidate>
-CreatePunctCandidate(const std::string& punct, const Segment& segment) {
-  const char half_shape[] =
-      "\xe3\x80\x94\xe5\x8d\x8a\xe8\xa7\x92\xe3\x80\x95";  // 〔半角〕
-  const char full_shape[] =
-      "\xe3\x80\x94\xe5\x85\xa8\xe8\xa7\x92\xe3\x80\x95";  // 〔全角〕
+shared_ptr<Candidate> CreatePunctCandidate(const std::string &punct, const Segment &segment) {
+  const char half_shape[] = "\xe3\x80\x94\xe5\x8d\x8a\xe8\xa7\x92\xe3\x80\x95";  // 〔半角〕
+  const char full_shape[] = "\xe3\x80\x94\xe5\x85\xa8\xe8\xa7\x92\xe3\x80\x95";  // 〔全角〕
   bool is_half_shape = false;
   bool is_full_shape = false;
   const char* p = punct.c_str();
@@ -246,116 +244,102 @@ CreatePunctCandidate(const std::string& punct, const Segment& segment) {
     is_full_shape = is_ideographic_space || is_full_shape_ascii;
   }
   bool one_key = (segment.end - segment.start == 1);
-  return New<SimpleCandidate>("punct",
-                              segment.start,
-                              segment.end,
-                              punct,
-                              (is_half_shape ? half_shape :
-                               is_full_shape ? full_shape : ""),
-                              one_key ? punct : "");
+  return boost::make_shared<SimpleCandidate>("punct",
+                                             segment.start,
+                                             segment.end,
+                                             punct,
+                                             (is_half_shape ? half_shape :
+                                              is_full_shape ? full_shape : ""),
+                                             one_key ? punct : "");
 }
 
-shared_ptr<Translation> PunctTranslator::Query(const std::string& input,
-                                               const Segment& segment,
+shared_ptr<Translation> PunctTranslator::Query(const std::string &input,
+                                               const Segment &segment,
                                                std::string* prompt) {
   if (!segment.HasTag("punct"))
-    return nullptr;
+    return shared_ptr<Translation>();
   config_.LoadConfig(engine_);
-  auto definition = config_.GetPunctDefinition(input);
+  ConfigItemPtr definition(config_.GetPunctDefinition(input));
   if (!definition)
-    return nullptr;
+    return shared_ptr<Translation>();
   DLOG(INFO) << "populating punctuation candidates for '" << input << "'.";
-  auto translation = TranslateUniquePunct(input, segment,
-                                          As<ConfigValue>(definition));
+  shared_ptr<Translation> translation = TranslateUniquePunct(input, segment, As<ConfigValue>(definition));
   if (!translation)
-    translation = TranslateAlternatingPunct(input, segment,
-                                            As<ConfigList>(definition));
+    translation = TranslateAlternatingPunct(input, segment, As<ConfigList>(definition));
   if (!translation)
-    translation = TranslateAutoCommitPunct(input, segment,
-                                           As<ConfigMap>(definition));
+    translation = TranslateAutoCommitPunct(input, segment, As<ConfigMap>(definition));
   if (!translation)
-    translation = TranslatePairedPunct(input, segment,
-                                       As<ConfigMap>(definition));
+    translation = TranslatePairedPunct(input, segment, As<ConfigMap>(definition));
   //if (prompt && translation) {
-  //  const char tips[] =
-  //      "\xe3\x80\x94\xe7\xac\xa6\xe8\x99\x9f\xe3\x80\x95";  // 〔符號〕
+  //  const char tips[] = "\xe3\x80\x94\xe7\xac\xa6\xe8\x99\x9f\xe3\x80\x95";  // 〔符號〕
   //  *prompt = tips;
   //}
   return translation;
 }
 
-shared_ptr<Translation>
-PunctTranslator::TranslateUniquePunct(const std::string& key,
-                                      const Segment& segment,
-                                      const ConfigValuePtr& definition) {
+shared_ptr<Translation> PunctTranslator::TranslateUniquePunct(const std::string &key,
+                                                              const Segment &segment,
+                                                              const ConfigValuePtr &definition) {
   if (!definition)
-    return nullptr;
-  return New<UniqueTranslation>(
-      CreatePunctCandidate(definition->str(), segment));
+    return shared_ptr<Translation>();
+  return make_shared<UniqueTranslation>(CreatePunctCandidate(definition->str(), segment));
 }
 
-shared_ptr<Translation>
-PunctTranslator::TranslateAlternatingPunct(const std::string& key,
-                                           const Segment& segment,
-                                           const ConfigListPtr& definition) {
+shared_ptr<Translation> PunctTranslator::TranslateAlternatingPunct(const std::string &key,
+                                                                   const Segment &segment,
+                                                                   const ConfigListPtr &definition) {
   if (!definition)
-    return nullptr;
-  auto translation = New<FifoTranslation>();
+    return shared_ptr<Translation>();
+  shared_ptr<FifoTranslation> translation(new FifoTranslation);
   for (size_t i = 0; i < definition->size(); ++i) {
-    auto value = definition->GetValueAt(i);
+    ConfigValuePtr value = definition->GetValueAt(i);
     if (!value) {
-      LOG(WARNING) << "invalid alternating punct at index " << i
-                   << " for '" << key << "'.";
+      LOG(WARNING) << "invalid alternating punct at index " << i << " for '" << key << "'.";
       continue;
     }
     translation->Append(CreatePunctCandidate(value->str(), segment));
   }
   if (!translation->size()) {
-    LOG(WARNING) << "empty candidate list for alternating punct '"
-                 << key << "'.";
+    LOG(WARNING) << "empty candidate list for alternating punct '" << key << "'.";
     translation.reset();
   }
   return translation;
 }
 
-shared_ptr<Translation>
-PunctTranslator::TranslateAutoCommitPunct(const std::string& key,
-                                          const Segment& segment,
-                                          const ConfigMapPtr& definition) {
+shared_ptr<Translation> PunctTranslator::TranslateAutoCommitPunct(const std::string &key,
+                                                                  const Segment &segment,
+                                                                  const ConfigMapPtr &definition) {
   if (!definition || !definition->HasKey("commit"))
-    return nullptr;
-  auto value = definition->GetValue("commit");
+    return shared_ptr<Translation>();
+  ConfigValuePtr value = definition->GetValue("commit");
   if (!value) {
     LOG(WARNING) << "unrecognized punct definition for '" << key << "'.";
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  return New<UniqueTranslation>(CreatePunctCandidate(value->str(), segment));
+  return make_shared<UniqueTranslation>(CreatePunctCandidate(value->str(), segment));
 }
 
-shared_ptr<Translation>
-PunctTranslator::TranslatePairedPunct(const std::string& key,
-                                      const Segment& segment,
-                                      const ConfigMapPtr& definition) {
+shared_ptr<Translation> PunctTranslator::TranslatePairedPunct(const std::string &key,
+                                                              const Segment &segment,
+                                                              const ConfigMapPtr &definition) {
   if (!definition || !definition->HasKey("pair"))
-    return nullptr;
-  auto list = As<ConfigList>(definition->Get("pair"));
+    return shared_ptr<Translation>();
+  ConfigListPtr list = As<ConfigList>(definition->Get("pair"));
   if (!list || list->size() != 2) {
     LOG(WARNING) << "unrecognized pair definition for '" << key << "'.";
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  auto translation = New<FifoTranslation>();
+  shared_ptr<FifoTranslation> translation(new FifoTranslation);
   for (size_t i = 0; i < list->size(); ++i) {
-    auto value = list->GetValueAt(i);
+    ConfigValuePtr value = list->GetValueAt(i);
     if (!value) {
-      LOG(WARNING) << "invalid paired punct at index " << i
-                   << " for '" << key << "'.";
+      LOG(WARNING) << "invalid paired punct at index " << i << " for '" << key << "'.";
       continue;
     }
     translation->Append(CreatePunctCandidate(value->str(), segment));
   }
   if (translation->size() != 2) {
-    LOG(WARNING) << "invalid num of candidate for paired punct '"
-                 << key << "'.";
+    LOG(WARNING) << "invalid num of candidate for paired punct '" << key << "'.";
     translation.reset();
   }
   return translation;
diff --git a/src/gear/recognizer.cc b/src/gear/recognizer.cc
index f870cf3..577646d 100644
--- a/src/gear/recognizer.cc
+++ b/src/gear/recognizer.cc
@@ -4,6 +4,7 @@
 //
 // 2012-01-01 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
 #include <rime/config.h>
@@ -15,23 +16,21 @@
 
 namespace rime {
 
-static void load_patterns(RecognizerPatterns* patterns, ConfigMapPtr map) {
-  if (!patterns || !map)
-    return;
-  for (auto it = map->begin(); it != map->end(); ++it) {
-    auto value = As<ConfigValue>(it->second);
-    if (!value)
-      continue;
+static void load_patterns(RecognizerPatterns *patterns, ConfigMapPtr map) {
+  if (!patterns || !map) return;
+  ConfigMap::Iterator it = map->begin();
+  for (; it != map->end(); ++it) {
+    ConfigValuePtr value = As<ConfigValue>(it->second);
+    if (!value) continue;
     (*patterns)[it->first] = value->str();
   }
 }
 
-void RecognizerPatterns::LoadConfig(Config* config) {
+void RecognizerPatterns::LoadConfig(Config *config) {
   ConfigMapPtr pattern_map;
   std::string preset;
   if (config->GetString("recognizer/import_preset", &preset)) {
-    unique_ptr<Config> preset_config(
-        Config::Require("config")->Create(preset));
+    scoped_ptr<Config> preset_config(Config::Require("config")->Create(preset));
     if (!preset_config) {
       LOG(ERROR) << "Error importing preset patterns '" << preset << "'.";
       return;
@@ -43,32 +42,29 @@ void RecognizerPatterns::LoadConfig(Config* config) {
   load_patterns(this, pattern_map);
 }
 
-RecognizerMatch
-RecognizerPatterns::GetMatch(const std::string& input,
-                             Segmentation* segmentation) const {
+RecognizerMatch RecognizerPatterns::GetMatch(
+    const std::string &input, Segmentation *segmentation) const {
   size_t j = segmentation->GetCurrentEndPosition();
   size_t k = segmentation->GetConfirmedPosition();
-  std::string active_input = input.substr(k);
+  std::string active_input(input.substr(k));
   DLOG(INFO) << "matching active input '" << active_input << "' at pos " << k;
-  for (const auto& v : *this) {
+  BOOST_FOREACH(const RecognizerPatterns::value_type &v, *this) {
     boost::smatch m;
     if (boost::regex_search(active_input, m, v.second)) {
       size_t start = k + m.position();
       size_t end = start + m.length();
-      if (end != input.length())
-        continue;
+      if (end != input.length()) continue;
       if (start == j) {
         DLOG(INFO) << "input [" << start << ", " << end << ") '"
                    << m.str() << "' matches pattern: " << v.first;
-        return {v.first, start, end};
+        return RecognizerMatch(v.first, start, end);
       }
-      for (const Segment& seg : *segmentation) {
-        if (start < seg.start)
-          break;
+      BOOST_FOREACH(const Segment &seg, *segmentation) {
+        if (start < seg.start) break;
         if (start == seg.start) {
           DLOG(INFO) << "input [" << start << ", " << end << ") '"
                      << m.str() << "' matches pattern: " << v.first;
-          return {v.first, start, end};
+          return RecognizerMatch(v.first, start, end);
         }
       }
     }
@@ -77,14 +73,13 @@ RecognizerPatterns::GetMatch(const std::string& input,
 }
 
 Recognizer::Recognizer(const Ticket& ticket) : Processor(ticket) {
-  if (!ticket.schema)
-    return;
-  if (Config* config = ticket.schema->config()) {
+  if (!ticket.schema) return;
+  if (Config *config = ticket.schema->config()) {
     patterns_.LoadConfig(config);
   }
 }
 
-ProcessResult Recognizer::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult Recognizer::ProcessKeyEvent(const KeyEvent &key_event) {
   if (patterns_.empty() ||
       key_event.ctrl() || key_event.alt() || key_event.release()) {
     return kNoop;
@@ -92,11 +87,11 @@ ProcessResult Recognizer::ProcessKeyEvent(const KeyEvent& key_event) {
   int ch = key_event.keycode();
   if (ch >= 0x20 && ch < 0x80) {
     // pattern matching against the input string plus the incoming character
-    Context* ctx = engine_->context();
-    std::string input = ctx->input();
+    Context *ctx = engine_->context();
+    std::string input(ctx->input());
     input += ch;
-    auto match = patterns_.GetMatch(input, ctx->composition());
-    if (match.found()) {
+    RecognizerMatch m = patterns_.GetMatch(input, ctx->composition());
+    if (m.found()) {
       ctx->PushInput(ch);
       return kAccepted;
     }
diff --git a/src/gear/reverse_lookup_filter.cc b/src/gear/reverse_lookup_filter.cc
index fb02205..604dd43 100644
--- a/src/gear/reverse_lookup_filter.cc
+++ b/src/gear/reverse_lookup_filter.cc
@@ -4,6 +4,7 @@
 //
 // 2013-11-05 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/engine.h>
 #include <rime/schema.h>
@@ -14,7 +15,10 @@
 namespace rime {
 
 ReverseLookupFilter::ReverseLookupFilter(const Ticket& ticket)
-    : Filter(ticket), TagMatching(ticket) {
+    : Filter(ticket),
+      TagMatching(ticket),
+      initialized_(false),
+      overwrite_comment_(false) {
   if (ticket.name_space == "filter") {
     name_space_ = "reverse_lookup";
   }
@@ -22,10 +26,10 @@ ReverseLookupFilter::ReverseLookupFilter(const Ticket& ticket)
 
 void ReverseLookupFilter::Initialize() {
   initialized_ = true;
-  if (!engine_)
-    return;
+  if (!engine_) return;
   Ticket ticket(engine_, name_space_);
-  if (auto c = ReverseLookupDictionary::Require("reverse_lookup_dictionary")) {
+  if (ReverseLookupDictionary::Component* c =
+      ReverseLookupDictionary::Require("reverse_lookup_dictionary")) {
     rev_dict_.reset(c->Create(ticket));
     if (rev_dict_ && !rev_dict_->Load()) {
       rev_dict_.reset();
@@ -33,20 +37,21 @@ void ReverseLookupFilter::Initialize() {
   }
   if (Config* config = engine_->schema()->config()) {
     config->GetBool(name_space_ + "/overwrite_comment", &overwrite_comment_);
-    comment_formatter_.Load(config->GetList(name_space_ + "/comment_format"));
+    comment_formatter_.Load(
+        config->GetList(name_space_ + "/comment_format"));
   }
 }
 
-void ReverseLookupFilter::Apply(CandidateList* recruited,
-                                CandidateList* candidates) {
+void ReverseLookupFilter::Apply(CandidateList *recruited,
+                                CandidateList *candidates) {
   if (!initialized_)
     Initialize();
   if (!rev_dict_)
     return;
-  for (auto& cand : *candidates) {
-    if (!overwrite_comment_ && !cand->comment().empty())
+  BOOST_FOREACH(shared_ptr<Candidate>& c, *candidates) {
+    if (!overwrite_comment_ && !c->comment().empty())
       continue;
-    auto phrase = As<Phrase>(Candidate::GetGenuineCandidate(cand));
+    shared_ptr<Phrase> phrase = As<Phrase>(Candidate::GetGenuineCandidate(c));
     if (!phrase)
       continue;
     std::string codes;
diff --git a/src/gear/reverse_lookup_translator.cc b/src/gear/reverse_lookup_translator.cc
index bf32d06..3f21670 100644
--- a/src/gear/reverse_lookup_translator.cc
+++ b/src/gear/reverse_lookup_translator.cc
@@ -19,9 +19,9 @@
 #include <rime/gear/table_translator.h>
 
 
-//static const char* quote_left = "\xef\xbc\x88";
-//static const char* quote_right = "\xef\xbc\x89";
-//static const char* separator = "\xef\xbc\x8c";
+//static const char *quote_left = "\xef\xbc\x88";
+//static const char *quote_right = "\xef\xbc\x89";
+//static const char *separator = "\xef\xbc\x8c";
 
 namespace rime {
 
@@ -32,14 +32,14 @@ class ReverseLookupTranslation : public TableTranslation {
                            const std::string& input,
                            size_t start, size_t end,
                            const std::string& preedit,
-                           const DictEntryIterator& iter,
+                           const DictEntryIterator &iter,
                            bool quality)
       : TableTranslation(options, NULL, input, start, end, preedit, iter),
         dict_(dict), options_(options), quality_(quality) {
   }
   virtual shared_ptr<Candidate> Peek();
   virtual int Compare(shared_ptr<Translation> other,
-                      const CandidateList& candidates);
+                      const CandidateList &candidates);
  protected:
   ReverseLookupDictionary* dict_;
   TranslatorOptions* options_;
@@ -48,11 +48,11 @@ class ReverseLookupTranslation : public TableTranslation {
 
 shared_ptr<Candidate> ReverseLookupTranslation::Peek() {
   if (exhausted())
-    return nullptr;
-  const auto& entry(iter_.Peek());
+    return shared_ptr<Candidate>();
+  const shared_ptr<DictEntry> &e(iter_.Peek());
   std::string tips;
   if (dict_) {
-    dict_->ReverseLookup(entry->text, &tips);
+    dict_->ReverseLookup(e->text, &tips);
     if (options_) {
       options_->comment_formatter().Apply(&tips);
     }
@@ -60,52 +60,49 @@ shared_ptr<Candidate> ReverseLookupTranslation::Peek() {
     //  boost::algorithm::replace_all(tips, " ", separator);
     //}
   }
-  shared_ptr<Candidate> cand = New<SimpleCandidate>(
+  shared_ptr<Candidate> cand = boost::make_shared<SimpleCandidate>(
       "reverse_lookup",
       start_,
       end_,
-      entry->text,
-      !tips.empty() ? tips : entry->comment,
+      e->text,
+      !tips.empty() ? (/*quote_left + */tips/* + quote_right*/) : e->comment,
       preedit_);
   return cand;
 }
 
 int ReverseLookupTranslation::Compare(shared_ptr<Translation> other,
-                                      const CandidateList& candidates) {
-  if (!other || other->exhausted())
-    return -1;
-  if (exhausted())
-    return 1;
-  auto theirs = other->Peek();
+                                      const CandidateList &candidates) {
+  if (!other || other->exhausted()) return -1;
+  if (exhausted()) return 1;
+  shared_ptr<const Candidate> theirs = other->Peek();
   if (!theirs)
     return -1;
-  if (quality_ && theirs->type() == "completion")
+  if (quality_ && theirs->type() == "completion") {
     return -1;
-  if (theirs->type() == "sentence")
+  }
+  if (theirs->type() == "sentence") {
     return -1;
+  }
   return 1;
 }
 
 ReverseLookupTranslator::ReverseLookupTranslator(const Ticket& ticket)
-    : Translator(ticket), tag_("reverse_lookup") {
+    : Translator(ticket), tag_("reverse_lookup"), initialized_(false) {
   if (ticket.name_space == "translator") {
     name_space_ = "reverse_lookup";
   }
-  if (!ticket.schema)
-    return;
+  if (!ticket.schema) return;
   Config* config = ticket.schema->config();
   config->GetString(name_space_ + "/tag", &tag_);
 }
 
 void ReverseLookupTranslator::Initialize() {
   initialized_ = true;  // no retry
-  if (!engine_)
-    return;
+  if (!engine_) return;
   Ticket ticket(engine_, name_space_);
   options_.reset(new TranslatorOptions(ticket));
-  Config* config = engine_->schema()->config();
-  if (!config)
-    return;
+  Config *config = engine_->schema()->config();
+  if (!config) return;
   config->GetString(name_space_ + "/prefix", &prefix_);
   config->GetString(name_space_ + "/suffix", &suffix_);
   config->GetString(name_space_ + "/tips", &tips_);
@@ -115,51 +112,45 @@ void ReverseLookupTranslator::Initialize() {
       options_->set_enable_completion(false);  // overridden default
   }
 
-  if (auto component = Dictionary::Require("dictionary")) {
-    dict_.reset(component->Create(ticket));
-  }
-  if (dict_) {
+  DictionaryComponent *component =
+      dynamic_cast<DictionaryComponent*>(Dictionary::Require("dictionary"));
+  if (!component) return;
+  dict_.reset(component->Create(ticket));
+  if (dict_)
     dict_->Load();
-  }
-  else {
+  else
     return;
-  }
-  auto rev_component =
+  ReverseLookupDictionary::Component *rev_component =
       ReverseLookupDictionary::Require("reverse_lookup_dictionary");
-  if (!rev_component)
-    return;
+  if (!rev_component) return;
   // lookup target defaults to "translator/dictionary"
   std::string rev_target("translator");
   config->GetString(name_space_ + "/target", &rev_target);
   Ticket rev_ticket(engine_, rev_target);
   rev_dict_.reset(rev_component->Create(rev_ticket));
-  if (rev_dict_) {
+  if (rev_dict_)
     rev_dict_->Load();
-  }
 }
 
-shared_ptr<Translation> ReverseLookupTranslator::Query(const std::string& input,
-                                                       const Segment& segment,
+shared_ptr<Translation> ReverseLookupTranslator::Query(const std::string &input,
+                                                       const Segment &segment,
                                                        std::string* prompt) {
   if (!segment.HasTag(tag_))
-    return nullptr;
-  if (!initialized_)
-    Initialize();  // load reverse dict at first use
+    return shared_ptr<Translation>();
+  if (!initialized_) Initialize();  // load reverse dict at first use
   if (!dict_ || !dict_->loaded())
-    return nullptr;
+    return shared_ptr<Translation>();
   DLOG(INFO) << "input = '" << input
              << "', [" << segment.start << ", " << segment.end << ")";
 
   const std::string& preedit(input);
 
   size_t start = 0;
-  if (!prefix_.empty() && boost::starts_with(input, prefix_)) {
+  if (!prefix_.empty() && boost::starts_with(input, prefix_))
     start = prefix_.length();
-  }
-  std::string code = input.substr(start);
-  if (!suffix_.empty() && boost::ends_with(code, suffix_)) {
+  std::string code(input.substr(start));
+  if (!suffix_.empty() && boost::ends_with(code, suffix_))
     code.resize(code.length() - suffix_.length());
-  }
 
   if (start > 0 && prompt) {
     *prompt = tips_;
@@ -171,7 +162,7 @@ shared_ptr<Translation> ReverseLookupTranslator::Query(const std::string& input,
     if (options_ && options_->enable_completion()) {
       dict_->LookupWords(&iter, code, true, 100);
       quality = !iter.exhausted() &&
-                (iter.Peek()->remaining_code_length == 0);
+          (iter.Peek()->remaining_code_length == 0);
     }
     else {
       // 2012-04-08 gongchen: fetch multi-syllable words from rev-lookup table
@@ -181,7 +172,7 @@ shared_ptr<Translation> ReverseLookupTranslator::Query(const std::string& input,
                                                        *dict_->prism(),
                                                        &graph);
       if (consumed == code.length()) {
-        auto collector = dict_->Lookup(graph, 0);
+        shared_ptr<DictEntryCollector> collector = dict_->Lookup(graph, 0);
         if (collector && !collector->empty() &&
             collector->rbegin()->first == consumed) {
           iter = collector->rbegin()->second;
@@ -192,15 +183,17 @@ shared_ptr<Translation> ReverseLookupTranslator::Query(const std::string& input,
     }
   }
   if (!iter.exhausted()) {
-    return Cached<ReverseLookupTranslation>(rev_dict_.get(),
-                                            options_.get(),
-                                            code,
-                                            segment.start,
-                                            segment.end,
-                                            preedit,
-                                            iter, quality);
+    return New<CacheTranslation>(
+        boost::make_shared<ReverseLookupTranslation>(
+            rev_dict_.get(),
+            options_.get(),
+            code,
+            segment.start,
+            segment.end,
+            preedit,
+            iter, quality));
   }
-  return nullptr;
+  return shared_ptr<Translation>();
 }
 
 }  // namespace rime
diff --git a/src/gear/schema_list_translator.cc b/src/gear/schema_list_translator.cc
index 5673599..eb54f3d 100644
--- a/src/gear/schema_list_translator.cc
+++ b/src/gear/schema_list_translator.cc
@@ -18,7 +18,7 @@ namespace rime {
 
 class SchemaSelection : public SimpleCandidate, public SwitcherCommand {
  public:
-  SchemaSelection(Schema* schema)
+  SchemaSelection(Schema *schema)
       : SimpleCandidate("schema", 0, 0, schema->schema_name()),
         SwitcherCommand(schema->schema_id()) {
   }
@@ -64,24 +64,22 @@ class SchemaListTranslation : public FifoTranslation {
     LoadSchemaList(switcher);
   }
   virtual int Compare(shared_ptr<Translation> other,
-                      const CandidateList& candidates);
+                      const CandidateList &candidates);
 
  protected:
   void LoadSchemaList(Switcher* switcher);
 };
 
 int SchemaListTranslation::Compare(shared_ptr<Translation> other,
-                                   const CandidateList& candidates) {
-  if (!other || other->exhausted())
-    return -1;
-  if (exhausted())
-    return 1;
+                                   const CandidateList &candidates) {
+  if (!other || other->exhausted()) return -1;
+  if (exhausted()) return 1;
   // switches should immediately follow current schema (#0)
-  auto theirs = other->Peek();
+  shared_ptr<Candidate> theirs = other->Peek();
   if (theirs && theirs->type() == "unfold") {
     if (cursor_ == 0) {
       // unfold its options when the current schema is selected
-      candies_[0] = New<SchemaAction>(candies_[0], theirs);
+      candies_[0] = boost::make_shared<SchemaAction>(candies_[0], theirs);
     }
     return cursor_ == 0 ? -1 : 1;
   }
@@ -91,37 +89,37 @@ int SchemaListTranslation::Compare(shared_ptr<Translation> other,
   return Translation::Compare(other, candidates);
 }
 
+static bool compare_access_time(const shared_ptr<Candidate>& a,
+                                const shared_ptr<Candidate>& b) {
+  return a->quality() > b->quality();
+}
+
 void SchemaListTranslation::LoadSchemaList(Switcher* switcher) {
   Engine* engine = switcher->attached_engine();
-  if (!engine)
-    return;
-  Config* config = switcher->schema()->config();
-  if (!config)
-    return;
-  auto schema_list = config->GetList("schema_list");
-  if (!schema_list)
-    return;
+  if (!engine) return;
+  Config *config = switcher->schema()->config();
+  if (!config) return;
+  ConfigListPtr schema_list = config->GetList("schema_list");
+  if (!schema_list) return;
   // current schema comes first
   Schema* current_schema = engine->schema();
   if (current_schema) {
-    Append(New<SchemaSelection>(current_schema));
+    Append(make_shared<SchemaSelection>(current_schema));
   }
-  Config* user_config = switcher->user_config();
   size_t fixed = candies_.size();
+  Config* user_config = switcher->user_config();
   time_t now = time(NULL);
   // load the rest schema list
   for (size_t i = 0; i < schema_list->size(); ++i) {
-    auto item = As<ConfigMap>(schema_list->GetAt(i));
-    if (!item)
-      continue;
-    auto schema_property = item->GetValue("schema");
-    if (!schema_property)
-      continue;
-    const std::string& schema_id(schema_property->str());
+    ConfigMapPtr item = As<ConfigMap>(schema_list->GetAt(i));
+    if (!item) continue;
+    ConfigValuePtr schema_property = item->GetValue("schema");
+    if (!schema_property) continue;
+    const std::string &schema_id(schema_property->str());
     if (current_schema && schema_id == current_schema->schema_id())
       continue;
     Schema schema(schema_id);
-    auto cand = New<SchemaSelection>(&schema);
+    shared_ptr<Candidate> cand = make_shared<SchemaSelection>(&schema);
     int timestamp = 0;
     if (user_config &&
         user_config->GetInt("var/schema_access_time/" + schema_id,
@@ -138,9 +136,7 @@ void SchemaListTranslation::LoadSchemaList(Switcher* switcher) {
     return;
   // reorder schema list by recency
   std::stable_sort(candies_.begin() + fixed, candies_.end(),
-      [](const shared_ptr<Candidate>& a, const shared_ptr<Candidate>& b) {
-        return a->quality() > b->quality();
-      });
+                   compare_access_time);
 }
 
 SchemaListTranslator::SchemaListTranslator(const Ticket& ticket)
@@ -150,11 +146,11 @@ SchemaListTranslator::SchemaListTranslator(const Ticket& ticket)
 shared_ptr<Translation> SchemaListTranslator::Query(const std::string& input,
                                                     const Segment& segment,
                                                     std::string* prompt) {
-  auto switcher = dynamic_cast<Switcher*>(engine_);
+  Switcher* switcher = dynamic_cast<Switcher*>(engine_);
   if (!switcher) {
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  return New<SchemaListTranslation>(switcher);
+  return make_shared<SchemaListTranslation>(switcher);
 }
 
 }  // namespace rime
diff --git a/src/gear/script_translator.cc b/src/gear/script_translator.cc
index 071d808..f9ee4ed 100644
--- a/src/gear/script_translator.cc
+++ b/src/gear/script_translator.cc
@@ -8,7 +8,8 @@
 //
 #include <algorithm>
 #include <boost/algorithm/string/join.hpp>
-#include <boost/range/adaptor/reversed.hpp>
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/foreach.hpp>
 #include <rime/composition.h>
 #include <rime/candidate.h>
 #include <rime/config.h>
@@ -23,37 +24,37 @@
 #include <rime/gear/translator_commons.h>
 
 
-//static const char* quote_left = "\xef\xbc\x88";
-//static const char* quote_right = "\xef\xbc\x89";
+//static const char *quote_left = "\xef\xbc\x88";
+//static const char *quote_right = "\xef\xbc\x89";
 
 namespace rime {
 
 namespace {
 
 struct DelimitSyllableState {
-  const std::string* input;
-  const std::string* delimiters;
-  const SyllableGraph* graph;
-  const Code* code;
+  const std::string *input;
+  const std::string *delimiters;
+  const SyllableGraph *graph;
+  const Code *code;
   size_t end_pos;
   std::string output;
 };
 
-bool DelimitSyllablesDfs(DelimitSyllableState* state,
+bool DelimitSyllablesDfs(DelimitSyllableState *state,
                          size_t current_pos, size_t depth) {
   if (depth == state->code->size()) {
     return current_pos == state->end_pos;
   }
   SyllableId syllable_id = state->code->at(depth);
-  auto z = state->graph->edges.find(current_pos);
+  EdgeMap::const_iterator z = state->graph->edges.find(current_pos);
   if (z == state->graph->edges.end())
     return false;
   // favor longer spellings
-  for (const auto& y : boost::adaptors::reverse(z->second)) {
+  BOOST_REVERSE_FOREACH(const EndVertexMap::value_type &y, z->second) {
     size_t end_vertex_pos = y.first;
     if (end_vertex_pos > state->end_pos)
       continue;
-    auto x = y.second.find(syllable_id);
+    SpellingMap::const_iterator x = y.second.find(syllable_id);
     if (x != y.second.end()) {
       size_t len = state->output.length();
       if (depth > 0 && len > 0 &&
@@ -73,19 +74,19 @@ bool DelimitSyllablesDfs(DelimitSyllableState* state,
 
 }  // anonymous namespace
 
-class ScriptTranslation
-    : public Translation,
-      public Syllabification,
-      public std::enable_shared_from_this<ScriptTranslation>
+class ScriptTranslation : public Translation,
+                          public Syllabification,
+                          public boost::enable_shared_from_this<ScriptTranslation>
 {
  public:
-  ScriptTranslation(ScriptTranslator* translator,
-                    const std::string& input, size_t start)
+  ScriptTranslation(ScriptTranslator *translator,
+                    const std::string &input, size_t start)
       : translator_(translator),
-        input_(input), start_(start) {
+        input_(input), start_(start),
+        user_phrase_index_(0) {
     set_exhausted(true);
   }
-  bool Evaluate(Dictionary* dict, UserDictionary* user_dict);
+  bool Evaluate(Dictionary *dict, UserDictionary *user_dict);
   virtual bool Next();
   virtual shared_ptr<Candidate> Peek();
   virtual size_t PreviousStop(size_t caret_pos) const;
@@ -95,13 +96,13 @@ class ScriptTranslation
   bool CheckEmpty();
   bool IsNormalSpelling() const;
   template <class CandidateT>
-  std::string GetPreeditString(const CandidateT& cand) const;
+  std::string GetPreeditString(const CandidateT &cand) const;
   template <class CandidateT>
-  std::string GetOriginalSpelling(const CandidateT& cand) const;
-  shared_ptr<Sentence> MakeSentence(Dictionary* dict,
-                                    UserDictionary* user_dict);
+  std::string GetOriginalSpelling(const CandidateT &cand) const;
+  shared_ptr<Sentence> MakeSentence(Dictionary *dict,
+                                    UserDictionary *user_dict);
 
-  ScriptTranslator* translator_;
+  ScriptTranslator *translator_;
   std::string input_;
   size_t start_;
 
@@ -112,7 +113,7 @@ class ScriptTranslation
 
   DictEntryCollector::reverse_iterator phrase_iter_;
   UserDictEntryCollector::reverse_iterator user_phrase_iter_;
-  size_t user_phrase_index_ = 0;
+  size_t user_phrase_index_;
 };
 
 // ScriptTranslator implementation
@@ -120,21 +121,22 @@ class ScriptTranslation
 ScriptTranslator::ScriptTranslator(const Ticket& ticket)
     : Translator(ticket),
       Memory(ticket),
-      TranslatorOptions(ticket) {
-  if (!engine_)
-    return;
-  if (Config* config = engine_->schema()->config()) {
+      TranslatorOptions(ticket),
+      spelling_hints_(0) {
+  if (!engine_) return;
+  Config *config = engine_->schema()->config();
+  if (config) {
     config->GetInt(name_space_ + "/spelling_hints", &spelling_hints_);
   }
 }
 
-shared_ptr<Translation> ScriptTranslator::Query(const std::string& input,
-                                                const Segment& segment,
+shared_ptr<Translation> ScriptTranslator::Query(const std::string &input,
+                                                const Segment &segment,
                                                 std::string* prompt) {
   if (!dict_ || !dict_->loaded())
-    return nullptr;
+    return shared_ptr<Translation>();
   if (!segment.HasTag(tag_))
-    return nullptr;
+    return shared_ptr<Translation>();
   DLOG(INFO) << "input = '" << input
              << "', [" << segment.start << ", " << segment.end << ")";
 
@@ -142,22 +144,23 @@ shared_ptr<Translation> ScriptTranslator::Query(const std::string& input,
       !IsUserDictDisabledFor(input);
 
   // the translator should survive translations it creates
-  auto result = New<ScriptTranslation>(this, input, segment.start);
+  shared_ptr<ScriptTranslation> result =
+      boost::make_shared<ScriptTranslation>(this, input, segment.start);
   if (!result ||
       !result->Evaluate(dict_.get(),
                         enable_user_dict ? user_dict_.get() : NULL)) {
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  return New<UniqueFilter>(result);
+  return make_shared<UniqueFilter>(result);
 }
 
 std::string ScriptTranslator::FormatPreedit(const std::string& preedit) {
-  std::string result = preedit;
+  std::string result(preedit);
   preedit_formatter_.Apply(&result);
   return result;
 }
 
-std::string ScriptTranslator::Spell(const Code& code) {
+std::string ScriptTranslator::Spell(const Code &code) {
   std::string result;
   std::vector<std::string> syllables;
   if (!dict_ || !dict_->Decode(code, &syllables) || syllables.empty())
@@ -173,7 +176,7 @@ bool ScriptTranslator::Memorize(const CommitEntry& commit_entry) {
   // avoid updating single character entries within a phrase which is
   // composed with single characters only
   if (commit_entry.elements.size() > 1) {
-    for (const DictEntry* e : commit_entry.elements) {
+    BOOST_FOREACH(const DictEntry* e, commit_entry.elements) {
       if (e->code.size() > 1) {
         update_elements = true;
         break;
@@ -181,7 +184,7 @@ bool ScriptTranslator::Memorize(const CommitEntry& commit_entry) {
     }
   }
   if (update_elements) {
-    for (const DictEntry* e : commit_entry.elements) {
+    BOOST_FOREACH(const DictEntry* e, commit_entry.elements) {
       user_dict_->UpdateEntry(*e, 0);
     }
   }
@@ -191,7 +194,7 @@ bool ScriptTranslator::Memorize(const CommitEntry& commit_entry) {
 
 // ScriptTranslation implementation
 
-bool ScriptTranslation::Evaluate(Dictionary* dict, UserDictionary* user_dict) {
+bool ScriptTranslation::Evaluate(Dictionary *dict, UserDictionary *user_dict) {
   Syllabifier syllabifier(translator_->delimiters(),
                           translator_->enable_completion(),
                           translator_->strict_spelling());
@@ -216,23 +219,22 @@ bool ScriptTranslation::Evaluate(Dictionary* dict, UserDictionary* user_dict) {
     sentence_ = MakeSentence(dict, user_dict);
   }
 
-  if (phrase_)
-    phrase_iter_ = phrase_->rbegin();
-  if (user_phrase_)
-    user_phrase_iter_ = user_phrase_->rbegin();
+  if (phrase_) phrase_iter_ = phrase_->rbegin();
+  if (user_phrase_) user_phrase_iter_ = user_phrase_->rbegin();
   return !CheckEmpty();
 }
 
 template <class CandidateT>
-std::string
-ScriptTranslation::GetPreeditString(const CandidateT& cand) const {
+std::string ScriptTranslation::GetPreeditString(
+    const CandidateT &cand) const {
   DelimitSyllableState state;
   state.input = &input_;
   state.delimiters = &translator_->delimiters();
   state.graph = &syllable_graph_;
   state.code = &cand.code();
   state.end_pos = cand.end() - start_;
-  if (bool success = DelimitSyllablesDfs(&state, cand.start() - start_, 0)) {
+  bool success = DelimitSyllablesDfs(&state, cand.start() - start_, 0);
+  if (success) {
     return translator_->FormatPreedit(state.output);
   }
   else {
@@ -241,8 +243,8 @@ ScriptTranslation::GetPreeditString(const CandidateT& cand) const {
 }
 
 template <class CandidateT>
-std::string
-ScriptTranslation::GetOriginalSpelling(const CandidateT& cand) const {
+std::string ScriptTranslation::GetOriginalSpelling(
+    const CandidateT& cand) const {
   if (translator_ &&
       static_cast<int>(cand.code().size()) <= translator_->spelling_hints()) {
     return translator_->Spell(cand.code());
@@ -267,14 +269,14 @@ bool ScriptTranslation::Next() {
   }
   if (user_phrase_code_length > 0 &&
       user_phrase_code_length >= phrase_code_length) {
-    DictEntryList& entries(user_phrase_iter_->second);
+    DictEntryList &entries(user_phrase_iter_->second);
     if (++user_phrase_index_ >= entries.size()) {
       ++user_phrase_iter_;
       user_phrase_index_ = 0;
     }
   }
   else if (phrase_code_length > 0) {
-    DictEntryIterator& iter(phrase_iter_->second);
+    DictEntryIterator &iter(phrase_iter_->second);
     if (!iter.Next()) {
       ++phrase_iter_;
     }
@@ -289,7 +291,7 @@ bool ScriptTranslation::IsNormalSpelling() const {
 
 shared_ptr<Candidate> ScriptTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   if (sentence_) {
     if (sentence_->preedit().empty()) {
       sentence_->set_preedit(GetPreeditString(*sentence_));
@@ -314,30 +316,30 @@ shared_ptr<Candidate> ScriptTranslation::Peek() {
   shared_ptr<Phrase> cand;
   if (user_phrase_code_length > 0 &&
       user_phrase_code_length >= phrase_code_length) {
-    DictEntryList& entries(user_phrase_iter_->second);
-    const auto& entry(entries[user_phrase_index_]);
-    DLOG(INFO) << "user phrase '" << entry->text
+    DictEntryList &entries(user_phrase_iter_->second);
+    const shared_ptr<DictEntry> &e(entries[user_phrase_index_]);
+    DLOG(INFO) << "user phrase '" << e->text
                << "', code length: " << user_phrase_code_length;
-    cand = New<Phrase>(translator_->language(),
-                       "phrase",
-                       start_,
-                       start_ + user_phrase_code_length,
-                       entry);
-    cand->set_quality(entry->weight +
+    cand = make_shared<Phrase>(translator_->language(),
+                               "phrase",
+                               start_,
+                               start_ + user_phrase_code_length,
+                               e);
+    cand->set_quality(e->weight +
                       translator_->initial_quality() +
                       (IsNormalSpelling() ? 0.5 : -0.5));
   }
   else if (phrase_code_length > 0) {
-    DictEntryIterator& iter(phrase_iter_->second);
-    const auto& entry(iter.Peek());
-    DLOG(INFO) << "phrase '" << entry->text
+    DictEntryIterator &iter(phrase_iter_->second);
+    const shared_ptr<DictEntry> &e(iter.Peek());
+    DLOG(INFO) << "phrase '" << e->text
                << "', code length: " << user_phrase_code_length;
-    cand = New<Phrase>(translator_->language(),
-                       "phrase",
-                       start_,
-                       start_ + phrase_code_length,
-                       entry);
-    cand->set_quality(entry->weight +
+    cand = make_shared<Phrase>(translator_->language(),
+                               "phrase",
+                               start_,
+                               start_ + phrase_code_length,
+                               e);
+    cand->set_quality(e->weight +
                       translator_->initial_quality() +
                       (IsNormalSpelling() ? 0 : -1));
   }
@@ -345,8 +347,9 @@ shared_ptr<Candidate> ScriptTranslation::Peek() {
     cand->set_preedit(GetPreeditString(*cand));
   }
   if (cand->comment().empty()) {
-    std::string spelling = GetOriginalSpelling(*cand);
-    if (!spelling.empty() && spelling != cand->preedit()) {
+    std::string spelling(GetOriginalSpelling(*cand));
+    if (!spelling.empty() &&
+        spelling != cand->preedit()) {
       cand->set_comment(/*quote_left + */spelling/* + quote_right*/);
     }
   }
@@ -360,38 +363,42 @@ bool ScriptTranslation::CheckEmpty() {
   return exhausted();
 }
 
-shared_ptr<Sentence>
-ScriptTranslation::MakeSentence(Dictionary* dict, UserDictionary* user_dict) {
+shared_ptr<Sentence> ScriptTranslation::MakeSentence(
+    Dictionary *dict, UserDictionary *user_dict) {
   const int kMaxSyllablesForUserPhraseQuery = 5;
   const double kPenaltyForAmbiguousSyllable = 1e-10;
   WordGraph graph;
-  for (const auto& x : syllable_graph_.edges) {
+  BOOST_FOREACH(const EdgeMap::value_type &s, syllable_graph_.edges) {
     // discourage starting a word from an ambiguous joint
     // bad cases include pinyin syllabification "niju'ede"
     double credibility = 1.0;
-    if (syllable_graph_.vertices[x.first] >= kAmbiguousSpelling)
+    if (syllable_graph_.vertices[s.first] >= kAmbiguousSpelling)
       credibility = kPenaltyForAmbiguousSyllable;
-    UserDictEntryCollector& dest(graph[x.first]);
+    shared_ptr<UserDictEntryCollector> user_phrase;
     if (user_dict) {
-      auto user_phrase = user_dict->Lookup(syllable_graph_, x.first,
-                                           kMaxSyllablesForUserPhraseQuery,
-                                           credibility);
-      if (user_phrase)
-        dest.swap(*user_phrase);
+      user_phrase = user_dict->Lookup(syllable_graph_, s.first,
+                                      kMaxSyllablesForUserPhraseQuery,
+                                      credibility);
     }
-    if (auto phrase = dict->Lookup(syllable_graph_, x.first, credibility)) {
+    UserDictEntryCollector &u(graph[s.first]);
+    if (user_phrase)
+      u.swap(*user_phrase);
+    shared_ptr<DictEntryCollector> phrase =
+        dict->Lookup(syllable_graph_, s.first, credibility);
+    if (phrase) {
       // merge lookup results
-      for (auto& y : *phrase) {
-        DictEntryList& entries(dest[y.first]);
+      BOOST_FOREACH(DictEntryCollector::value_type &t, *phrase) {
+        DictEntryList &entries(u[t.first]);
         if (entries.empty()) {
-          entries.push_back(y.second.Peek());
+          shared_ptr<DictEntry> e(t.second.Peek());
+          entries.push_back(e);
         }
       }
     }
   }
   Poet poet(translator_->language());
-  auto sentence = poet.MakeSentence(graph,
-                                    syllable_graph_.interpreted_length);
+  shared_ptr<Sentence> sentence =
+      poet.MakeSentence(graph, syllable_graph_.interpreted_length);
   if (sentence) {
     sentence->Offset(start_);
     sentence->set_syllabification(shared_from_this());
@@ -401,7 +408,8 @@ ScriptTranslation::MakeSentence(Dictionary* dict, UserDictionary* user_dict) {
 
 size_t ScriptTranslation::PreviousStop(size_t caret_pos) const {
   size_t offset = caret_pos - start_;
-  for (const auto& x : boost::adaptors::reverse(syllable_graph_.vertices)) {
+  BOOST_REVERSE_FOREACH(const VertexMap::value_type& x,
+                        syllable_graph_.vertices) {
     if (x.first < offset)
       return x.first + start_;
   }
@@ -410,7 +418,7 @@ size_t ScriptTranslation::PreviousStop(size_t caret_pos) const {
 
 size_t ScriptTranslation::NextStop(size_t caret_pos) const {
   size_t offset = caret_pos - start_;
-  for (const auto& x : syllable_graph_.vertices) {
+  BOOST_FOREACH(const VertexMap::value_type& x, syllable_graph_.vertices) {
     if (x.first > offset)
       return x.first + start_;
   }
diff --git a/src/gear/selector.cc b/src/gear/selector.cc
index a1900ae..b0b5226 100644
--- a/src/gear/selector.cc
+++ b/src/gear/selector.cc
@@ -19,13 +19,13 @@ namespace rime {
 Selector::Selector(const Ticket& ticket) : Processor(ticket) {
 }
 
-ProcessResult Selector::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult Selector::ProcessKeyEvent(const KeyEvent &key_event) {
   if (key_event.release())
     return kNoop;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   if (!ctx->composition() || ctx->composition()->empty())
     return kNoop;
-  Segment& current_segment(ctx->composition()->back());
+  Segment &current_segment(ctx->composition()->back());
   if (!current_segment.menu || current_segment.HasTag("raw"))
     return kNoop;
   int ch = key_event.keycode();
@@ -73,8 +73,8 @@ ProcessResult Selector::ProcessKeyEvent(const KeyEvent& key_event) {
   return kNoop;
 }
 
-bool Selector::PageUp(Context* ctx) {
-  Composition* comp = ctx->composition();
+bool Selector::PageUp(Context *ctx) {
+  Composition *comp = ctx->composition();
   if (comp->empty())
     return false;
   int page_size = engine_->schema()->page_size();
@@ -85,8 +85,8 @@ bool Selector::PageUp(Context* ctx) {
   return true;
 }
 
-bool Selector::PageDown(Context* ctx) {
-  Composition* comp = ctx->composition();
+bool Selector::PageDown(Context *ctx) {
+  Composition *comp = ctx->composition();
   if (comp->empty() || !comp->back().menu)
     return false;
   int page_size = engine_->schema()->page_size();
@@ -103,8 +103,8 @@ bool Selector::PageDown(Context* ctx) {
 
 }
 
-bool Selector::CursorUp(Context* ctx) {
-  Composition* comp = ctx->composition();
+bool Selector::CursorUp(Context *ctx) {
+  Composition *comp = ctx->composition();
   if (comp->empty())
     return false;
   int index = comp->back().selected_index;
@@ -115,8 +115,8 @@ bool Selector::CursorUp(Context* ctx) {
   return true;
 }
 
-bool Selector::CursorDown(Context* ctx) {
-  Composition* comp = ctx->composition();
+bool Selector::CursorDown(Context *ctx) {
+  Composition *comp = ctx->composition();
   if (comp->empty() || !comp->back().menu)
     return false;
   int index = comp->back().selected_index + 1;
@@ -128,10 +128,10 @@ bool Selector::CursorDown(Context* ctx) {
   return true;
 }
 
-bool Selector::Home(Context* ctx) {
+bool Selector::Home(Context *ctx) {
   if (ctx->composition()->empty())
     return false;
-  Segment& seg(ctx->composition()->back());
+  Segment &seg(ctx->composition()->back());
   if (seg.selected_index > 0) {
     seg.selected_index = 0;
     return true;
@@ -139,7 +139,7 @@ bool Selector::Home(Context* ctx) {
   return false;
 }
 
-bool Selector::End(Context* ctx) {
+bool Selector::End(Context *ctx) {
   if (ctx->caret_pos() < ctx->input().length()) {
     // navigator should handle this
     return false;
@@ -149,8 +149,8 @@ bool Selector::End(Context* ctx) {
 }
 
 
-bool Selector::SelectCandidateAt(Context* ctx, int index) {
-  Composition* comp = ctx->composition();
+bool Selector::SelectCandidateAt(Context *ctx, int index) {
+  Composition *comp = ctx->composition();
   if (comp->empty())
     return false;
   int page_size = engine_->schema()->page_size();
diff --git a/src/gear/shape.cc b/src/gear/shape.cc
index 7150637..2fa57bd 100644
--- a/src/gear/shape.cc
+++ b/src/gear/shape.cc
@@ -6,6 +6,7 @@
 //
 #include <sstream>
 #include <boost/algorithm/string.hpp>
+#include <boost/foreach.hpp>
 #include <rime/context.h>
 #include <rime/engine.h>
 #include <rime/key_event.h>
@@ -21,7 +22,7 @@ void ShapeFormatter::Format(std::string* text) {
     return;
   }
   std::ostringstream oss;
-  for (char ch : *text) {
+  BOOST_FOREACH(char ch, *text) {
     if (ch == 0x20) {
       oss << "\xe3\x80\x80";
     }
@@ -36,7 +37,7 @@ void ShapeFormatter::Format(std::string* text) {
   *text = oss.str();
 }
 
-ProcessResult ShapeProcessor::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult ShapeProcessor::ProcessKeyEvent(const KeyEvent &key_event) {
   DLOG(INFO) << "shape_processor: " << key_event;
   if (!engine_->context()->get_option("full_shape")) {
     return kNoop;
diff --git a/src/gear/simplifier.cc b/src/gear/simplifier.cc
index 6bb8524..50dee70 100644
--- a/src/gear/simplifier.cc
+++ b/src/gear/simplifier.cc
@@ -8,6 +8,7 @@
 #include <vector>
 #include <boost/algorithm/string.hpp>
 #include <boost/filesystem.hpp>
+#include <boost/scoped_array.hpp>
 #include <opencc/opencc.h>
 #include <stdint.h>
 #include <utf8.h>
@@ -20,24 +21,24 @@
 #include <rime/service.h>
 #include <rime/gear/simplifier.h>
 
-static const char* quote_left = "\xe3\x80\x94";  //"\xef\xbc\x88";
-static const char* quote_right = "\xe3\x80\x95";  //"\xef\xbc\x89";
+static const char *quote_left = "\xe3\x80\x94";  //"\xef\xbc\x88";
+static const char *quote_right = "\xe3\x80\x95";  //"\xef\xbc\x89";
 
 namespace rime {
 
 class Opencc {
  public:
-  Opencc(const std::string& config_path);
+  Opencc(const std::string &config_path);
   ~Opencc();
-  bool ConvertText(const std::string& text,
-                   std::string* simplified,
-                   bool* is_single_char);
+  bool ConvertText(const std::string &text,
+                   std::string *simplified,
+                   bool *is_single_char);
 
  private:
   opencc_t od_;
 };
 
-Opencc::Opencc(const std::string& config_path) {
+Opencc::Opencc(const std::string &config_path) {
   LOG(INFO) << "initilizing opencc: " << config_path;
   od_ = opencc_open(config_path.c_str());
   if (od_ == (opencc_t) -1) {
@@ -51,21 +52,21 @@ Opencc::~Opencc() {
   }
 }
 
-bool Opencc::ConvertText(const std::string& text,
-                         std::string* simplified,
-                         bool* is_single_char) {
+bool Opencc::ConvertText(const std::string &text,
+                         std::string *simplified,
+                         bool *is_single_char) {
   if (od_ == (opencc_t) -1)
     return false;
-  unique_ptr<uint32_t[]> inbuf(new uint32_t[text.length() + 1]);
-  uint32_t* end = utf8::unchecked::utf8to32(text.c_str(),
+  boost::scoped_array<uint32_t> inbuf(new uint32_t[text.length() + 1]);
+  uint32_t *end = utf8::unchecked::utf8to32(text.c_str(),
                                             text.c_str() + text.length(),
                                             inbuf.get());
   *end = L'\0';
   size_t inlen = end - inbuf.get();
-  uint32_t* inptr = inbuf.get();
+  uint32_t *inptr = inbuf.get();
   size_t outlen = inlen * 5;
-  unique_ptr<uint32_t[]> outbuf(new uint32_t[outlen + 1]);
-  uint32_t* outptr = outbuf.get();
+  boost::scoped_array<uint32_t> outbuf(new uint32_t[outlen + 1]);
+  uint32_t *outptr = outbuf.get();
   if (inlen == 1) {
     *is_single_char = true;
     opencc_set_conversion_mode(od_, OPENCC_CONVERSION_LIST_CANDIDATES);
@@ -80,8 +81,8 @@ bool Opencc::ConvertText(const std::string& text,
     return false;
   }
   *outptr = L'\0';
-  unique_ptr<char[]> out_utf8(new char[(outptr - outbuf.get()) * 6 + 1]);
-  char* utf8_end = utf8::unchecked::utf32to8(outbuf.get(),
+  boost::scoped_array<char> out_utf8(new char[(outptr - outbuf.get()) * 6 + 1]);
+  char *utf8_end = utf8::unchecked::utf32to8(outbuf.get(),
                                              outptr,
                                              out_utf8.get());
   *utf8_end = '\0';
@@ -92,24 +93,29 @@ bool Opencc::ConvertText(const std::string& text,
 // Simplifier
 
 Simplifier::Simplifier(const Ticket& ticket) : Filter(ticket),
-                                               TagMatching(ticket) {
+                                               TagMatching(ticket),
+                                               initialized_(false),
+                                               tips_level_(kTipsNone) {
   if (name_space_ == "filter") {
     name_space_ = "simplifier";
   }
-  if (Config* config = engine_->schema()->config()) {
+  Config *config = engine_->schema()->config();
+  if (config) {
     std::string tips;
     if (config->GetString(name_space_ + "/tips", &tips) ||
         config->GetString(name_space_ + "/tip", &tips)) {
-      tips_level_ = (tips == "all") ? kTipsAll :
-                    (tips == "char") ? kTipsChar : kTipsNone;
+      tips_level_ =
+          (tips == "all") ? kTipsAll :
+          (tips == "char") ? kTipsChar : kTipsNone;
     }
     config->GetString(name_space_ + "/option_name", &option_name_);
     config->GetString(name_space_ + "/opencc_config", &opencc_config_);
-    if (auto types = config->GetList(name_space_ + "/excluded_types")) {
-      for (auto it = types->begin(); it != types->end(); ++it) {
-        if (auto value = As<ConfigValue>(*it)) {
-          excluded_types_.insert(value->str());
-        }
+    ConfigListPtr types = config->GetList(name_space_ + "/excluded_types");
+    if (types) {
+      for (ConfigList::Iterator it = types->begin(); it != types->end(); ++it) {
+        ConfigValuePtr value = As<ConfigValue>(*it);
+        if (!value) continue;
+        excluded_types_.insert(value->str());
       }
     }
   }
@@ -122,42 +128,43 @@ Simplifier::Simplifier(const Ticket& ticket) : Filter(ticket),
 }
 
 void Simplifier::Initialize() {
-  using namespace boost::filesystem;
   initialized_ = true;  // no retry
-  path opencc_config_path = opencc_config_;
+  boost::filesystem::path opencc_config_path = opencc_config_;
   if (opencc_config_path.is_relative()) {
-    path user_config_path = Service::instance().deployer().user_data_dir;
-    path shared_config_path = Service::instance().deployer().shared_data_dir;
+    boost::filesystem::path user_config_path =
+        Service::instance().deployer().user_data_dir;
+    boost::filesystem::path shared_config_path =
+        Service::instance().deployer().shared_data_dir;
     (user_config_path /= "opencc") /= opencc_config_path;
     (shared_config_path /= "opencc") /= opencc_config_path;
-    if (exists(user_config_path)) {
+    if (boost::filesystem::exists(user_config_path)) {
       opencc_config_path = user_config_path;
     }
-    else if (exists(shared_config_path)) {
+    else if (boost::filesystem::exists(shared_config_path)) {
       opencc_config_path = shared_config_path;
     }
   }
   opencc_.reset(new Opencc(opencc_config_path.string()));
 }
 
-void Simplifier::Apply(CandidateList* recruited,
-                       CandidateList* candidates) {
+void Simplifier::Apply(CandidateList *recruited,
+                       CandidateList *candidates) {
   if (!engine_->context()->get_option(option_name_))  // off
     return;
-  if (!initialized_)
-    Initialize();
+  if (!initialized_) Initialize();
   if (!opencc_ || !candidates || candidates->empty())
     return;
   CandidateList result;
-  for (auto it = candidates->begin(); it != candidates->end(); ++it) {
+  for (CandidateList::iterator it = candidates->begin();
+       it != candidates->end(); ++it) {
     if (!Convert(*it, &result))
       result.push_back(*it);
   }
   candidates->swap(result);
 }
 
-bool Simplifier::Convert(const shared_ptr<Candidate>& original,
-                         CandidateList* result) {
+bool Simplifier::Convert(const shared_ptr<Candidate> &original,
+                         CandidateList *result) {
   if (excluded_types_.find(original->type()) != excluded_types_.end()) {
     return false;
   }
@@ -180,7 +187,7 @@ bool Simplifier::Convert(const shared_ptr<Candidate>& original,
           tips = quote_left + original->text() + quote_right;
         }
         result->push_back(
-            New<ShadowCandidate>(
+            boost::make_shared<ShadowCandidate>(
                 original,
                 "simplified",
                 forms[i],
@@ -194,7 +201,7 @@ bool Simplifier::Convert(const shared_ptr<Candidate>& original,
       tips = quote_left + original->text() + quote_right;
     }
     result->push_back(
-        New<ShadowCandidate>(
+        boost::make_shared<ShadowCandidate>(
             original,
             "simplified",
             simplified,
diff --git a/src/gear/speller.cc b/src/gear/speller.cc
index 97fde41..2156a15 100644
--- a/src/gear/speller.cc
+++ b/src/gear/speller.cc
@@ -56,12 +56,16 @@ static bool expecting_an_initial(Context* ctx,
   const std::string& input(ctx->input());
   char previous_char = input[caret_pos - 1];
   return belongs_to(previous_char, finals) ||
-         !belongs_to(previous_char, alphabet);
+      !belongs_to(previous_char, alphabet);
 }
 
 Speller::Speller(const Ticket& ticket) : Processor(ticket),
-                                         alphabet_(kRimeAlphabet) {
-  if (Config* config = engine_->schema()->config()) {
+                                         alphabet_(kRimeAlphabet),
+                                         max_code_length_(0),
+                                         auto_select_(false),
+                                         use_space_(false) {
+  Config *config = engine_->schema()->config();
+  if (config) {
     config->GetString("speller/alphabet", &alphabet_);
     config->GetString("speller/delimiter", &delimiters_);
     config->GetString("speller/initials", &initials_);
@@ -74,12 +78,10 @@ Speller::Speller(const Ticket& ticket) : Processor(ticket),
       auto_select_pattern_ = pattern;
     }
   }
-  if (initials_.empty()) {
-    initials_ = alphabet_;
-  }
+  if (initials_.empty()) initials_ = alphabet_;
 }
 
-ProcessResult Speller::ProcessKeyEvent(const KeyEvent& key_event) {
+ProcessResult Speller::ProcessKeyEvent(const KeyEvent &key_event) {
   if (key_event.release() || key_event.ctrl() || key_event.alt())
     return kNoop;
   int ch = key_event.keycode();
@@ -89,7 +91,7 @@ ProcessResult Speller::ProcessKeyEvent(const KeyEvent& key_event) {
     return kNoop;
   if (!belongs_to(ch, alphabet_) && !belongs_to(ch, delimiters_))
     return kNoop;
-  Context* ctx = engine_->context();
+  Context *ctx = engine_->context();
   bool is_initial = belongs_to(ch, initials_);
   if (!is_initial &&
       expecting_an_initial(ctx, alphabet_, finals_)) {
@@ -129,7 +131,7 @@ bool Speller::AutoSelectAtMaxCodeLength(Context* ctx) {
   if (!ctx->HasMenu())
     return false;
   const Segment& seg(ctx->composition()->back());
-  auto cand = seg.GetSelectedCandidate();
+  shared_ptr<Candidate> cand = seg.GetSelectedCandidate();
   if (cand &&
       reached_max_code_length(cand, max_code_length_) &&
       is_auto_selectable(cand, ctx->input(), delimiters_)) {
@@ -149,7 +151,7 @@ bool Speller::AutoSelectUniqueCandidate(Context* ctx) {
   if (!unique_candidate)
     return false;
   const std::string& input(ctx->input());
-  auto cand = seg.GetSelectedCandidate();
+  shared_ptr<Candidate> cand = seg.GetSelectedCandidate();
   bool matches_input_pattern = false;
   if (auto_select_pattern_.empty()) {
     matches_input_pattern =
@@ -184,7 +186,7 @@ bool Speller::AutoSelectPreviousMatch(Context* ctx,
                          converted, delimiters_)) {
     // reuse previous match
     ctx->composition()->pop_back();
-    ctx->composition()->push_back(std::move(*previous_segment));
+    ctx->composition()->push_back(*previous_segment);
     ctx->ConfirmCurrentSelection();
     if (ctx->get_option("_auto_commit")) {
       ctx->set_input(converted);
diff --git a/src/gear/switch_translator.cc b/src/gear/switch_translator.cc
index 0126cfe..3b5ef97 100644
--- a/src/gear/switch_translator.cc
+++ b/src/gear/switch_translator.cc
@@ -5,6 +5,8 @@
 // 2013-05-26 GONG Chen <chen.sst@gmail.com>
 //
 #include <vector>
+#include <boost/enable_shared_from_this.hpp>
+#include <boost/foreach.hpp>
 #include <utf8.h>
 #include <rime/candidate.h>
 #include <rime/common.h>
@@ -23,9 +25,9 @@ namespace rime {
 
 class Switch : public SimpleCandidate, public SwitcherCommand {
  public:
-  Switch(const std::string& current_state_label,
-         const std::string& next_state_label,
-         const std::string& option_name,
+  Switch(const std::string &current_state_label,
+         const std::string &next_state_label,
+         const std::string &option_name,
          bool current_state,
          bool auto_save)
       : SimpleCandidate("switch", 0, 0,
@@ -55,7 +57,7 @@ void Switch::Apply(Switcher* switcher) {
 
 class RadioOption;
 
-class RadioGroup : public std::enable_shared_from_this<RadioGroup> {
+class RadioGroup : public boost::enable_shared_from_this<RadioGroup> {
  public:
   RadioGroup(Context* context, Switcher* switcher)
       : context_(context), switcher_(switcher) {
@@ -74,11 +76,11 @@ class RadioGroup : public std::enable_shared_from_this<RadioGroup> {
 class RadioOption : public SimpleCandidate, public SwitcherCommand {
  public:
   RadioOption(shared_ptr<RadioGroup> group,
-              const std::string& state_label,
-              const std::string& option_name)
+              const std::string &state_label,
+              const std::string &option_name)
       : SimpleCandidate("switch", 0, 0, state_label),
         SwitcherCommand(option_name),
-        group_(group) {
+        group_(group), selected_(false) {
   }
   virtual void Apply(Switcher* switcher);
   void UpdateState(bool selected);
@@ -86,7 +88,7 @@ class RadioOption : public SimpleCandidate, public SwitcherCommand {
 
  protected:
   shared_ptr<RadioGroup> group_;
-  bool selected_ = false;
+  bool selected_;
 };
 
 void RadioOption::Apply(Switcher* switcher) {
@@ -99,21 +101,19 @@ void RadioOption::UpdateState(bool selected) {
   set_comment(selected ? kRadioSelected : "");
 }
 
-shared_ptr<RadioOption>
-RadioGroup::CreateOption(const std::string& state_label,
-                         const std::string& option_name) {
-  auto option = New<RadioOption>(shared_from_this(),
-                                 state_label,
-                                 option_name);
+shared_ptr<RadioOption> RadioGroup::CreateOption(const std::string& state_label,
+                                                 const std::string& option_name) {
+  shared_ptr<RadioOption> option = boost::make_shared<RadioOption>(
+      shared_from_this(), state_label, option_name);
   options_.push_back(option.get());
   return option;
 }
 
 void RadioGroup::SelectOption(RadioOption* option) {
-  if (!option)
-    return;
+  if (!option) return;
   Config* user_config = switcher_->user_config();
-  for (auto it = options_.begin(); it != options_.end(); ++it) {
+  for (std::vector<RadioOption*>::iterator it = options_.begin();
+       it != options_.end(); ++it) {
     bool selected = (*it == option);
     (*it)->UpdateState(selected);
     const std::string& option_name((*it)->keyword());
@@ -129,7 +129,8 @@ void RadioGroup::SelectOption(RadioOption* option) {
 RadioOption* RadioGroup::GetSelectedOption() const {
   if (options_.empty())
     return NULL;
-  for (auto it = options_.begin(); it != options_.end(); ++it) {
+  for (std::vector<RadioOption*>::const_iterator it = options_.begin();
+       it != options_.end(); ++it) {
     if (context_->get_option((*it)->keyword()))
       return *it;
   }
@@ -140,7 +141,9 @@ class FoldedOptions : public SimpleCandidate, public SwitcherCommand {
  public:
   FoldedOptions(Config* config)
       : SimpleCandidate("unfold", 0, 0, ""),
-        SwitcherCommand("_fold_options") {
+        SwitcherCommand("_fold_options"),
+        separator_(" "),
+        abbreviate_options_(false) {
     LoadConfig(config);
   }
   virtual void Apply(Switcher* switcher);
@@ -157,8 +160,8 @@ class FoldedOptions : public SimpleCandidate, public SwitcherCommand {
 
   std::string prefix_;
   std::string suffix_;
-  std::string separator_ = " ";
-  bool abbreviate_options_ = false;
+  std::string separator_;
+  bool abbreviate_options_;
 
   std::vector<std::string> labels_;
 };
@@ -193,7 +196,7 @@ static std::string FirstCharOf(const std::string& str) {
 void FoldedOptions::Finish() {
   text_ = prefix_;
   bool first = true;
-  for (const auto& label : labels_) {
+  BOOST_FOREACH(const std::string& label, labels_) {
     if (first) {
       first = false;
     }
@@ -216,54 +219,46 @@ class SwitchTranslation : public FifoTranslation {
 
 void SwitchTranslation::LoadSwitches(Switcher* switcher) {
   Engine* engine = switcher->attached_engine();
-  if (!engine)
-    return;
-  Config* config = engine->schema()->config();
-  if (!config)
-    return;
-  auto switches = config->GetList("switches");
-  if (!switches)
-    return;
-  Context* context = engine->context();
+  if (!engine) return;
+  Config *config = engine->schema()->config();
+  if (!config) return;
+  ConfigListPtr switches = config->GetList("switches");
+  if (!switches) return;
+  Context *context = engine->context();
   for (size_t i = 0; i < switches->size(); ++i) {
-    auto item = As<ConfigMap>(switches->GetAt(i));
-    if (!item)
-      continue;
-    auto states = As<ConfigList>(item->Get("states"));
-    if (!states)
-      continue;
-    if (auto option_name = item->GetValue("name")) {
+    ConfigMapPtr item = As<ConfigMap>(switches->GetAt(i));
+    if (!item) continue;
+    ConfigListPtr states = As<ConfigList>(item->Get("states"));
+    if (!states) continue;
+    if (ConfigValuePtr option_name = item->GetValue("name")) {
       // toggle
-      if (states->size() != 2)
-        continue;
+      if (states->size() != 2) continue;
       bool current_state = context->get_option(option_name->str());
-      Append(New<Switch>(
+      Append(boost::make_shared<Switch>(
           states->GetValueAt(current_state)->str(),
           states->GetValueAt(1 - current_state)->str(),
           option_name->str(),
           current_state,
           switcher->IsAutoSave(option_name->str())));
     }
-    else if (auto options = As<ConfigList>(item->Get("options"))) {
+    else if (ConfigListPtr options = As<ConfigList>(item->Get("options"))) {
       // radio
-      if (states->size() < 2)
-        continue;
-      if (states->size() != options->size())
-        continue;
-      auto group = New<RadioGroup>(context, switcher);
+      if (states->size() < 2) continue;
+      if (states->size() != options->size()) continue;
+      shared_ptr<RadioGroup> group = make_shared<RadioGroup>(context, switcher);
       for (size_t i = 0; i < options->size(); ++i) {
-        auto option_name = options->GetValueAt(i);
-        auto state_label = states->GetValueAt(i);
-        if (!option_name || !state_label)
-          continue;
+        ConfigValuePtr option_name = options->GetValueAt(i);
+        ConfigValuePtr state_label = states->GetValueAt(i);
+        if (!option_name || !state_label) continue;
         Append(group->CreateOption(state_label->str(), option_name->str()));
       }
       group->SelectOption(group->GetSelectedOption());
     }
   }
   if (switcher->context()->get_option("_fold_options")) {
-    auto folded_options = New<FoldedOptions>(switcher->schema()->config());
-    for (auto x : candies_) {
+    shared_ptr<FoldedOptions> folded_options =
+        New<FoldedOptions>(switcher->schema()->config());
+    BOOST_FOREACH(shared_ptr<Candidate> x, candies_) {
       if (Is<Switch>(x) ||
           (Is<RadioOption>(x) && As<RadioOption>(x)->selected())) {
         folded_options->Append(x->text());
@@ -282,15 +277,14 @@ SwitchTranslator::SwitchTranslator(const Ticket& ticket)
     : Translator(ticket) {
 }
 
-shared_ptr<Translation>
-SwitchTranslator::Query(const std::string& input,
-                        const Segment& segment,
-                        std::string* prompt) {
-  auto switcher = dynamic_cast<Switcher*>(engine_);
+shared_ptr<Translation> SwitchTranslator::Query(const std::string& input,
+                                                const Segment& segment,
+                                                std::string* prompt) {
+  Switcher* switcher = dynamic_cast<Switcher*>(engine_);
   if (!switcher) {
-    return nullptr;
+    return shared_ptr<Translation>();
   }
-  return New<SwitchTranslation>(switcher);
+  return make_shared<SwitchTranslation>(switcher);
 }
 
 }  // namespace rime
diff --git a/src/gear/table_translator.cc b/src/gear/table_translator.cc
index 7cee82f..9248365 100644
--- a/src/gear/table_translator.cc
+++ b/src/gear/table_translator.cc
@@ -5,7 +5,7 @@
 // 2011-07-10 GONG Chen <chen.sst@gmail.com>
 //
 #include <boost/algorithm/string.hpp>
-#include <boost/range/adaptor/reversed.hpp>
+#include <boost/foreach.hpp>
 #include <utf8.h>
 #include <rime/candidate.h>
 #include <rime/composition.h>
@@ -75,14 +75,14 @@ static bool is_constructed(const DictEntry* e) {
 
 shared_ptr<Candidate> TableTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   bool is_user_phrase = PreferUserPhrase();
-  auto e = PreferedEntry(is_user_phrase);
+  shared_ptr<DictEntry> e = PreferedEntry(is_user_phrase);
   std::string comment(is_constructed(e.get()) ? kUnitySymbol : e->comment);
   if (options_) {
     options_->comment_formatter().Apply(&comment);
   }
-  auto phrase = New<Phrase>(
+  shared_ptr<Phrase> phrase = boost::make_shared<Phrase>(
       language_,
       e->remaining_code_length == 0 ? "table" : "completion",
       start_, end_, e);
@@ -146,23 +146,22 @@ LazyTableTranslation::LazyTableTranslation(TableTranslator* translator,
                                            size_t start, size_t end,
                                            const std::string& preedit,
                                            bool enable_user_dict)
-    : TableTranslation(translator, translator->language(),
+    : TableTranslation(translator,
+                       translator->language(),
                        input, start, end, preedit),
       dict_(translator->dict()),
       user_dict_(enable_user_dict ? translator->user_dict() : NULL),
-      limit_(kInitialSearchLimit),
-      user_dict_limit_(kInitialSearchLimit) {
+      limit_(kInitialSearchLimit), user_dict_limit_(kInitialSearchLimit) {
   FetchUserPhrases(translator) || FetchMoreUserPhrases();
   FetchMoreTableEntries();
   CheckEmpty();
 }
 
 bool LazyTableTranslation::FetchUserPhrases(TableTranslator* translator) {
-  if (!user_dict_)
-    return false;
+  if (!user_dict_) return false;
   // fetch all exact match entries
   user_dict_->LookupWords(&uter_, input_, false, 0, &user_dict_key_);
-  auto encoder = translator->encoder();
+  UnityTableEncoder* encoder = translator->encoder();
   if (encoder && encoder->loaded()) {
     encoder->LookupPhrases(&uter_, input_, false);
   }
@@ -210,10 +209,15 @@ bool LazyTableTranslation::FetchMoreTableEntries() {
 TableTranslator::TableTranslator(const Ticket& ticket)
     : Translator(ticket),
       Memory(ticket),
-      TranslatorOptions(ticket) {
-  if (!engine_)
-    return;
-  if (Config* config = engine_->schema()->config()) {
+      TranslatorOptions(ticket),
+      enable_charset_filter_(false),
+      enable_encoder_(false),
+      enable_sentence_(true),
+      sentence_over_completion_(false),
+      encode_commit_history_(true),
+      max_phrase_length_(5) {
+  if (!engine_) return;
+  if (Config *config = engine_->schema()->config()) {
     config->GetBool(name_space_ + "/enable_charset_filter",
                     &enable_charset_filter_);
     config->GetBool(name_space_ + "/enable_sentence",
@@ -236,7 +240,7 @@ TableTranslator::TableTranslator(const Ticket& ticket)
 static bool starts_with_completion(shared_ptr<Translation> translation) {
   if (!translation)
     return false;
-  auto cand = translation->Peek();
+  shared_ptr<Candidate> cand = translation->Peek();
   return cand && cand->type() == "completion";
 }
 
@@ -244,7 +248,7 @@ shared_ptr<Translation> TableTranslator::Query(const std::string& input,
                                                const Segment& segment,
                                                std::string* prompt) {
   if (!segment.HasTag(tag_))
-    return nullptr;
+    return shared_ptr<Translation>();
   DLOG(INFO) << "input = '" << input
              << "', [" << segment.start << ", " << segment.end << ")";
 
@@ -252,18 +256,19 @@ shared_ptr<Translation> TableTranslator::Query(const std::string& input,
       !IsUserDictDisabledFor(input);
 
   const std::string& preedit(input);
-  std::string code = input;
+  std::string code(input);
   boost::trim_right_if(code, boost::is_any_of(delimiters_));
 
   shared_ptr<Translation> translation;
   if (enable_completion_) {
-    translation = Cached<LazyTableTranslation>(
-        this,
-        code,
-        segment.start,
-        segment.start + input.length(),
-        preedit,
-        enable_user_dict);
+    translation = New<CacheTranslation>(
+        boost::make_shared<LazyTableTranslation>(
+            this,
+            code,
+            segment.start,
+            segment.start + input.length(),
+            preedit,
+            enable_user_dict));
   }
   else {
     DictEntryIterator iter;
@@ -278,21 +283,22 @@ shared_ptr<Translation> TableTranslator::Query(const std::string& input,
       }
     }
     if (!iter.exhausted() || !uter.exhausted())
-      translation = Cached<TableTranslation>(
-          this,
-          language(),
-          code,
-          segment.start,
-          segment.start + input.length(),
-          preedit,
-          iter,
-          uter);
+      translation = New<CacheTranslation>(
+          boost::make_shared<TableTranslation>(
+              this,
+              language(),
+              code,
+              segment.start,
+              segment.start + input.length(),
+              preedit,
+              iter,
+              uter));
   }
   if (translation) {
     bool filter_by_charset = enable_charset_filter_ &&
         !engine_->context()->get_option("extended_charset");
     if (filter_by_charset) {
-      translation = New<CharsetFilter>(translation);
+      translation = make_shared<CharsetFilter>(translation);
     }
   }
   if (translation && translation->exhausted()) {
@@ -304,12 +310,12 @@ shared_ptr<Translation> TableTranslator::Query(const std::string& input,
   }
   else if (sentence_over_completion_ &&
            starts_with_completion(translation)) {
-    if (auto sentence = MakeSentence(input, segment.start)) {
+    if (shared_ptr<Translation> sentence = MakeSentence(input, segment.start)) {
       translation = sentence + translation;
     }
   }
   if (translation) {
-    translation = New<UniqueFilter>(translation);
+    translation = make_shared<UniqueFilter>(translation);
   }
   if (translation && translation->exhausted()) {
     translation.reset();  // discard futile translation
@@ -318,9 +324,8 @@ shared_ptr<Translation> TableTranslator::Query(const std::string& input,
 }
 
 bool TableTranslator::Memorize(const CommitEntry& commit_entry) {
-  if (!user_dict_)
-    return false;
-  for (const DictEntry* e : commit_entry.elements) {
+  if (!user_dict_) return false;
+  BOOST_FOREACH(const DictEntry* e, commit_entry.elements) {
     if (is_constructed(e)) {
       DictEntry blessed(*e);
       UnityTableEncoder::RemovePrefix(&blessed.custom_code);
@@ -335,10 +340,10 @@ bool TableTranslator::Memorize(const CommitEntry& commit_entry) {
       encoder_->EncodePhrase(commit_entry.text, "1");
     }
     if (encode_commit_history_) {
-      const auto& history(engine_->context()->commit_history());
+      const CommitHistory& history(engine_->context()->commit_history());
       if (!history.empty()) {
         DLOG(INFO) << "history: " << history.repr();
-        auto it = history.rbegin();
+        CommitHistory::const_reverse_iterator it = history.rbegin();
         if (it->type == "punct") {  // ending with punctuation
             ++it;
         }
@@ -371,7 +376,7 @@ class SentenceTranslation : public Translation {
   SentenceTranslation(TableTranslator* translator,
                       shared_ptr<Sentence> sentence,
                       DictEntryCollector* collector,
-                      UserDictEntryCollector* ucollector,
+                      UserDictEntryCollector* user_phrase_collector,
                       const std::string& input,
                       size_t start);
   virtual bool Next();
@@ -386,7 +391,7 @@ class SentenceTranslation : public Translation {
   shared_ptr<Sentence> sentence_;
   DictEntryCollector collector_;
   UserDictEntryCollector user_phrase_collector_;
-  size_t user_phrase_index_ = 0;
+  size_t user_phrase_index_;
   std::string input_;
   size_t start_;
 };
@@ -409,7 +414,8 @@ SentenceTranslation::SentenceTranslation(TableTranslator* translator,
                                          UserDictEntryCollector* ucollector,
                                          const std::string& input,
                                          size_t start)
-    : translator_(translator), input_(input), start_(start) {
+    : translator_(translator),
+      user_phrase_index_(0), input_(input), start_(start) {
   sentence_.swap(sentence);
   if (collector)
     collector_.swap(*collector);
@@ -425,14 +431,15 @@ bool SentenceTranslation::Next() {
     return !CheckEmpty();
   }
   if (PreferUserPhrase()) {
-    auto r = user_phrase_collector_.rbegin();
+    UserDictEntryCollector::reverse_iterator r =
+        user_phrase_collector_.rbegin();
     if (++user_phrase_index_ >= r->second.size()) {
       user_phrase_collector_.erase(r->first);
       user_phrase_index_ = 0;
     }
   }
   else {
-    auto r = collector_.rbegin();
+    DictEntryCollector::reverse_iterator r = collector_.rbegin();
     if (!r->second.Next()) {
       collector_.erase(r->first);
     }
@@ -442,30 +449,31 @@ bool SentenceTranslation::Next() {
 
 shared_ptr<Candidate> SentenceTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   if (sentence_) {
     return sentence_;
   }
   size_t code_length = 0;
   shared_ptr<DictEntry> entry;
   if (PreferUserPhrase()) {
-    auto r = user_phrase_collector_.rbegin();
+    UserDictEntryCollector::reverse_iterator r =
+        user_phrase_collector_.rbegin();
     code_length = r->first;
     entry = r->second[user_phrase_index_];
   }
   else {
-    auto r = collector_.rbegin();
+    DictEntryCollector::reverse_iterator r = collector_.rbegin();
     code_length = r->first;
     entry = r->second.Peek();
   }
-  auto result = New<Phrase>(
+  shared_ptr<Phrase> result = boost::make_shared<Phrase>(
       translator_ ? translator_->language() : NULL,
       "table",
       start_,
       start_ + code_length,
       entry);
   if (translator_) {
-    std::string preedit = input_.substr(0, code_length);
+    std::string preedit(input_.substr(0, code_length));
     translator_->preedit_formatter().Apply(&preedit);
     result->set_preedit(preedit);
   }
@@ -473,20 +481,20 @@ shared_ptr<Candidate> SentenceTranslation::Peek() {
 }
 
 void SentenceTranslation::PrepareSentence() {
-  if (!sentence_)
-    return;
+  if (!sentence_) return;
   sentence_->Offset(start_);
   sentence_->set_comment(kUnitySymbol);
-  sentence_->set_syllabification(New<SentenceSyllabification>(sentence_));
+  sentence_->set_syllabification(
+      make_shared<SentenceSyllabification>(sentence_));
 
-  if (!translator_)
-    return;
-  std::string preedit = input_;
+  if (!translator_) return;
+  std::string preedit(input_);
   const std::string& delimiters(translator_->delimiters());
   // split syllables
   size_t pos = 0;
-  for (int len : sentence_->syllable_lengths()) {
-    if (pos > 0 && delimiters.find(input_[pos - 1]) == std::string::npos) {
+  BOOST_FOREACH(int len, sentence_->syllable_lengths()) {
+    if (pos > 0 &&
+        delimiters.find(input_[pos - 1]) == std::string::npos) {
       preedit.insert(pos, 1, ' ');
       ++pos;
     }
@@ -508,7 +516,8 @@ bool SentenceTranslation::PreferUserPhrase() const {
   int user_phrase_code_length = 0;
   int table_code_length = 0;
   if (!user_phrase_collector_.empty()) {
-    user_phrase_code_length = user_phrase_collector_.rbegin()->first;
+    user_phrase_code_length =
+        user_phrase_collector_.rbegin()->first;
   }
   if (!collector_.empty()) {
     table_code_length = collector_.rbegin()->first;
@@ -521,9 +530,10 @@ bool SentenceTranslation::PreferUserPhrase() const {
 }
 
 size_t SentenceSyllabification::PreviousStop(size_t caret_pos) const {
-  if (auto sentence = syllabified_.lock()) {
+  shared_ptr<Sentence> sentence = syllabified_.lock();
+  if (sentence) {
     size_t stop = sentence->start();
-    for (size_t len : sentence->syllable_lengths()) {
+    BOOST_FOREACH(size_t len, sentence->syllable_lengths()) {
       if (stop + len >= caret_pos) {
         return stop;
       }
@@ -534,9 +544,10 @@ size_t SentenceSyllabification::PreviousStop(size_t caret_pos) const {
 }
 
 size_t SentenceSyllabification::NextStop(size_t caret_pos) const {
-  if (auto sentence = syllabified_.lock()) {
+  shared_ptr<Sentence> sentence = syllabified_.lock();
+  if (sentence) {
     size_t stop = sentence->start();
-    for (size_t len : sentence->syllable_lengths()) {
+    BOOST_FOREACH(size_t len, sentence->syllable_lengths()) {
       stop += len;
       if (stop > caret_pos) {
         return stop;
@@ -550,9 +561,8 @@ static size_t consume_trailing_delimiters(size_t pos,
                                           const std::string& input,
                                           const std::string& delimiters) {
   while (pos < input.length() &&
-         delimiters.find(input[pos]) != std::string::npos) {
-    ++pos;
-  }
+         delimiters.find(input[pos]) != std::string::npos)
+        ++pos;
   return pos;
 }
 
@@ -563,14 +573,14 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
       !engine_->context()->get_option("extended_charset");
   DictEntryCollector collector;
   UserDictEntryCollector user_phrase_collector;
-  std::map<int, shared_ptr<Sentence>> sentences;
-  sentences[0] = New<Sentence>(language());
+  std::map<int, shared_ptr<Sentence> > sentences;
+  sentences[0] = make_shared<Sentence>(language());
   for (size_t start_pos = 0; start_pos < input.length(); ++start_pos) {
     if (sentences.find(start_pos) == sentences.end())
       continue;
-    std::string active_input = input.substr(start_pos);
-    std::string active_key = active_input + ' ';
-    std::vector<shared_ptr<DictEntry>> entries(active_input.length() + 1);
+    std::string active_input(input.substr(start_pos));
+    std::string active_key(active_input + ' ');
+    std::vector<shared_ptr<DictEntry> > entries(active_input.length() + 1);
     // lookup dictionaries
     if (user_dict_ && user_dict_->loaded()) {
       for (size_t len = 1; len <= active_input.length(); ++len) {
@@ -581,7 +591,7 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
         DLOG(INFO) << "active input: " << active_input << "[0, " << len << ")";
         UserDictEntryIterator uter;
         std::string resume_key;
-        std::string key = active_input.substr(0, len);
+        std::string key(active_input.substr(0, len));
         user_dict_->LookupWords(&uter, key, false, 0, &resume_key);
         if (filter_by_charset) {
           uter.AddFilter(CharsetFilter::FilterDictEntry);
@@ -608,7 +618,7 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
         DLOG(INFO) << "active input: " << active_input << "[0, " << len << ")";
         UserDictEntryIterator uter;
         std::string resume_key;
-        std::string key = active_input.substr(0, len);
+        std::string key(active_input.substr(0, len));
         encoder_->LookupPhrases(&uter, key, false, 0, &resume_key);
         if (filter_by_charset) {
           uter.AddFilter(CharsetFilter::FilterDictEntry);
@@ -628,11 +638,9 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
     if (dict_ && dict_->loaded()) {
       std::vector<Prism::Match> matches;
       dict_->prism()->CommonPrefixSearch(input.substr(start_pos), &matches);
-      if (matches.empty())
-        continue;
-      for (const auto& m : boost::adaptors::reverse(matches)) {
-        if (m.length == 0)
-          continue;
+      if (matches.empty()) continue;
+      BOOST_REVERSE_FOREACH(const Prism::Match &m, matches) {
+        if (m.length == 0) continue;
         size_t consumed_length =
             consume_trailing_delimiters(m.length, active_input, delimiters_);
         if (entries[consumed_length])
@@ -652,11 +660,11 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
       }
     }
     for (size_t len = 1; len <= active_input.length(); ++len) {
-      if (!entries[len])
-        continue;
+      if (!entries[len]) continue;
       size_t end_pos = start_pos + len;
       // create a new sentence
-      auto new_sentence = New<Sentence>(*sentences[start_pos]);
+      shared_ptr<Sentence> new_sentence =
+          make_shared<Sentence>(*sentences[start_pos]);
       new_sentence->Extend(*entries[len], end_pos);
       // compare and update sentences
       if (sentences.find(end_pos) == sentences.end() ||
@@ -667,15 +675,16 @@ TableTranslator::MakeSentence(const std::string& input, size_t start,
   }
   shared_ptr<Translation> result;
   if (sentences.find(input.length()) != sentences.end()) {
-    result = Cached<SentenceTranslation>(
-        this,
-        sentences[input.length()],
-        include_prefix_phrases ? &collector : NULL,
-        include_prefix_phrases ? &user_phrase_collector : NULL,
-        input,
-        start);
+    result = New<CacheTranslation>(
+        boost::make_shared<SentenceTranslation>(
+            this,
+            sentences[input.length()],
+            include_prefix_phrases ? &collector : NULL,
+            include_prefix_phrases ? &user_phrase_collector : NULL,
+            input,
+            start));
     if (result && filter_by_charset) {
-      result = New<CharsetFilter>(result);
+      result = make_shared<CharsetFilter>(result);
     }
   }
   return result;
diff --git a/src/gear/translator_commons.cc b/src/gear/translator_commons.cc
index 5e6b87f..2f26291 100644
--- a/src/gear/translator_commons.cc
+++ b/src/gear/translator_commons.cc
@@ -4,6 +4,7 @@
 //
 // 2012-04-22 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 #include <utf8.h>
 #include <rime/config.h>
 #include <rime/schema.h>
@@ -18,12 +19,11 @@ bool contains_extended_cjk(const std::string &text);
 
 bool Patterns::Load(ConfigListPtr patterns) {
   clear();
-  if (!patterns)
-    return false;
-  for (auto it = patterns->begin(); it != patterns->end(); ++it) {
-    if (auto value = As<ConfigValue>(*it)) {
-      push_back(boost::regex(value->str()));
-    }
+  if (!patterns) return false;
+  for (ConfigList::Iterator it = patterns->begin(); it != patterns->end(); ++it) {
+    ConfigValuePtr value = As<ConfigValue>(*it);
+    if (!value) continue;
+    push_back(boost::regex(value->str()));
   }
   return true;
 }
@@ -70,7 +70,7 @@ bool CacheTranslation::Next() {
 
 shared_ptr<Candidate> CacheTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   if (!cache_) {
     cache_ = translation_->Peek();
   }
@@ -100,7 +100,7 @@ shared_ptr<Candidate> CharsetFilter::Peek() {
 
 bool CharsetFilter::LocateNextCandidate() {
   while (!translation_->exhausted()) {
-    auto cand = translation_->Peek();
+    shared_ptr<Candidate> cand = translation_->Peek();
     if (cand && FilterText(cand->text()))
       return true;
     translation_->Next();
@@ -142,10 +142,14 @@ bool UniqueFilter::AlreadyHas(const std::string& text) const {
 
 // TranslatorOptions
 
-TranslatorOptions::TranslatorOptions(const Ticket& ticket) {
-  if (!ticket.schema)
-    return;
-  if (Config *config = ticket.schema->config()) {
+TranslatorOptions::TranslatorOptions(const Ticket& ticket)
+    : tag_("abc"),
+      enable_completion_(true),
+      strict_spelling_(false),
+      initial_quality_(0.0) {
+  if (!ticket.schema) return;
+  Config *config = ticket.schema->config();
+  if (config) {
     config->GetString(ticket.name_space + "/delimiter", &delimiters_) ||
         config->GetString("speller/delimiter", &delimiters_);
     config->GetString(ticket.name_space + "/tag", &tag_);
@@ -160,8 +164,7 @@ TranslatorOptions::TranslatorOptions(const Ticket& ticket) {
     comment_formatter_.Load(
         config->GetList(ticket.name_space + "/comment_format"));
     user_dict_disabling_patterns_.Load(
-        config->GetList(
-            ticket.name_space + "/disable_user_dict_for_patterns"));
+        config->GetList(ticket.name_space + "/disable_user_dict_for_patterns"));
   }
   if (delimiters_.empty()) {
     delimiters_ = " ";
@@ -171,11 +174,12 @@ TranslatorOptions::TranslatorOptions(const Ticket& ticket) {
 bool TranslatorOptions::IsUserDictDisabledFor(const std::string& input) const {
   if (user_dict_disabling_patterns_.empty())
     return false;
-  for (const auto& pattern : user_dict_disabling_patterns_) {
+  BOOST_FOREACH(const boost::regex& pattern, user_dict_disabling_patterns_) {
     if (boost::regex_match(input, pattern))
       return true;
   }
   return false;
 }
 
+
 }  // namespace rime
diff --git a/src/gear/uniquifier.cc b/src/gear/uniquifier.cc
index e53d786..bd764bf 100644
--- a/src/gear/uniquifier.cc
+++ b/src/gear/uniquifier.cc
@@ -15,21 +15,21 @@ namespace rime {
 Uniquifier::Uniquifier(const Ticket& ticket) : Filter(ticket) {
 }
 
-void Uniquifier::Apply(CandidateList* recruited,
-                       CandidateList* candidates) {
+void Uniquifier::Apply(CandidateList *recruited,
+                       CandidateList *candidates) {
   if (!candidates || candidates->empty())
     return;
-  auto i = candidates->begin();
+  CandidateList::iterator i = candidates->begin();
   while (i != candidates->end()) {
-    auto j = recruited->begin();
-    for ( ; j != recruited->end(); ++j) {
+    CandidateList::iterator j = recruited->begin();
+    for (; j != recruited->end(); ++j) {
       if ((*i)->text() == (*j)->text()) {
-        auto u = As<UniquifiedCandidate>(*j);
-        if (!u) {
-          u = New<UniquifiedCandidate>(*j, "uniquified");
-          *j = u;
+        shared_ptr<UniquifiedCandidate> c = As<UniquifiedCandidate>(*j);
+        if (!c) {
+          c = make_shared<UniquifiedCandidate>(*j, "uniquified");
+          *j = c;
         }
-        u->Append(*i);
+        c->Append(*i);
         break;
       }
     }
diff --git a/src/gear/unity_table_encoder.cc b/src/gear/unity_table_encoder.cc
index 9fd5b39..9e5f2b6 100644
--- a/src/gear/unity_table_encoder.cc
+++ b/src/gear/unity_table_encoder.cc
@@ -23,7 +23,8 @@ UnityTableEncoder::~UnityTableEncoder() {
 }
 
 bool UnityTableEncoder::Load(const Ticket& ticket) {
-  auto c = ReverseLookupDictionary::Require("reverse_lookup_dictionary");
+  ReverseLookupDictionary::Component *c =
+      ReverseLookupDictionary::Require("reverse_lookup_dictionary");
   if (!c) {
     LOG(ERROR) << "component not available: reverse_lookup_dictionary";
     return false;
@@ -33,7 +34,7 @@ bool UnityTableEncoder::Load(const Ticket& ticket) {
     LOG(ERROR) << "error loading dictionary for unity table encoder.";
     return false;
   }
-  auto settings = rev_dict_->GetDictSettings();
+  shared_ptr<DictSettings> settings = rev_dict_->GetDictSettings();
   if (!settings || !settings->use_rule_based_encoder()) {
     LOG(WARNING) << "unity table encoder is not enabled in dict settings.";
     return false;
@@ -41,11 +42,10 @@ bool UnityTableEncoder::Load(const Ticket& ticket) {
   return LoadSettings(settings.get());
 }
 
-void UnityTableEncoder::CreateEntry(const std::string& word,
-                                    const std::string& code_str,
-                                    const std::string& weight_str) {
-  if (!user_dict_)
-    return;
+void UnityTableEncoder::CreateEntry(const std::string &word,
+                                    const std::string &code_str,
+                                    const std::string &weight_str) {
+  if (!user_dict_) return;
   DictEntry entry;
   entry.text = word;
   entry.custom_code = code_str + ' ';
@@ -72,8 +72,7 @@ size_t UnityTableEncoder::LookupPhrases(UserDictEntryIterator* result,
                                         bool predictive,
                                         size_t limit,
                                         std::string* resume_key) {
-  if (!user_dict_)
-    return 0;
+  if (!user_dict_) return 0;
   return user_dict_->LookupWords(result,
                                  kEncodedPrefix + input,
                                  predictive, limit, resume_key);
@@ -89,8 +88,7 @@ bool UnityTableEncoder::AddPrefix(std::string* key) {
 }
 
 bool UnityTableEncoder::RemovePrefix(std::string* key) {
-  if (!HasPrefix(*key))
-    return false;
+  if (!HasPrefix(*key)) return false;
   key->erase(0, strlen(kEncodedPrefix));
   return true;
 }
diff --git a/src/key_event.cc b/src/key_event.cc
index 926e603..3c3324c 100644
--- a/src/key_event.cc
+++ b/src/key_event.cc
@@ -12,7 +12,7 @@
 
 namespace rime {
 
-KeyEvent::KeyEvent(const std::string& repr) {
+KeyEvent::KeyEvent(const std::string &repr) {
   if (!Parse(repr))
     keycode_ = modifier_ = 0;
 }
@@ -22,7 +22,7 @@ std::string KeyEvent::repr() const {
   std::ostringstream modifiers;
   if (modifier_) {
     int k = modifier_ & kModifierMask;
-    const char* modifier_name = NULL;
+    const char *modifier_name = NULL;
     for (int i = 0; k; ++i, k >>= 1) {
       if (!(k & 1))
         continue;
@@ -33,9 +33,9 @@ std::string KeyEvent::repr() const {
     }
   }
   // first lookup predefined key name
-  if (const char* name = RimeGetKeyName(keycode_)) {
+  const char *name = RimeGetKeyName(keycode_);
+  if (name)
     return modifiers.str() + name;
-  }
   // no name :-| return its hex value
   std::string value;
   if (keycode_ <= 0xffff) {
@@ -50,7 +50,7 @@ std::string KeyEvent::repr() const {
   return modifiers.str() + value;
 }
 
-bool KeyEvent::Parse(const std::string& repr) {
+bool KeyEvent::Parse(const std::string &repr) {
   keycode_ = modifier_ = 0;
   if (repr.empty()) {
     return false;
@@ -85,7 +85,7 @@ bool KeyEvent::Parse(const std::string& repr) {
   return true;
 }
 
-KeySequence::KeySequence(const std::string& repr) {
+KeySequence::KeySequence(const std::string &repr) {
   if (!Parse(repr))
     clear();
 }
@@ -93,7 +93,7 @@ KeySequence::KeySequence(const std::string& repr) {
 std::string KeySequence::repr() const {
   std::ostringstream result;
   std::string k;
-  for (auto it = cbegin(); it != cend(); ++it) {
+  for (const_iterator it = begin(); it != end(); ++it) {
     k = it->repr();
     if (k.size() == 1) {
       result << k;
@@ -105,7 +105,7 @@ std::string KeySequence::repr() const {
   return result.str();
 }
 
-bool KeySequence::Parse(const std::string& repr) {
+bool KeySequence::Parse(const std::string &repr) {
   clear();
   size_t n = repr.size();
   size_t start = 0;
diff --git a/src/lever/custom_settings.cc b/src/lever/custom_settings.cc
index 0153830..0105e2d 100644
--- a/src/lever/custom_settings.cc
+++ b/src/lever/custom_settings.cc
@@ -18,9 +18,8 @@ namespace rime {
 CustomSettings::CustomSettings(Deployer* deployer,
                                const std::string& config_id,
                                const std::string& generator_id)
-    : deployer_(deployer),
-      config_id_(config_id),
-      generator_id_(generator_id) {
+    : deployer_(deployer), modified_(false),
+      config_id_(config_id), generator_id_(generator_id) {
 }
 
 bool CustomSettings::Load() {
@@ -41,8 +40,7 @@ bool CustomSettings::Load() {
 }
 
 bool CustomSettings::Save() {
-  if (!modified_)
-    return false;
+  if (!modified_) return false;
   Signature signature(generator_id_, "customization");
   signature.Sign(&custom_config_, deployer_);
   fs::path custom_config_path(deployer_->user_data_dir);
@@ -66,9 +64,9 @@ ConfigMapPtr CustomSettings::GetMap(const std::string& key) {
 
 bool CustomSettings::Customize(const std::string& key,
                                const ConfigItemPtr& item) {
-  auto patch = custom_config_.GetMap("patch");
+  ConfigMapPtr patch = custom_config_.GetMap("patch");
   if (!patch) {
-    patch = New<ConfigMap>();
+    patch = make_shared<ConfigMap>();
   }
   patch->Set(key, item);
   // the branch 'patch' should be set as a whole in order to be saved, for
diff --git a/src/lever/customizer.cc b/src/lever/customizer.cc
index 5d02597..38d01b9 100644
--- a/src/lever/customizer.cc
+++ b/src/lever/customizer.cc
@@ -117,17 +117,18 @@ bool Customizer::UpdateConfigFile() {
       LOG(ERROR) << "Error loading customization file.";
       return false;
     }
-    if (auto patch = custom_config.GetMap("patch")) {
-      for (auto it = patch->begin(); it != patch->end(); ++it) {
+    ConfigMapPtr patch = custom_config.GetMap("patch");
+    if (!patch) {
+      LOG(WARNING) << "'patch' not found in customization file.";
+    }
+    else {
+      for (ConfigMap::Iterator it = patch->begin(); it != patch->end(); ++it) {
         if (!dest_config.SetItem(it->first, it->second)) {
           LOG(ERROR) << "Error applying customization: '" << it->first << "'.";
           return false;
         }
       }
     }
-    else {
-      LOG(WARNING) << "'patch' not found in customization file.";
-    }
     // update config version
     dest_config.GetString(version_key_, &dest_version);
     size_t custom_part = dest_version.find(".custom.");
diff --git a/src/lever/deployment_tasks.cc b/src/lever/deployment_tasks.cc
index 495066f..7847af7 100644
--- a/src/lever/deployment_tasks.cc
+++ b/src/lever/deployment_tasks.cc
@@ -23,8 +23,6 @@
 #include <windows.h>
 #endif
 
-using namespace std::placeholders;
-
 namespace fs = boost::filesystem;
 
 namespace rime {
@@ -112,7 +110,7 @@ bool InstallationUpdate::Run(Deployer* deployer) {
 bool WorkspaceUpdate::Run(Deployer* deployer) {
   LOG(INFO) << "updating workspace.";
   {
-    unique_ptr<DeploymentTask> t;
+    scoped_ptr<DeploymentTask> t;
     t.reset(new ConfigFileUpdate("default.yaml", "config_version"));
     t->Run(deployer);
     // since brise 0.18
@@ -130,7 +128,7 @@ bool WorkspaceUpdate::Run(Deployer* deployer) {
                << default_config_path.string() << "'.";
     return false;
   }
-  auto schema_list = config.GetList("schema_list");
+  ConfigListPtr schema_list = config.GetList("schema_list");
   if (!schema_list) {
     LOG(WARNING) << "schema list not defined.";
     return false;
@@ -140,14 +138,13 @@ bool WorkspaceUpdate::Run(Deployer* deployer) {
   int success = 0;
   int failure = 0;
   std::map<std::string, std::string> schemas;
-  for (auto it = schema_list->begin(); it != schema_list->end(); ++it) {
-    auto item = As<ConfigMap>(*it);
-    if (!item)
-      continue;
-    auto schema_property = item->GetValue("schema");
-    if (!schema_property)
-      continue;
-    const std::string& schema_id(schema_property->str());
+  for (ConfigList::Iterator it = schema_list->begin();
+       it != schema_list->end(); ++it) {
+    ConfigMapPtr item = As<ConfigMap>(*it);
+    if (!item) continue;
+    ConfigValuePtr schema_property = item->GetValue("schema");
+    if (!schema_property) continue;
+    const std::string &schema_id(schema_property->str());
     LOG(INFO) << "schema: " << schema_id;
     std::string schema_path;
     if (schemas.find(schema_id) == schemas.end()) {
@@ -162,38 +159,39 @@ bool WorkspaceUpdate::Run(Deployer* deployer) {
       continue;
     }
     // build schema
-    unique_ptr<DeploymentTask> t(new SchemaUpdate(schema_path));
+    scoped_ptr<DeploymentTask> t(new SchemaUpdate(schema_path));
     if (t->Run(deployer))
       ++success;
     else
       ++failure;
   }
   // find dependencies
-  for (auto s = schemas.cbegin(); s != schemas.cend(); ++s) {
+  for (std::map<std::string, std::string>::const_iterator s = schemas.begin();
+       s != schemas.end(); ++s) {
     Config schema_config;
     // user could have customized dependencies in the resulting schema
     std::string user_schema_path = GetSchemaPath(deployer, s->first, false);
     if (!schema_config.LoadFromFile(user_schema_path))
       continue;
-    auto dependencies = schema_config.GetList("schema/dependencies");
+    ConfigListPtr dependencies = schema_config.GetList("schema/dependencies");
     if (!dependencies)
       continue;
-    for (auto d = dependencies->begin(); d != dependencies->end(); ++d) {
-      auto dependency = As<ConfigValue>(*d);
-      if (!dependency)
-        continue;
+    for (ConfigList::Iterator d = dependencies->begin();
+         d != dependencies->end(); ++d) {
+      ConfigValuePtr dependency = As<ConfigValue>(*d);
+      if (!dependency) continue;
       std::string dependency_id(dependency->str());
       if (schemas.find(dependency_id) != schemas.end())  // already built
         continue;
       LOG(INFO) << "new dependency: " << dependency_id;
-      std::string dependency_path = GetSchemaPath(deployer, dependency_id, true);
+      std::string dependency_path(GetSchemaPath(deployer, dependency_id, true));
       schemas[dependency_id] = dependency_path;
       if (dependency_path.empty()) {
         LOG(WARNING) << "missing schema file for dependency '" << dependency_id << "'.";
         continue;
       }
       // build dependency
-      unique_ptr<DeploymentTask> t(new SchemaUpdate(dependency_path));
+      scoped_ptr<DeploymentTask> t(new SchemaUpdate(dependency_path));
       if (t->Run(deployer))
         ++success;
       else
@@ -285,14 +283,15 @@ bool SchemaUpdate::Run(Deployer* deployer) {
     return true;
   }
   DictionaryComponent component;
-  unique_ptr<Dictionary> dict(component.Create({&schema, "translator"}));
+  scoped_ptr<Dictionary> dict;
+  dict.reset(component.Create(Ticket(&schema, "translator")));
   if (!dict) {
     LOG(ERROR) << "Error creating dictionary '" << dict_name << "'.";
     return false;
   }
   LOG(INFO) << "preparing dictionary '" << dict_name << "'.";
-  DictFileFinder finder = std::bind(&find_dict_file,
-                                    _1, shared_data_path, user_data_path);
+  DictFileFinder finder =
+      boost::bind(&find_dict_file, _1, shared_data_path, user_data_path);
   DictCompiler dict_compiler(dict.get(), finder);
   if (verbose_) {
     dict_compiler.set_options(DictCompiler::kRebuild | DictCompiler::kDump);
@@ -307,7 +306,8 @@ bool SchemaUpdate::Run(Deployer* deployer) {
 
 ConfigFileUpdate::ConfigFileUpdate(TaskInitializer arg) {
   try {
-    auto p = boost::any_cast< std::pair<std::string, std::string>>(arg);
+    std::pair<std::string, std::string> p =
+        boost::any_cast< std::pair<std::string, std::string> >(arg);
     file_name_ = p.first;
     version_key_ = p.second;
   }
@@ -335,12 +335,13 @@ bool PrebuildAllSchemas::Run(Deployer* deployer) {
   fs::path user_data_path(deployer->user_data_dir);
   if (!fs::exists(shared_data_path) || !fs::is_directory(shared_data_path))
     return false;
+  fs::directory_iterator iter(shared_data_path);
+  fs::directory_iterator end;
   bool success = true;
-  for (fs::directory_iterator iter(shared_data_path), end;
-       iter != end; ++iter) {
+  for (; iter != end; ++iter) {
     fs::path entry(iter->path());
     if (boost::ends_with(entry.string(), ".schema.yaml")) {
-      unique_ptr<DeploymentTask> t(new SchemaUpdate(entry.string()));
+      scoped_ptr<DeploymentTask> t(new SchemaUpdate(entry.string()));
       if (!t->Run(deployer))
         success = false;
     }
@@ -357,8 +358,9 @@ bool SymlinkingPrebuiltDictionaries::Run(Deployer* deployer) {
     return false;
   bool success = false;
   // test existing link
-  for (fs::directory_iterator test(user_data_path), end;
-       test != end; ++test) {
+  fs::directory_iterator test(user_data_path);
+  fs::directory_iterator end;
+  for (; test != end; ++test) {
     fs::path entry(test->path());
     if (fs::is_symlink(entry) && entry.extension().string() == ".bin") {
       try {
@@ -375,8 +377,8 @@ bool SymlinkingPrebuiltDictionaries::Run(Deployer* deployer) {
     }
   }
   // create link
-  for (fs::directory_iterator iter(shared_data_path), end;
-       iter != end; ++iter) {
+  fs::directory_iterator iter(shared_data_path);
+  for (; iter != end; ++iter) {
     fs::path entry(iter->path());
     fs::path link(user_data_path / entry.filename());
     try {
@@ -400,7 +402,8 @@ bool UserDictUpgration::Run(Deployer* deployer) {
   UserDictList dicts;
   manager.GetUserDictList(&dicts);
   bool ok = true;
-  for (auto it = dicts.cbegin(); it != dicts.cend(); ++it) {
+  UserDictList::const_iterator it = dicts.begin();
+  for (; it != dicts.end(); ++it) {
     if (!manager.UpgradeUserDict(*it))
       ok = false;
   }
@@ -421,18 +424,18 @@ bool BackupConfigFiles::Run(Deployer* deployer) {
   if (!fs::exists(backup_dir)) {
     boost::system::error_code ec;
     if (!fs::create_directories(backup_dir, ec)) {
-      LOG(ERROR) << "error creating directory '"
-                 << backup_dir.string() << "'.";
+      LOG(ERROR) << "error creating directory '" << backup_dir.string() << "'.";
       return false;
     }
   }
   int success = 0, failure = 0, latest = 0, skipped = 0;
-  for (fs::directory_iterator iter(user_data_path), end;
-       iter != end; ++iter) {
+  fs::directory_iterator iter(user_data_path);
+  fs::directory_iterator end;
+  for (; iter != end; ++iter) {
     fs::path entry(iter->path());
     if (!fs::is_regular_file(entry))
       continue;
-    auto file_extension = entry.extension().string();
+    const std::string file_extension(entry.extension().string());
     bool is_yaml_file = file_extension == ".yaml";
     bool is_text_file = file_extension == ".txt";
     if (!is_yaml_file && !is_text_file)
@@ -476,12 +479,13 @@ bool CleanupTrash::Run(Deployer* deployer) {
     return false;
   fs::path trash = user_data_path / "trash";
   int success = 0, failure = 0;
-  for (fs::directory_iterator iter(user_data_path), end;
-       iter != end; ++iter) {
+  fs::directory_iterator iter(user_data_path);
+  fs::directory_iterator end;
+  for (; iter != end; ++iter) {
     fs::path entry(iter->path());
     if (!fs::is_regular_file(entry))
       continue;
-    auto filename = entry.filename().string();
+    std::string filename(entry.filename().string());
     if (filename == "rime.log" ||
         boost::ends_with(filename, ".userdb.kct.old") ||
         boost::ends_with(filename, ".userdb.kct.snapshot")) {
@@ -532,9 +536,12 @@ bool CleanOldLogFiles::Run(Deployer* deployer) {
 
   bool success = true;
   int removed = 0;
-  for (auto i = dirs.cbegin(); i != dirs.cend(); ++i) {
+  std::vector<std::string>::const_iterator i = dirs.begin();
+  for (; i != dirs.end(); ++i) {
     DLOG(INFO) << "temp directory: " << *i;
-    for (fs::directory_iterator j(*i), end; j != end; ++j) {
+    fs::directory_iterator j(*i);
+    fs::directory_iterator end;
+    for (; j != end; ++j) {
       fs::path entry(j->path());
       std::string file_name(entry.filename().string());
       try {
diff --git a/src/lever/levers_module.cc b/src/lever/levers_module.cc
index d76fdbe..64262de 100644
--- a/src/lever/levers_module.cc
+++ b/src/lever/levers_module.cc
@@ -4,6 +4,7 @@
 //
 // 2013-10-17 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/foreach.hpp>
 
 #include <rime_api.h>
 #include <rime_levers_api.h>
@@ -21,7 +22,7 @@ static void rime_levers_initialize() {
   using namespace rime;
 
   LOG(INFO) << "registering components from module 'levers'.";
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
 
   // deployment tools
   r.Register("installation_update", new Component<InstallationUpdate>);
@@ -43,9 +44,8 @@ static void rime_levers_finalize() {
 
 // implementation of levers api
 
-static RimeCustomSettings*
-rime_levers_custom_settings_init(const char* config_id,
-                                 const char* generator_id) {
+static RimeCustomSettings* rime_levers_custom_settings_init(const char* config_id,
+                                                            const char* generator_id) {
   return reinterpret_cast<RimeCustomSettings*>(
       new rime::CustomSettings(&rime::Service::instance().deployer(),
                                config_id, generator_id));
@@ -66,29 +66,25 @@ static Bool rime_levers_save_settings(RimeCustomSettings* settings) {
 static Bool rime_levers_customize_bool(RimeCustomSettings* settings,
                                        const char* key, bool value) {
   rime::ConfigItemPtr item = rime::New<rime::ConfigValue>(value);
-  auto custom_settings = reinterpret_cast<rime::CustomSettings*>(settings);
-  return custom_settings->Customize(key, item);
+  return reinterpret_cast<rime::CustomSettings*>(settings)->Customize(key, item);
 }
 
 static Bool rime_levers_customize_int(RimeCustomSettings* settings,
                                       const char* key, int value) {
   rime::ConfigItemPtr item = rime::New<rime::ConfigValue>(value);
-  auto custom_settings = reinterpret_cast<rime::CustomSettings*>(settings);
-  return custom_settings->Customize(key, item);
+  return reinterpret_cast<rime::CustomSettings*>(settings)->Customize(key, item);
 }
 
 static Bool rime_levers_customize_double(RimeCustomSettings* settings,
                                          const char* key, double value) {
   rime::ConfigItemPtr item = rime::New<rime::ConfigValue>(value);
-  auto custom_settings = reinterpret_cast<rime::CustomSettings*>(settings);
-  return custom_settings->Customize(key, item);
+  return reinterpret_cast<rime::CustomSettings*>(settings)->Customize(key, item);
 }
 
 static Bool rime_levers_customize_string(RimeCustomSettings* settings,
                                          const char* key, const char* value) {
   rime::ConfigItemPtr item = rime::New<rime::ConfigValue>(value);
-  auto custom_settings = reinterpret_cast<rime::CustomSettings*>(settings);
-  return custom_settings->Customize(key, item);
+  return reinterpret_cast<rime::CustomSettings*>(settings)->Customize(key, item);
 }
 
 static Bool rime_levers_customize_item(RimeCustomSettings* settings,
@@ -99,7 +95,8 @@ static Bool rime_levers_customize_item(RimeCustomSettings* settings,
       item = v->GetItem("");
     }
   }
-  auto custom_settings = reinterpret_cast<rime::CustomSettings*>(settings);
+  rime::CustomSettings* custom_settings =
+      reinterpret_cast<rime::CustomSettings*>(settings);
   return custom_settings->Customize(key, item);
 }
 
@@ -111,10 +108,8 @@ static Bool rime_levers_settings_is_modified(RimeCustomSettings* settings) {
   return reinterpret_cast<rime::CustomSettings*>(settings)->modified();
 }
 
-static Bool rime_levers_settings_get_config(RimeCustomSettings* settings,
-                                            RimeConfig* config) {
-  if (!config)
-    return False;
+static Bool rime_levers_settings_get_config(RimeCustomSettings* settings, RimeConfig* config) {
+  if (!config) return False;
   config->ptr = reinterpret_cast<rime::CustomSettings*>(settings)->config();
   return Bool(!!config->ptr);
 }
@@ -124,18 +119,17 @@ static RimeSwitcherSettings* rime_levers_switcher_settings_init() {
       new rime::SwitcherSettings(&rime::Service::instance().deployer()));
 }
 
-static Bool
-rime_levers_get_available_schema_list(RimeSwitcherSettings* settings,
-                                      RimeSchemaList* list) {
-  auto ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
+static Bool rime_levers_get_available_schema_list(RimeSwitcherSettings* settings,
+                                                  RimeSchemaList* list) {
+  rime::SwitcherSettings* ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
   list->size = 0;
   list->list = NULL;
   if (ss->available().empty()) {
     return False;
   }
   list->list = new RimeSchemaListItem[ss->available().size()];
-  for (const auto& info : ss->available()) {
-    auto& item(list->list[list->size]);
+  BOOST_FOREACH(const rime::SchemaInfo& info, ss->available()) {
+    RimeSchemaListItem& item(list->list[list->size]);
     item.schema_id = const_cast<char*>(info.schema_id.c_str());
     item.name = const_cast<char*>(info.name.c_str());
     item.reserved = const_cast<rime::SchemaInfo*>(&info);
@@ -144,18 +138,17 @@ rime_levers_get_available_schema_list(RimeSwitcherSettings* settings,
   return True;
 }
 
-static Bool
-rime_levers_get_selected_schema_list(RimeSwitcherSettings* settings,
-                                     RimeSchemaList* list) {
-  auto ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
+static Bool rime_levers_get_selected_schema_list(RimeSwitcherSettings* settings,
+                                                 RimeSchemaList* list) {
+  rime::SwitcherSettings* ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
   list->size = 0;
   list->list = NULL;
   if (ss->selection().empty()) {
     return False;
   }
   list->list = new RimeSchemaListItem[ss->selection().size()];
-  for (const std::string& schema_id : ss->selection()) {
-    auto& item(list->list[list->size]);
+  BOOST_FOREACH(const std::string& schema_id, ss->selection()) {
+    RimeSchemaListItem& item(list->list[list->size]);
     item.schema_id = const_cast<char*>(schema_id.c_str());
     ++list->size;
   }
@@ -169,38 +162,38 @@ static void rime_levers_schema_list_destroy(RimeSchemaList* list) {
 }
 
 static const char* rime_levers_get_schema_id(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->schema_id.empty() ? si->schema_id.c_str() : NULL;
 }
 
 static const char* rime_levers_get_schema_name(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->name.empty() ? si->name.c_str() : NULL;
 }
 
 static const char* rime_levers_get_schema_version(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->version.empty() ? si->version.c_str() : NULL;
 }
 static const char* rime_levers_get_schema_author(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->author.empty() ? si->author.c_str() : NULL;
 }
 
 static const char* rime_levers_get_schema_description(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->description.empty() ? si->description.c_str() : NULL;
 }
 
 static const char* rime_levers_get_schema_file_path(RimeSchemaInfo* info) {
-  auto si = reinterpret_cast<rime::SchemaInfo*>(info);
+  rime::SchemaInfo* si = reinterpret_cast<rime::SchemaInfo*>(info);
   return si && !si->file_path.empty() ? si->file_path.c_str() : NULL;
 }
 
 static Bool rime_levers_select_schemas(RimeSwitcherSettings* settings,
                                        const char* schema_id_list[],
                                        int count) {
-  auto ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
+  rime::SwitcherSettings* ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
   rime::SwitcherSettings::Selection selection;
   for (int i = 0; i < count; ++i) {
     selection.push_back(schema_id_list[i]);
@@ -209,13 +202,12 @@ static Bool rime_levers_select_schemas(RimeSwitcherSettings* settings,
 }
 
 static const char* rime_levers_get_hotkeys(RimeSwitcherSettings* settings) {
-  auto ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
+  rime::SwitcherSettings* ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
   return !ss->hotkeys().empty() ? ss->hotkeys().c_str() : NULL;
 }
 
-static Bool rime_levers_set_hotkeys(RimeSwitcherSettings* settings,
-                                    const char* hotkeys) {
-  auto ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
+static Bool rime_levers_set_hotkeys(RimeSwitcherSettings* settings, const char* hotkeys) {
+  rime::SwitcherSettings* ss = reinterpret_cast<rime::SwitcherSettings*>(settings);
   return Bool(ss->SetHotkeys(hotkeys));
 }
 
@@ -239,7 +231,7 @@ static void rime_levers_user_dict_iterator_destroy(RimeUserDictIterator* iter) {
 }
 
 static const char* rime_levers_next_user_dict(RimeUserDictIterator* iter) {
-  auto list = reinterpret_cast<rime::UserDictList*>(iter->ptr);
+  rime::UserDictList* list = reinterpret_cast<rime::UserDictList*>(iter->ptr);
   if (!list || iter->i >= list->size()) {
     return NULL;
   }
@@ -256,14 +248,12 @@ static Bool rime_levers_restore_user_dict(const char* snapshot_file) {
   return Bool(mgr.Restore(snapshot_file));
 }
 
-static int rime_levers_export_user_dict(const char* dict_name,
-                                        const char* text_file) {
+static int rime_levers_export_user_dict(const char* dict_name, const char* text_file) {
   rime::UserDictManager mgr(&rime::Service::instance().deployer());
   return mgr.Export(dict_name, text_file);
 }
 
-static int rime_levers_import_user_dict(const char* dict_name,
-                                        const char* text_file) {
+static int rime_levers_import_user_dict(const char* dict_name, const char* text_file) {
   rime::UserDictManager mgr(&rime::Service::instance().deployer());
   return mgr.Import(dict_name, text_file);
 }
diff --git a/src/lever/switcher_settings.cc b/src/lever/switcher_settings.cc
index 4ee7d57..d0d139f 100644
--- a/src/lever/switcher_settings.cc
+++ b/src/lever/switcher_settings.cc
@@ -4,9 +4,9 @@
 //
 // 2012-02-18 GONG Chen <chen.sst@gmail.com>
 //
-#include <utility>
 #include <boost/algorithm/string.hpp>
 #include <boost/filesystem.hpp>
+#include <boost/foreach.hpp>
 #include <rime/config.h>
 #include <rime/deployer.h>
 #include <rime/lever/switcher_settings.h>
@@ -34,12 +34,12 @@ bool SwitcherSettings::Load() {
   return true;
 }
 
-bool SwitcherSettings::Select(Selection selection) {
-  selection_ = std::move(selection);
-  auto schema_list = New<ConfigList>();
-  for (const std::string& schema_id : selection_) {
-    auto item = New<ConfigMap>();
-    item->Set("schema", New<ConfigValue>(schema_id));
+bool SwitcherSettings::Select(const Selection& selection) {
+  selection_ = selection;
+  ConfigListPtr schema_list = make_shared<ConfigList>();
+  BOOST_FOREACH(const std::string& schema_id, selection_) {
+    ConfigMapPtr item = make_shared<ConfigMap>();
+    item->Set("schema", boost::make_shared<ConfigValue>(schema_id));
     schema_list->Append(item);
   }
   return Customize("schema_list", schema_list);
@@ -55,33 +55,32 @@ void SwitcherSettings::GetAvailableSchemasFromDirectory(const fs::path& dir) {
     LOG(INFO) << "directory '" << dir.string() << "' does not exist.";
     return;
   }
-  for (fs::directory_iterator it(dir), end;
-       it != end; ++it) {
+  fs::directory_iterator it(dir);
+  fs::directory_iterator end;
+  for (; it != end; ++it) {
     std::string file_path(it->path().string());
     if (boost::ends_with(file_path, ".schema.yaml")) {
       Config config;
       if (config.LoadFromFile(file_path)) {
         SchemaInfo info;
         // required properties
-        if (!config.GetString("schema/schema_id", &info.schema_id))
-          continue;
-        if (!config.GetString("schema/name", &info.name))
-          continue;
+        if (!config.GetString("schema/schema_id", &info.schema_id)) continue;
+        if (!config.GetString("schema/name", &info.name)) continue;
         // check for duplicates
         bool duplicated = false;
-        for (const SchemaInfo& other : available_) {
+        BOOST_FOREACH(const SchemaInfo& other, available_) {
           if (other.schema_id == info.schema_id) {
             duplicated = true;
             break;
           }
         }
-        if (duplicated)
-          continue;
+        if (duplicated) continue;
         // details
         config.GetString("schema/version", &info.version);
-        if (auto authors = config.GetList("schema/author")) {
+        ConfigListPtr authors = config.GetList("schema/author");
+        if (authors) {
           for (size_t i = 0; i < authors->size(); ++i) {
-            auto author = authors->GetValueAt(i);
+            ConfigValuePtr author = authors->GetValueAt(i);
             if (author && !author->str().empty()) {
               if (!info.author.empty())
                 info.author += "\n";
@@ -98,36 +97,34 @@ void SwitcherSettings::GetAvailableSchemasFromDirectory(const fs::path& dir) {
 }
 
 void SwitcherSettings::GetSelectedSchemasFromConfig() {
-  auto schema_list = config_.GetList("schema_list");
+  ConfigListPtr schema_list = config_.GetList("schema_list");
   if (!schema_list) {
     LOG(WARNING) << "schema list not defined.";
     return;
   }
-  for (auto it = schema_list->begin(); it != schema_list->end(); ++it) {
-    auto item = As<ConfigMap>(*it);
-    if (!item)
-      continue;
-    auto schema_property = item->GetValue("schema");
-    if (!schema_property)
-      continue;
-    const std::string& schema_id(schema_property->str());
+  ConfigList::Iterator it = schema_list->begin();
+  for (; it != schema_list->end(); ++it) {
+    ConfigMapPtr item = As<ConfigMap>(*it);
+    if (!item) continue;
+    ConfigValuePtr schema_property = item->GetValue("schema");
+    if (!schema_property) continue;
+    const std::string &schema_id(schema_property->str());
     selection_.push_back(schema_id);
   }
 }
 
 void SwitcherSettings::GetHotkeysFromConfig() {
-  auto hotkeys = config_.GetList("switcher/hotkeys");
+  ConfigListPtr hotkeys = config_.GetList("switcher/hotkeys");
   if (!hotkeys) {
     LOG(WARNING) << "hotkeys not defined.";
     return;
   }
-  for (auto it = hotkeys->begin(); it != hotkeys->end(); ++it) {
-    auto item = As<ConfigValue>(*it);
-    if (!item)
-      continue;
-    const std::string& hotkey(item->str());
-    if (hotkey.empty())
-      continue;
+  ConfigList::Iterator it = hotkeys->begin();
+  for (; it != hotkeys->end(); ++it) {
+    ConfigValuePtr item = As<ConfigValue>(*it);
+    if (!item) continue;
+    const std::string &hotkey(item->str());
+    if (hotkey.empty()) continue;
     if (!hotkeys_.empty())
       hotkeys_ += ", ";
     hotkeys_ += hotkey;
diff --git a/src/lever/user_dict_manager.cc b/src/lever/user_dict_manager.cc
index 601cfc2..456af48 100644
--- a/src/lever/user_dict_manager.cc
+++ b/src/lever/user_dict_manager.cc
@@ -7,6 +7,7 @@
 #include <fstream>
 #include <boost/algorithm/string.hpp>
 #include <boost/filesystem.hpp>
+#include <boost/foreach.hpp>
 #include <boost/scope_exit.hpp>
 #include <rime/common.h>
 #include <rime/deployer.h>
@@ -29,15 +30,16 @@ UserDictManager::UserDictManager(Deployer* deployer)
 }
 
 void UserDictManager::GetUserDictList(UserDictList* user_dict_list) {
-  if (!user_dict_list)
-    return;
+  if (!user_dict_list) return;
   user_dict_list->clear();
   if (!fs::exists(path_) || !fs::is_directory(path_)) {
     LOG(INFO) << "directory '" << path_.string() << "' does not exist.";
     return;
   }
-  for (fs::directory_iterator it(path_), end; it != end; ++it) {
-    std::string name = it->path().filename().string();
+  fs::directory_iterator it(path_);
+  fs::directory_iterator end;
+  for (; it != end; ++it) {
+    std::string name(it->path().filename().string());
     if (boost::ends_with(name, UserDb<TreeDb>::extension)) {
       boost::erase_last(name, UserDb<TreeDb>::extension);
       user_dict_list->push_back(name);
@@ -78,13 +80,12 @@ bool UserDictManager::Restore(const std::string& snapshot_file) {
   {
     temp.Close();
     temp.Remove();
-  }
-  BOOST_SCOPE_EXIT_END
+  } BOOST_SCOPE_EXIT_END
   if (!temp.Restore(snapshot_file))
     return false;
   if (!temp.IsUserDb())
     return false;
-  std::string db_name = temp.GetDbName();
+  std::string db_name(temp.GetDbName());
   if (db_name.empty())
     return false;
   UserDb<TreeDb> dest(db_name);
@@ -111,8 +112,7 @@ int UserDictManager::Export(const std::string& dict_name,
   BOOST_SCOPE_EXIT( (&db) )
   {
     db.Close();
-  }
-  BOOST_SCOPE_EXIT_END
+  } BOOST_SCOPE_EXIT_END
   if (!db.IsUserDb())
     return -1;
   TsvWriter writer(text_file, TableDb::format.formatter);
@@ -138,8 +138,7 @@ int UserDictManager::Import(const std::string& dict_name,
   BOOST_SCOPE_EXIT( (&db) )
   {
     db.Close();
-  }
-  BOOST_SCOPE_EXIT_END
+  } BOOST_SCOPE_EXIT_END
   if (!db.IsUserDb())
     return -1;
   TsvReader reader(text_file, TableDb::format.parser);
@@ -177,9 +176,9 @@ bool UserDictManager::UpgradeUserDict(const std::string& dict_name) {
         dict_name + UserDb<TextDb>::snapshot_extension;
     fs::path snapshot_path = trash / snapshot_file;
     return db.Backup(snapshot_path.string()) &&
-           db.Close() &&
-           db.Remove() &&
-           Restore(snapshot_path.string());
+        db.Close() &&
+        db.Remove() &&
+        Restore(snapshot_path.string());
   }
   return true;
 }
@@ -195,13 +194,15 @@ bool UserDictManager::Synchronize(const std::string& dict_name) {
       return false;
     }
   }
+  fs::directory_iterator it(sync_dir);
+  fs::directory_iterator end;
   // *.userdb.txt
   std::string snapshot_file =
       dict_name + UserDb<TextDb>::snapshot_extension;
   // *.userdb.kct.snapshot
   std::string legacy_snapshot_file =
       dict_name + UserDb<TreeDb>::extension + ".snapshot";
-  for (fs::directory_iterator it(sync_dir), end; it != end; ++it) {
+  for (; it != end; ++it) {
     if (!fs::is_directory(it->path()))
       continue;
     fs::path file_path = it->path() / snapshot_file;
@@ -229,7 +230,7 @@ bool UserDictManager::SynchronizeAll() {
   GetUserDictList(&user_dicts);
   LOG(INFO) << "synchronizing " << user_dicts.size() << " user dicts.";
   int failure = 0;
-  for (const std::string& dict_name : user_dicts) {
+  BOOST_FOREACH(const std::string& dict_name, user_dicts) {
     if (!Synchronize(dict_name))
       ++failure;
   }
diff --git a/src/lever/userdb_recovery_task.cc b/src/lever/userdb_recovery_task.cc
index 818e2fd..1b0d186 100644
--- a/src/lever/userdb_recovery_task.cc
+++ b/src/lever/userdb_recovery_task.cc
@@ -30,10 +30,9 @@ bool UserDbRecoveryTask::Run(Deployer* deployer) {
   }
   BOOST_SCOPE_EXIT( (&db_) ) {
     db_->enable();
-  }
-  BOOST_SCOPE_EXIT_END
+  } BOOST_SCOPE_EXIT_END
   //
-  auto r = As<Recoverable>(db_);
+  shared_ptr<Recoverable> r = As<Recoverable>(db_);
   if (r && r->Recover()) {
     return true;
   }
@@ -61,7 +60,7 @@ bool UserDbRecoveryTask::Run(Deployer* deployer) {
 }
 
 void UserDbRecoveryTask::RestoreUserDataFromSnapshot(Deployer* deployer) {
-  if (!Is<UserDb<TreeDb>>(db_))
+  if (!Is< UserDb<TreeDb> >(db_))
     return;
   std::string dict_name(db_->name());
   boost::erase_last(dict_name, UserDb<TreeDb>::extension);
@@ -87,7 +86,7 @@ void UserDbRecoveryTask::RestoreUserDataFromSnapshot(Deployer* deployer) {
 
 UserDbRecoveryTask* UserDbRecoveryTaskComponent::Create(TaskInitializer arg) {
   try {
-    auto db = boost::any_cast<shared_ptr<Db>>(arg);
+    shared_ptr<Db> db = boost::any_cast< shared_ptr<Db> >(arg);
     return new UserDbRecoveryTask(db);
   }
   catch (const boost::bad_any_cast&) {
diff --git a/src/module.cc b/src/module.cc
index 2999b63..bdc5a3d 100644
--- a/src/module.cc
+++ b/src/module.cc
@@ -25,8 +25,7 @@ RimeModule* ModuleManager::Find(const std::string& name) {
 
 void ModuleManager::LoadModule(RimeModule* module) {
   DLOG(INFO) << "loading module: " << module;
-  if (!module)
-    return;
+  if (!module) return;
   loaded_.push_back(module);
   if (module->initialize != NULL) {
     module->initialize();
@@ -37,7 +36,8 @@ void ModuleManager::LoadModule(RimeModule* module) {
 }
 
 void ModuleManager::UnloadModules() {
-  for (auto it = loaded_.cbegin(); it != loaded_.cend(); ++it) {
+  for (std::vector<RimeModule*>::const_iterator it = loaded_.begin();
+       it != loaded_.end(); ++it) {
     if ((*it)->finalize != NULL) {
       (*it)->finalize();
     }
@@ -46,7 +46,7 @@ void ModuleManager::UnloadModules() {
 }
 
 ModuleManager& ModuleManager::instance() {
-  static unique_ptr<ModuleManager> s_instance;
+  static scoped_ptr<ModuleManager> s_instance;
   if (!s_instance) {
     s_instance.reset(new ModuleManager);
   }
diff --git a/src/registry.cc b/src/registry.cc
index 15716d1..c57952a 100644
--- a/src/registry.cc
+++ b/src/registry.cc
@@ -45,7 +45,7 @@ ComponentBase* Registry::Find(const std::string &name) {
 }
 
 Registry& Registry::instance() {
-  static unique_ptr<Registry> s_instance;
+  static scoped_ptr<Registry> s_instance;
   if (!s_instance) {
     s_instance.reset(new Registry);
   }
diff --git a/src/rime_api.cc b/src/rime_api.cc
index c5bea15..d3bb161 100644
--- a/src/rime_api.cc
+++ b/src/rime_api.cc
@@ -5,8 +5,9 @@
 // 2011-08-09 GONG Chen <chen.sst@gmail.com>
 //
 #include <cstring>
-#include <functional>
 #include <sstream>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <boost/format.hpp>
 #include <rime/common.h>
 #include <rime/composition.h>
@@ -22,8 +23,6 @@
 #include <rime/signature.h>
 #include <rime_api.h>
 
-using namespace std::placeholders;
-
 // assuming member is a pointer in struct *p
 #define PROVIDED(p, member) ((p) && RIME_STRUCT_HAS_MEMBER(*(p), (p)->member) && (p)->member)
 
@@ -75,7 +74,7 @@ RIME_API void RimeSetNotificationHandler(RimeNotificationHandler handler,
                                          void* context_object) {
   if (handler) {
     rime::Service::instance().SetNotificationHandler(
-        std::bind(handler, context_object, _1, _2, _3));
+        boost::bind(handler, context_object, _1, _2, _3));
   }
   else {
     rime::Service::instance().ClearNotificationHandler();
@@ -201,21 +200,21 @@ RIME_API void RimeCleanupAllSessions() {
 // input
 
 RIME_API Bool RimeProcessKey(RimeSessionId session_id, int keycode, int mask) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   return Bool(session->ProcessKey(rime::KeyEvent(keycode, mask)));
 }
 
 RIME_API Bool RimeCommitComposition(RimeSessionId session_id) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   return Bool(session->CommitComposition());
 }
 
 RIME_API void RimeClearComposition(RimeSessionId session_id) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return;
   session->ClearComposition();
@@ -227,7 +226,7 @@ RIME_API Bool RimeGetContext(RimeSessionId session_id, RimeContext* context) {
   if (!context || context->data_size <= 0)
     return False;
   RIME_STRUCT_CLEAR(*context);
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   rime::Context *ctx = session->context();
@@ -258,7 +257,7 @@ RIME_API Bool RimeGetContext(RimeSessionId session_id, RimeContext* context) {
       page_size = schema->page_size();
     int selected_index = seg.selected_index;
     int page_no = selected_index / page_size;
-    rime::unique_ptr<rime::Page> page(seg.menu->CreatePage(page_size, page_no));
+    boost::scoped_ptr<rime::Page> page(seg.menu->CreatePage(page_size, page_no));
     if (page) {
       context->menu.page_size = page_size;
       context->menu.page_no = page_no;
@@ -267,7 +266,7 @@ RIME_API Bool RimeGetContext(RimeSessionId session_id, RimeContext* context) {
       int i = 0;
       context->menu.num_candidates = page->candidates.size();
       context->menu.candidates = new RimeCandidate[page->candidates.size()];
-      for (const rime::shared_ptr<rime::Candidate> &cand : page->candidates) {
+      BOOST_FOREACH(const boost::shared_ptr<rime::Candidate> &cand, page->candidates) {
         RimeCandidate* dest = &context->menu.candidates[i++];
         dest->text = new char[cand->text().length() + 1];
         std::strcpy(dest->text, cand->text().c_str());
@@ -313,7 +312,7 @@ RIME_API Bool RimeGetCommit(RimeSessionId session_id, RimeCommit* commit) {
   if (!commit)
     return False;
   RIME_STRUCT_CLEAR(*commit);
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   const std::string& commit_text(session->commit_text());
@@ -338,7 +337,7 @@ RIME_API Bool RimeGetStatus(RimeSessionId session_id, RimeStatus* status) {
   if (!status || status->data_size <= 0)
     return False;
   RIME_STRUCT_CLEAR(*status);
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   rime::Schema *schema = session->schema();
@@ -371,7 +370,7 @@ RIME_API Bool RimeFreeStatus(RimeStatus* status) {
 // runtime options
 
 RIME_API void RimeSetOption(RimeSessionId session_id, const char* option, Bool value) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return;
   rime::Context *ctx = session->context();
@@ -381,7 +380,7 @@ RIME_API void RimeSetOption(RimeSessionId session_id, const char* option, Bool v
 }
 
 RIME_API Bool RimeGetOption(RimeSessionId session_id, const char* option) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   rime::Context *ctx = session->context();
@@ -391,7 +390,7 @@ RIME_API Bool RimeGetOption(RimeSessionId session_id, const char* option) {
 }
 
 RIME_API void RimeSetProperty(RimeSessionId session_id, const char* prop, const char* value) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return;
   rime::Context *ctx = session->context();
@@ -402,7 +401,7 @@ RIME_API void RimeSetProperty(RimeSessionId session_id, const char* prop, const
 
 RIME_API Bool RimeGetProperty(RimeSessionId session_id, const char* prop,
                               char* value, size_t buffer_size) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   rime::Context *ctx = session->context();
@@ -463,7 +462,7 @@ RIME_API void RimeFreeSchemaList(RimeSchemaList* schema_list) {
 }
 
 RIME_API Bool RimeGetCurrentSchema(RimeSessionId session_id, char* schema_id, size_t buffer_size) {
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session) return False;
   rime::Schema* schema = session->schema();
   if (!schema) return False;
@@ -473,7 +472,7 @@ RIME_API Bool RimeGetCurrentSchema(RimeSessionId session_id, char* schema_id, si
 
 RIME_API Bool RimeSelectSchema(RimeSessionId session_id, const char* schema_id) {
   if (!schema_id) return False;
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session) return False;
   session->ApplySchema(new rime::Schema(schema_id));
   return True;
@@ -664,7 +663,7 @@ RIME_API void RimeConfigEnd(RimeConfigIterator* iterator) {
 
 RIME_API Bool RimeSimulateKeySequence(RimeSessionId session_id, const char *key_sequence) {
   LOG(INFO) << "simulate key sequence: " << key_sequence;
-  rime::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
+  boost::shared_ptr<rime::Session> session(rime::Service::instance().GetSession(session_id));
   if (!session)
     return False;
   rime::KeySequence keys;
@@ -672,7 +671,7 @@ RIME_API Bool RimeSimulateKeySequence(RimeSessionId session_id, const char *key_
     LOG(ERROR) << "error parsing input: '" << key_sequence << "'";
     return False;
   }
-  for (const rime::KeyEvent& key : keys) {
+  BOOST_FOREACH(const rime::KeyEvent& key, keys) {
     session->ProcessKey(key);
   }
   return True;
@@ -811,7 +810,7 @@ RIME_API Bool RimeConfigClear(RimeConfig* config, const char* key) {
   rime::Config* c = reinterpret_cast<rime::Config*>(config->ptr);
   if (!c)
     return False;
-  return Bool(c->SetItem(key, nullptr));
+  return Bool(c->SetItem(key, rime::ConfigItemPtr()));
 }
 
 RIME_API Bool RimeConfigCreateList(RimeConfig* config, const char* key) {
diff --git a/src/schema.cc b/src/schema.cc
index 7ab2708..08ab9e5 100644
--- a/src/schema.cc
+++ b/src/schema.cc
@@ -9,14 +9,14 @@
 
 namespace rime {
 
-Schema::Schema()
-    : schema_id_(".default") {
+Schema::Schema() : schema_id_(".default"),
+                   page_size_(5) {
   config_.reset(Config::Require("config")->Create("default"));
   FetchUsefulConfigItems();
 }
 
-Schema::Schema(const std::string& schema_id)
-    : schema_id_(schema_id) {
+Schema::Schema(const std::string &schema_id) : schema_id_(schema_id),
+                                               page_size_(5) {
   if (boost::starts_with(schema_id_, L".")) {
     config_.reset(Config::Require("config")->Create(schema_id.substr(1)));
   }
@@ -37,11 +37,10 @@ void Schema::FetchUsefulConfigItems() {
   if (!config_->GetInt("menu/page_size", &page_size_) &&
       schema_id_ != ".default") {
     // not defined in schema, use default setting
-    unique_ptr<Config> default_config(
+    scoped_ptr<Config> default_config(
         Config::Require("config")->Create("default"));
-    if (default_config) {
+    if (default_config)
       default_config->GetInt("menu/page_size", &page_size_);
-    }
   }
   config_->GetString("menu/alternative_select_keys", &select_keys_);
 }
diff --git a/src/segmentation.cc b/src/segmentation.cc
index 1ba6d17..1cc2b1f 100644
--- a/src/segmentation.cc
+++ b/src/segmentation.cc
@@ -7,6 +7,7 @@
 #include <algorithm>
 #include <iterator>
 #include <ostream>
+#include <boost/foreach.hpp>
 #include <rime/menu.h>
 #include <rime/segmentation.h>
 
@@ -14,8 +15,9 @@ namespace rime {
 
 shared_ptr<Candidate> Segment::GetCandidateAt(size_t index) const {
   if (!menu)
-    return nullptr;
-  return menu->GetCandidateAt(index);
+    return shared_ptr<Candidate>();
+  else
+    return menu->GetCandidateAt(index);
 }
 
 shared_ptr<Candidate> Segment::GetSelectedCandidate() const {
@@ -25,7 +27,7 @@ shared_ptr<Candidate> Segment::GetSelectedCandidate() const {
 Segmentation::Segmentation() {
 }
 
-void Segmentation::Reset(const std::string& new_input) {
+void Segmentation::Reset(const std::string &new_input) {
   DLOG(INFO) << "reset to " << size() << " segments.";
   // mark redo segmentation, while keeping user confirmed segments
   size_t diff_pos = 0;
@@ -41,8 +43,7 @@ void Segmentation::Reset(const std::string& new_input) {
     pop_back();
     ++disposed;
   }
-  if (disposed > 0)
-    Forward();
+  if (disposed > 0) Forward();
 
   input_ = new_input;
 }
@@ -53,7 +54,7 @@ void Segmentation::Reset(size_t num_segments) {
   resize(num_segments);
 }
 
-bool Segmentation::AddSegment(const Segment& segment) {
+bool Segmentation::AddSegment(const Segment &segment) {
   int start = GetCurrentStartPosition();
   if (segment.start != start) {
     // rule one: in one round, we examine only those segs
@@ -66,7 +67,7 @@ bool Segmentation::AddSegment(const Segment& segment) {
     return true;
   }
 
-  Segment& last = back();
+  Segment &last = back();
   if (last.end > segment.end) {
     // rule two: always prefer the longer segment...
   }
@@ -121,7 +122,7 @@ size_t Segmentation::GetCurrentSegmentLength() const {
 
 size_t Segmentation::GetConfirmedPosition() const {
   size_t k = 0;
-  for (const Segment& seg : *this) {
+  BOOST_FOREACH(const Segment &seg, *this) {
     if (seg.status >= Segment::kSelected)
       k = seg.end;
   }
@@ -129,14 +130,14 @@ size_t Segmentation::GetConfirmedPosition() const {
 }
 
 std::ostream& operator<< (std::ostream& out,
-                          const Segmentation& segmentation) {
+                          const Segmentation &segmentation) {
   out << "[" << segmentation.input();
-  for (const Segment& segment : segmentation) {
+  BOOST_FOREACH(const Segment &segment, segmentation) {
     out << "|" << segment.start << "," << segment.end;
     if (!segment.tags.empty()) {
       out << "{";
       bool first = true;
-      for (const std::string& tag : segment.tags) {
+      BOOST_FOREACH(const std::string& tag, segment.tags) {
         if (first)
           first = false;
         else
diff --git a/src/service.cc b/src/service.cc
index 5837713..1632507 100644
--- a/src/service.cc
+++ b/src/service.cc
@@ -4,21 +4,20 @@
 //
 // 2011-08-08 GONG Chen <chen.sst@gmail.com>
 //
+#include <boost/bind.hpp>
 #include <rime/context.h>
 #include <rime/engine.h>
 #include <rime/schema.h>
 #include <rime/service.h>
 
-using namespace std::placeholders;
-
 namespace rime {
 
-Session::Session() {
+Session::Session() : last_active_time_(0) {
   engine_.reset(Engine::Create());
-  engine_->sink().connect(std::bind(&Session::OnCommit, this, _1));
+  engine_->sink().connect(boost::bind(&Session::OnCommit, this, _1));
   SessionId session_id = reinterpret_cast<SessionId>(this);
   engine_->message_sink().connect(
-      std::bind(&Service::Notify, &Service::instance(), session_id, _1, _2));
+      boost::bind(&Service::Notify, &Service::instance(), session_id, _1, _2));
 }
 
 bool Session::ProcessKey(const KeyEvent& key_event) {
@@ -50,7 +49,7 @@ void Session::ApplySchema(Schema* schema) {
   engine_->ApplySchema(schema);
 }
 
-void Session::OnCommit(const std::string& commit_text) {
+void Session::OnCommit(const std::string &commit_text) {
   commit_text_ += commit_text;
 }
 
@@ -62,9 +61,9 @@ Schema* Session::schema() const {
   return engine_ ? engine_->schema() : NULL;
 }
 
-Service::Service() {
+Service::Service() : started_(false) {
   deployer_.message_sink().connect(
-      std::bind(&Service::Notify, this, 0, _1, _2));
+      boost::bind(&Service::Notify, this, 0, _1, _2));
 }
 
 Service::~Service() {
@@ -84,7 +83,7 @@ SessionId Service::CreateSession() {
   SessionId id = kInvalidSessionId;
   if (disabled()) return id;
   try {
-    auto session = New<Session>();
+    shared_ptr<Session> session = make_shared<Session>();
     session->Activate();
     id = reinterpret_cast<uintptr_t>(session.get());
     sessions_[id] = session;
@@ -108,19 +107,18 @@ SessionId Service::CreateSession() {
 }
 
 shared_ptr<Session> Service::GetSession(SessionId session_id) {
-  if (disabled())
-    return nullptr;
+  shared_ptr<Session> session;
+  if (disabled()) return session;
   SessionMap::iterator it = sessions_.find(session_id);
   if (it != sessions_.end()) {
-    auto& session = it->second;
+    session = it->second;
     session->Activate();
-    return session;
   }
-  return nullptr;
+  return session;
 }
 
 bool Service::DestroySession(SessionId session_id) {
-  auto it = sessions_.find(session_id);
+  SessionMap::iterator it = sessions_.find(session_id);
   if (it == sessions_.end())
     return false;
   sessions_.erase(it);
@@ -130,15 +128,15 @@ bool Service::DestroySession(SessionId session_id) {
 void Service::CleanupStaleSessions() {
   time_t now = time(NULL);
   int count = 0;
-  for (auto it = sessions_.begin(); it != sessions_.end(); ) {
+  for (SessionMap::iterator it = sessions_.begin();
+       it != sessions_.end(); ) {
     if (it->second &&
         it->second->last_active_time() < now - Session::kLifeSpan) {
       sessions_.erase(it++);
       ++count;
     }
-    else {
+    else
       ++it;
-    }
   }
   if (count > 0) {
     LOG(INFO) << "Recycled " << count << " stale sessions.";
@@ -154,22 +152,21 @@ void Service::SetNotificationHandler(const NotificationHandler& handler) {
 }
 
 void Service::ClearNotificationHandler() {
-  notification_handler_ = nullptr;
+  notification_handler_.clear();
 }
 
 void Service::Notify(SessionId session_id,
                      const std::string& message_type,
                      const std::string& message_value) {
   if (notification_handler_) {
-    std::lock_guard<std::mutex> lock(mutex_);
+    boost::lock_guard<boost::mutex> lock(mutex_);
     notification_handler_(session_id,
-                          message_type.c_str(),
-                          message_value.c_str());
+                          message_type.c_str(), message_value.c_str());
   }
 }
 
 Service& Service::instance() {
-  static unique_ptr<Service> s_instance;
+  static scoped_ptr<Service> s_instance;
   if (!s_instance) {
     s_instance.reset(new Service);
   }
diff --git a/src/switcher.cc b/src/switcher.cc
index e6750ce..f69cee8 100644
--- a/src/switcher.cc
+++ b/src/switcher.cc
@@ -5,6 +5,8 @@
 // 2011-12-07 GONG Chen <chen.sst@gmail.com>
 //
 #include <string>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/common.h>
 #include <rime/composition.h>
@@ -21,12 +23,15 @@
 
 namespace rime {
 
-Switcher::Switcher(const Ticket& ticket) : Processor(ticket) {
+Switcher::Switcher(const Ticket& ticket)
+    : Processor(ticket),
+      fold_options_(false),
+      active_(false) {
   context_->set_option("dumb", true);  // not going to commit anything
 
   // receive context notifications
   context_->select_notifier().connect(
-      [this](Context* ctx) { OnSelect(ctx); });
+      boost::bind(&Switcher::OnSelect, this, _1));
 
   user_config_.reset(Config::Require("config")->Create("user"));
   InitializeComponents();
@@ -42,7 +47,7 @@ Switcher::~Switcher() {
 
 void Switcher::RestoreSavedOptions() {
   if (user_config_) {
-    for (const std::string& option_name : save_options_) {
+    BOOST_FOREACH(const std::string& option_name, save_options_) {
       bool value = false;
       if (user_config_->GetBool("var/option/" + option_name, &value)) {
         engine_->context()->set_option(option_name, value);
@@ -52,7 +57,7 @@ void Switcher::RestoreSavedOptions() {
 }
 
 ProcessResult Switcher::ProcessKeyEvent(const KeyEvent& key_event) {
-  for (const KeyEvent& hotkey : hotkeys_) {
+  BOOST_FOREACH(const KeyEvent& hotkey, hotkeys_) {
     if (key_event == hotkey) {
       if (!active_ && engine_) {
         Activate();
@@ -64,7 +69,7 @@ ProcessResult Switcher::ProcessKeyEvent(const KeyEvent& key_event) {
     }
   }
   if (active_) {
-    for (auto& p : processors_) {
+    BOOST_FOREACH(shared_ptr<Processor>& p, processors_) {
       ProcessResult result = p->ProcessKeyEvent(key_event);
       if (result != kNoop) {
         return result;
@@ -86,7 +91,7 @@ ProcessResult Switcher::ProcessKeyEvent(const KeyEvent& key_event) {
 }
 
 void Switcher::HighlightNextSchema() {
-  Composition* comp = context_->composition();
+  Composition *comp = context_->composition();
   if (!comp || comp->empty() || !comp->back().menu)
     return;
   Segment& seg(comp->back());
@@ -113,7 +118,7 @@ Schema* Switcher::CreateSchema() {
   Config* config = schema_->config();
   if (!config)
     return NULL;
-  auto schema_list = config->GetList("schema_list");
+  ConfigListPtr schema_list = config->GetList("schema_list");
   if (!schema_list)
     return NULL;
   std::string previous;
@@ -122,10 +127,10 @@ Schema* Switcher::CreateSchema() {
   }
   std::string recent;
   for (size_t i = 0; i < schema_list->size(); ++i) {
-    auto item = As<ConfigMap>(schema_list->GetAt(i));
+    ConfigMapPtr item = As<ConfigMap>(schema_list->GetAt(i));
     if (!item)
       continue;
-    auto schema_property = item->GetValue("schema");
+    ConfigValuePtr schema_property = item->GetValue("schema");
     if (!schema_property)
       continue;
     const std::string& schema_id(schema_property->str());
@@ -143,18 +148,15 @@ Schema* Switcher::CreateSchema() {
 }
 
 void Switcher::SelectNextSchema() {
-  if (translators_.empty())
-    return;
-  auto xlator = translators_[0];  // schema_list_translator
-  if (!xlator)
-    return;
+  if (translators_.empty()) return;
+  shared_ptr<Translator> x = translators_[0];  // schema_list_translator
+  if (!x) return;
   Menu menu;
-  menu.AddTranslation(xlator->Query("", Segment(), NULL));
-  if (menu.Prepare(2) < 2)
-    return;
-  auto command = As<SwitcherCommand>(menu.GetCandidateAt(1));
-  if (!command)
-    return;
+  menu.AddTranslation(x->Query("", Segment(), NULL));
+  if (menu.Prepare(2) < 2) return;
+  shared_ptr<SwitcherCommand> command =
+      As<SwitcherCommand>(menu.GetCandidateAt(1));
+  if (!command) return;
   command->Apply(this);
 }
 
@@ -162,10 +164,11 @@ bool Switcher::IsAutoSave(const std::string& option) const {
   return save_options_.find(option) != save_options_.end();
 }
 
-void Switcher::OnSelect(Context* ctx) {
+void Switcher::OnSelect(Context *ctx) {
   LOG(INFO) << "a switcher option is selected.";
   Segment& seg(ctx->composition()->back());
-  if (auto command = As<SwitcherCommand>(seg.GetSelectedCandidate())) {
+  if (shared_ptr<SwitcherCommand> command =
+      As<SwitcherCommand>(seg.GetSelectedCandidate())) {
     command->Apply(this);
   }
 }
@@ -178,12 +181,12 @@ void Switcher::RefreshMenu() {
     seg.prompt = caption_;
     comp->AddSegment(seg);
   }
-  auto menu = New<Menu>();
+  shared_ptr<Menu> menu = make_shared<Menu>();
   comp->back().menu = menu;
-  for (auto& translator : translators_) {
-    if (auto t = translator->Query("", comp->back(), NULL)) {
+  BOOST_FOREACH(shared_ptr<Translator>& translator, translators_) {
+    shared_ptr<Translation> t = translator->Query("", comp->back(), NULL);
+    if (t)
       menu->AddTranslation(t);
-    }
   }
 }
 
@@ -202,25 +205,25 @@ void Switcher::Deactivate() {
 }
 
 void Switcher::LoadSettings() {
-  Config* config = schema_->config();
-  if (!config)
-    return;
+  Config *config = schema_->config();
+  if (!config) return;
   if (!config->GetString("switcher/caption", &caption_) || caption_.empty()) {
     caption_ = ":-)";
   }
-  if (auto hotkeys = config->GetList("switcher/hotkeys")) {
+  if (ConfigListPtr hotkeys = config->GetList("switcher/hotkeys")) {
     hotkeys_.clear();
     for (size_t i = 0; i < hotkeys->size(); ++i) {
-      auto value = hotkeys->GetValueAt(i);
+      ConfigValuePtr value = hotkeys->GetValueAt(i);
       if (!value)
         continue;
       hotkeys_.push_back(KeyEvent(value->str()));
     }
   }
-  if (auto options = config->GetList("switcher/save_options")) {
+  if (ConfigListPtr options = config->GetList("switcher/save_options")) {
     save_options_.clear();
-    for (auto it = options->begin(); it != options->end(); ++it) {
-      auto option_name = As<ConfigValue>(*it);
+    for (ConfigList::Iterator it = options->begin();
+         it != options->end(); ++it) {
+      ConfigValuePtr option_name = As<ConfigValue>(*it);
       if (!option_name)
         continue;
       save_options_.insert(option_name->str());
@@ -232,34 +235,46 @@ void Switcher::LoadSettings() {
 void Switcher::InitializeComponents() {
   processors_.clear();
   translators_.clear();
-  if (auto c = Processor::Require("key_binder")) {
-    shared_ptr<Processor> p(c->Create(Ticket(this)));
-    processors_.push_back(p);
-  }
-  else {
-    LOG(WARNING) << "key_binder not available.";
-  }
-  if (auto c = Processor::Require("selector")) {
-    shared_ptr<Processor> p(c->Create(Ticket(this)));
-    processors_.push_back(p);
+  {
+    Processor::Component* c = Processor::Require("key_binder");
+    if (!c) {
+      LOG(WARNING) << "key_binder not available.";
+    }
+    else {
+      shared_ptr<Processor> p(c->Create(Ticket(this)));
+      processors_.push_back(p);
+    }
   }
-  else {
-    LOG(WARNING) << "selector not available.";
+  {
+    Processor::Component* c = Processor::Require("selector");
+    if (!c) {
+      LOG(WARNING) << "selector not available.";
+    }
+    else {
+      shared_ptr<Processor> p(c->Create(Ticket(this)));
+      processors_.push_back(p);
+    }
   }
   DLOG(INFO) << "num processors: " << processors_.size();
-  if (auto c = Translator::Require("schema_list_translator")) {
-    shared_ptr<Translator> t(c->Create(Ticket(this)));
-    translators_.push_back(t);
-  }
-  else {
-    LOG(WARNING) << "schema_list_translator not available.";
-  }
-  if (auto c = Translator::Require("switch_translator")) {
-    shared_ptr<Translator> t(c->Create(Ticket(this)));
-    translators_.push_back(t);
+  {
+    Translator::Component* c = Translator::Require("schema_list_translator");
+    if (!c) {
+      LOG(WARNING) << "schema_list_translator not available.";
+    }
+    else {
+      shared_ptr<Translator> t(c->Create(Ticket(this)));
+      translators_.push_back(t);
+    }
   }
-  else {
-    LOG(WARNING) << "switch_translator not available.";
+  {
+    Translator::Component* c = Translator::Require("switch_translator");
+    if (!c) {
+      LOG(WARNING) << "switch_translator not available.";
+    }
+    else {
+      shared_ptr<Translator> t(c->Create(Ticket(this)));
+      translators_.push_back(t);
+    }
   }
   DLOG(INFO) << "num translators: " << translators_.size();
 }
diff --git a/src/ticket.cc b/src/ticket.cc
index 700a8c8..13340cc 100644
--- a/src/ticket.cc
+++ b/src/ticket.cc
@@ -9,8 +9,12 @@
 
 namespace rime {
 
+Ticket::Ticket()
+    : engine(NULL), schema(NULL) {
+}
+
 Ticket::Ticket(Schema* s, const std::string& ns)
-    : schema(s), name_space(ns) {
+    : engine(NULL), schema(s), name_space(ns) {
 }
 
 Ticket::Ticket(Engine* e, const std::string& ns,
diff --git a/src/translation.cc b/src/translation.cc
index 42ee278..e1b3b8f 100644
--- a/src/translation.cc
+++ b/src/translation.cc
@@ -10,24 +10,20 @@
 namespace rime {
 
 int Translation::Compare(shared_ptr<Translation> other,
-                         const CandidateList& candidates) {
-  if (!other || other->exhausted())
-    return -1;
-  if (exhausted())
-    return 1;
-  auto ours = Peek();
-  auto theirs = other->Peek();
-  if (!ours || !theirs)
-    return 1;
+                         const CandidateList &candidates) {
+  if (!other || other->exhausted()) return -1;
+  if (exhausted()) return 1;
+  shared_ptr<const Candidate> ours = Peek();
+  shared_ptr<const Candidate> theirs = other->Peek();
+  if (!ours) return 1;
+  if (!theirs) return -1;
   int k = 0;
   // the one nearer to the beginning of segment comes first
   k = ours->start() - theirs->start();
-  if (k != 0)
-    return k;
+  if (k != 0) return k;
   // then the longer comes first
   k = ours->end() - theirs->end();
-  if (k != 0)
-    return -k;
+  if (k != 0) return -k;
   // compare quality
   double qdiff = ours->quality() - theirs->quality();
   if (qdiff != 0.)
@@ -45,11 +41,11 @@ bool UniqueTranslation::Next() {
 
 shared_ptr<Candidate> UniqueTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   return candidate_;
 }
 
-FifoTranslation::FifoTranslation() {
+FifoTranslation::FifoTranslation() : cursor_(0) {
   set_exhausted(true);
 }
 
@@ -63,7 +59,7 @@ bool FifoTranslation::Next() {
 
 shared_ptr<Candidate> FifoTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   return candies_[cursor_];
 }
 
@@ -91,7 +87,7 @@ bool UnionTranslation::Next() {
 
 shared_ptr<Candidate> UnionTranslation::Peek() {
   if (exhausted())
-    return nullptr;
+    return shared_ptr<Candidate>();
   return translations_.front()->Peek();
 }
 
@@ -105,10 +101,10 @@ UnionTranslation& UnionTranslation::operator+= (shared_ptr<Translation> t) {
 
 shared_ptr<UnionTranslation> operator+ (shared_ptr<Translation> a,
                                         shared_ptr<Translation> b) {
-  auto c = New<UnionTranslation>();
+  shared_ptr<UnionTranslation> c = New<UnionTranslation>();
   *c += a;
   *c += b;
-  return c->exhausted() ? nullptr : c;
+  return c->exhausted() ? shared_ptr<UnionTranslation>() : c;
 }
 
 }  // namespace rime
diff --git a/test/algebra_test.cc b/test/algebra_test.cc
index 992dac9..8a961af 100644
--- a/test/algebra_test.cc
+++ b/test/algebra_test.cc
@@ -8,8 +8,7 @@
 #include <rime/common.h>
 #include <rime/algo/algebra.h>
 
-static const char* kTransliteration =
-    "xlit/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/";
+static const char* kTransliteration = "xlit/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/";
 static const char* kTransformation = "xform/^([zcs])h(.*)$/$1$2/";
 
 static const int kNumOfInstructions = 5;
@@ -22,9 +21,9 @@ static const char* kInstructions[kNumOfInstructions] = {
 };
 
 TEST(RimeAlgebraTest, SpellingManipulation) {
-  auto c = rime::New<rime::ConfigList>();
-  c->Append(rime::New<rime::ConfigValue>(kTransliteration));
-  c->Append(rime::New<rime::ConfigValue>(kTransformation));
+  rime::ConfigListPtr c = boost::make_shared<rime::ConfigList>();
+  c->Append(boost::make_shared<rime::ConfigValue>(kTransliteration));
+  c->Append(boost::make_shared<rime::ConfigValue>(kTransformation));
   rime::Projection p;
   ASSERT_TRUE(p.Load(c));
 
@@ -34,9 +33,9 @@ TEST(RimeAlgebraTest, SpellingManipulation) {
 }
 
 TEST(RimeAlgebraTest, Projection) {
-  auto c = rime::New<rime::ConfigList>();
+  rime::ConfigListPtr c = boost::make_shared<rime::ConfigList>();
   for (int i = 0; i < kNumOfInstructions; ++i) {
-    c->Append(rime::New<rime::ConfigValue>(kInstructions[i]));
+    c->Append(boost::make_shared<rime::ConfigValue>(kInstructions[i]));
   }
   rime::Projection p;
   ASSERT_TRUE(p.Load(c));
diff --git a/test/calculus_test.cc b/test/calculus_test.cc
index 6794d51..1bae7a9 100644
--- a/test/calculus_test.cc
+++ b/test/calculus_test.cc
@@ -8,8 +8,7 @@
 #include <rime/common.h>
 #include <rime/algo/calculus.h>
 
-static const char* kTransliteration =
-    "xlit abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ";
+static const char* kTransliteration = "xlit abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ";
 static const char* kTransformation = "xform/^([zcs])h(.*)$/$1$2/";
 static const char* kErasion = "erase/^[czs]h[aoe]ng?$/";
 static const char* kDerivation = "derive/^([zcs])h/$1/";
@@ -17,8 +16,8 @@ static const char* kAbbreviation = "abbrev/^([zcs]h).*$/$1/";
 
 TEST(RimeCalculusTest, Transliteration) {
   rime::Calculus calc;
-  rime::unique_ptr<rime::Calculation> c(calc.Parse(kTransliteration));
-  ASSERT_TRUE(bool(c));
+  boost::scoped_ptr<rime::Calculation> c(calc.Parse(kTransliteration));
+  ASSERT_TRUE(c);
   rime::Spelling s("abracadabra");
   EXPECT_TRUE(c->Apply(&s));
   EXPECT_EQ("ABRACADABRA", s.str);
@@ -26,8 +25,8 @@ TEST(RimeCalculusTest, Transliteration) {
 
 TEST(RimeCalculusTest, Transformation) {
   rime::Calculus calc;
-  rime::unique_ptr<rime::Calculation> c(calc.Parse(kTransformation));
-  ASSERT_TRUE(bool(c));
+  boost::scoped_ptr<rime::Calculation> c(calc.Parse(kTransformation));
+  ASSERT_TRUE(c);
   rime::Spelling s("shang");
   EXPECT_TRUE(c->Apply(&s));
   EXPECT_EQ("sang", s.str);
@@ -38,8 +37,8 @@ TEST(RimeCalculusTest, Transformation) {
 
 TEST(RimeCalculusTest, Erasion) {
   rime::Calculus calc;
-  rime::unique_ptr<rime::Calculation> c(calc.Parse(kErasion));
-  ASSERT_TRUE(bool(c));
+  boost::scoped_ptr<rime::Calculation> c(calc.Parse(kErasion));
+  ASSERT_TRUE(c);
   EXPECT_FALSE(c->addition());
   EXPECT_TRUE(c->deletion());
   rime::Spelling s("shang");
@@ -52,8 +51,8 @@ TEST(RimeCalculusTest, Erasion) {
 
 TEST(RimeCalculusTest, Derivation) {
   rime::Calculus calc;
-  rime::unique_ptr<rime::Calculation> c(calc.Parse(kDerivation));
-  ASSERT_TRUE(bool(c));
+  boost::scoped_ptr<rime::Calculation> c(calc.Parse(kDerivation));
+  ASSERT_TRUE(c);
   EXPECT_TRUE(c->addition());
   EXPECT_FALSE(c->deletion());
   rime::Spelling s("shang");
@@ -66,8 +65,8 @@ TEST(RimeCalculusTest, Derivation) {
 
 TEST(RimeCalculusTest, Abbreviation) {
   rime::Calculus calc;
-  rime::unique_ptr<rime::Calculation> c(calc.Parse(kAbbreviation));
-  ASSERT_TRUE(bool(c));
+  boost::scoped_ptr<rime::Calculation> c(calc.Parse(kAbbreviation));
+  ASSERT_TRUE(c);
   EXPECT_TRUE(c->addition());
   EXPECT_FALSE(c->deletion());
   rime::Spelling s("shang");
diff --git a/test/component_test.cc b/test/component_test.cc
index 569a03b..db16ea9 100644
--- a/test/component_test.cc
+++ b/test/component_test.cc
@@ -13,14 +13,14 @@ using namespace rime;
 class Greeting : public Class<Greeting, const std::string&> {
  public:
   virtual std::string Say() = 0;
-  virtual ~Greeting() = default;
+  virtual ~Greeting() {}
 };
 
-using HelloMessage = std::pair<std::string, std::string>;
+typedef std::pair<std::string, std::string> HelloMessage;
 
 class Hello : public Greeting {
  public:
-  Hello(const HelloMessage& msg) : word_(msg.first), name_(msg.second) {
+  Hello(const HelloMessage &msg) : word_(msg.first), name_(msg.second) {
   }
   std::string Say() {
     return word_ + ", " + name_ + "!";
@@ -33,9 +33,9 @@ class Hello : public Greeting {
 // customize a hello component with parameters
 class HelloComponent : public Hello::Component {
  public:
-  HelloComponent(const std::string& word) : word_(word) {}
+  HelloComponent(const std::string &word) : word_(word) {}
   // define a custom creator to provide an additional argument
-  Hello* Create(const std::string& name) {
+  Hello* Create(const std::string &name) {
     return new Hello(std::make_pair(word_, name));
   }
  private:
@@ -44,7 +44,7 @@ class HelloComponent : public Hello::Component {
 
 
 TEST(RimeComponentTest, UsingComponent) {
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
   r.Register("test_hello", new HelloComponent("hello"));
   r.Register("test_morning", new HelloComponent("good morning"));
 
@@ -53,7 +53,7 @@ TEST(RimeComponentTest, UsingComponent) {
   Greeting::Component* gm = Greeting::Require("test_morning");
   EXPECT_TRUE(gm != NULL);
 
-  unique_ptr<Greeting> g(gm->Create("michael"));
+  scoped_ptr<Greeting> g(gm->Create("michael"));
   EXPECT_STREQ("good morning, michael!", g->Say().c_str());
 
   r.Unregister("test_hello");
diff --git a/test/config_test.cc b/test/config_test.cc
index 162333f..3b62560 100644
--- a/test/config_test.cc
+++ b/test/config_test.cc
@@ -13,7 +13,7 @@ using namespace rime;
 
 class RimeConfigTest : public ::testing::Test {
  protected:
-  RimeConfigTest() = default;
+  RimeConfigTest() {}
 
   virtual void SetUp() {
     component_.reset(new ConfigComponent("%s.yaml"));
@@ -23,20 +23,20 @@ class RimeConfigTest : public ::testing::Test {
   virtual void TearDown() {
   }
 
-  unique_ptr<Config::Component> component_;
-  unique_ptr<Config> config_;
+  scoped_ptr<Config::Component> component_;
+  scoped_ptr<Config> config_;
 };
 
 TEST(RimeConfigComponentTest, RealCreationWorkflow) {
   // registration
-  Registry& r = Registry::instance();
+  Registry &r = Registry::instance();
   r.Register("test_config", new ConfigComponent("%s.yaml"));
   // finding component
-  Config::Component* cc = Config::Require("test_config");
+  Config::Component *cc = Config::Require("test_config");
   ASSERT_TRUE(cc != NULL);
   // creation
-  unique_ptr<Config> config(cc->Create("config_test"));
-  EXPECT_TRUE(bool(config));
+  scoped_ptr<Config> config(cc->Create("config_test"));
+  EXPECT_TRUE(config);
   r.Unregister("test_config");
 }
 
@@ -103,16 +103,16 @@ TEST_F(RimeConfigTest, Config_GetString) {
 TEST_F(RimeConfigTest, Config_GetList) {
   ConfigListPtr p;
   p = config_->GetList("protoss/air_force");
-  ASSERT_TRUE(bool(p));
+  ASSERT_TRUE(p);
   ASSERT_EQ(4, p->size());
   ConfigValuePtr element;
   std::string value;
   element = p->GetValueAt(0);
-  ASSERT_TRUE(bool(element));
+  ASSERT_TRUE(element);
   ASSERT_TRUE(element->GetString(&value));
   EXPECT_EQ("scout", value);
   element = p->GetValueAt(3);
-  ASSERT_TRUE(bool(element));
+  ASSERT_TRUE(element);
   ASSERT_TRUE(element->GetString(&value));
   EXPECT_EQ("arbiter", value);
 
@@ -121,7 +121,7 @@ TEST_F(RimeConfigTest, Config_GetList) {
 TEST_F(RimeConfigTest, Config_GetMap) {
   ConfigMapPtr p;
   p = config_->GetMap("terrans/tank/cost");
-  ASSERT_TRUE(bool(p));
+  ASSERT_TRUE(p);
   EXPECT_FALSE(p->HasKey("rime"));
   ASSERT_TRUE(p->HasKey("time"));
   ConfigValuePtr item;
@@ -129,28 +129,28 @@ TEST_F(RimeConfigTest, Config_GetMap) {
   int mineral = 0;
   int gas = 0;
   item = p->GetValue("time");
-  ASSERT_TRUE(bool(item));
+  ASSERT_TRUE(item);
   ASSERT_TRUE(item->GetString(&time));
   EXPECT_EQ("30 seconds", time);
   item = p->GetValue("mineral");
-  ASSERT_TRUE(bool(item));
+  ASSERT_TRUE(item);
   ASSERT_TRUE(item->GetInt(&mineral));
   EXPECT_EQ(150, mineral);
   item = p->GetValue("gas");
-  ASSERT_TRUE(bool(item));
+  ASSERT_TRUE(item);
   ASSERT_TRUE(item->GetInt(&gas));
   EXPECT_EQ(100, gas);
 }
 
 TEST(RimeConfigWriterTest, Greetings) {
-  unique_ptr<Config> config(new Config);
-  ASSERT_TRUE(bool(config));
+  scoped_ptr<Config> config(new Config);
+  ASSERT_TRUE(config);
   // creating contents
-  EXPECT_TRUE(config->SetItem("/", New<ConfigMap>()));
-  ConfigItemPtr terran_greetings = New<ConfigValue>("Greetings, Terrans!");
-  ConfigItemPtr zerg_greetings = New<ConfigValue>("Zergsss are coming!");
-  ConfigItemPtr zergs_coming = New<ConfigValue>(true);
-  ConfigItemPtr zergs_population = New<ConfigValue>(1000000);
+  EXPECT_TRUE(config->SetItem("/", make_shared<ConfigMap>()));
+  ConfigItemPtr terran_greetings = make_shared<ConfigValue>("Greetings, Terrans!");
+  ConfigItemPtr zerg_greetings = make_shared<ConfigValue>("Zergsss are coming!");
+  ConfigItemPtr zergs_coming = make_shared<ConfigValue>(true);
+  ConfigItemPtr zergs_population = make_shared<ConfigValue>(1000000);
   EXPECT_TRUE(config->SetItem("greetings", terran_greetings));
   EXPECT_TRUE(config->SetItem("zergs/overmind/greetings", zerg_greetings));
   EXPECT_TRUE(config->SetItem("zergs/going", zergs_coming));
@@ -160,8 +160,8 @@ TEST(RimeConfigWriterTest, Greetings) {
   // saving
   EXPECT_TRUE(config->SaveToFile("config_writer_test.yaml"));
   // verify
-  unique_ptr<Config> config2(new Config);
-  ASSERT_TRUE(bool(config2));
+  scoped_ptr<Config> config2(new Config);
+  ASSERT_TRUE(config2);
   EXPECT_TRUE(config2->LoadFromFile("config_writer_test.yaml"));
   std::string the_greetings;
   EXPECT_TRUE(config2->GetString("greetings", &the_greetings));
@@ -181,8 +181,8 @@ TEST(RimeConfigWriterTest, Greetings) {
   EXPECT_TRUE(config2->SetItem("zergs/overmind", ConfigItemPtr()));
   EXPECT_TRUE(config2->SaveToFile("config_rewriter_test.yaml"));
   // verify
-  unique_ptr<Config> config3(new Config);
-  ASSERT_TRUE(bool(config3));
+  scoped_ptr<Config> config3(new Config);
+  ASSERT_TRUE(config3);
   EXPECT_TRUE(config3->LoadFromFile("config_rewriter_test.yaml"));
   EXPECT_TRUE(config3->GetInt("zergs/statistics/population", &population));
   EXPECT_EQ(500000, population);
@@ -233,7 +233,7 @@ TEST(RimeConfigxxTest, Operations) {
 TEST(RimeConfigListKeyPathTest, Greetings) {
   int id = 0;
   int value = 0;
-  unique_ptr<Config> config(new Config);
+  scoped_ptr<Config> config(new Config);
   ASSERT_TRUE(bool(config));
   // append items
   EXPECT_TRUE(config->SetInt("list/@next/id", 1));
diff --git a/test/dictionary_test.cc b/test/dictionary_test.cc
index 605e6ad..ce9bc3f 100644
--- a/test/dictionary_test.cc
+++ b/test/dictionary_test.cc
@@ -17,8 +17,8 @@ class RimeDictionaryTest : public ::testing::Test {
     if (!dict_) {
       dict_.reset(new rime::Dictionary(
           "dictionary_test",
-          rime::New<rime::Table>("dictionary_test.table.bin"),
-          rime::New<rime::Prism>("dictionary_test.prism.bin")));
+          boost::make_shared<rime::Table>("dictionary_test.table.bin"),
+          boost::make_shared<rime::Prism>("dictionary_test.prism.bin")));
     }
     if (!rebuilt_) {
       dict_->Remove();
@@ -32,11 +32,11 @@ class RimeDictionaryTest : public ::testing::Test {
     dict_.reset();
   }
  protected:
-  static rime::unique_ptr<rime::Dictionary> dict_;
+  static boost::scoped_ptr<rime::Dictionary> dict_;
   static bool rebuilt_;
 };
 
-rime::unique_ptr<rime::Dictionary> RimeDictionaryTest::dict_;
+boost::scoped_ptr<rime::Dictionary> RimeDictionaryTest::dict_;
 bool RimeDictionaryTest::rebuilt_ = false;
 
 TEST_F(RimeDictionaryTest, Ready) {
@@ -74,14 +74,14 @@ TEST_F(RimeDictionaryTest, ScriptLookup) {
   std::string input("shurufa");
   ASSERT_TRUE(s.BuildSyllableGraph(input, *dict_->prism(), &g) > 0);
   EXPECT_EQ(g.interpreted_length, g.input_length);
-  auto c = dict_->Lookup(g, 0);
-  ASSERT_TRUE(bool(c));
+  boost::shared_ptr<rime::DictEntryCollector> c(dict_->Lookup(g, 0));
+  ASSERT_TRUE(c);
 
   ASSERT_TRUE(c->find(3) != c->end());
   rime::DictEntryIterator d3((*c)[3]);
   EXPECT_FALSE(d3.exhausted());
-  auto e1 = d3.Peek();
-  ASSERT_TRUE(bool(e1));
+  boost::shared_ptr<const rime::DictEntry> e1(d3.Peek());
+  ASSERT_TRUE(e1);
   EXPECT_EQ(1, e1->code.size());
   EXPECT_EQ(3, e1->text.length());
   EXPECT_TRUE(d3.Next());
@@ -89,15 +89,15 @@ TEST_F(RimeDictionaryTest, ScriptLookup) {
   ASSERT_TRUE(c->find(5) != c->end());
   rime::DictEntryIterator d5((*c)[5]);
   EXPECT_FALSE(d5.exhausted());
-  auto e2 = d5.Peek();
-  ASSERT_TRUE(bool(e2));
+  boost::shared_ptr<const rime::DictEntry> e2(d5.Peek());
+  ASSERT_TRUE(e2);
   EXPECT_EQ(2, e2->code.size());
 
   ASSERT_TRUE(c->find(7) != c->end());
   rime::DictEntryIterator d7((*c)[7]);
   EXPECT_FALSE(d7.exhausted());
-  auto e3 = d7.Peek();
-  ASSERT_TRUE(bool(e3));
+  boost::shared_ptr<const rime::DictEntry> e3(d7.Peek());
+  ASSERT_TRUE(e3);
   EXPECT_EQ(3, e3->code.size());
   EXPECT_EQ(9, e3->text.length());
   EXPECT_FALSE(d7.Next());
diff --git a/test/encoder_test.cc b/test/encoder_test.cc
index 7e840d7..fa484c0 100644
--- a/test/encoder_test.cc
+++ b/test/encoder_test.cc
@@ -21,7 +21,7 @@ TEST(RimeEncoderTest, Settings) {
   rime::TableEncoder encoder;
   encoder.LoadSettings(&config);
   EXPECT_TRUE(encoder.loaded());
-  const auto& rules(encoder.encoding_rules());
+  const std::vector<rime::TableEncodingRule>& rules(encoder.encoding_rules());
   ASSERT_EQ(3, rules.size());
   EXPECT_EQ(2, rules[0].min_word_length);
   EXPECT_EQ(2, rules[0].max_word_length);
diff --git a/test/menu_test.cc b/test/menu_test.cc
index 1db324d..f15ea96 100644
--- a/test/menu_test.cc
+++ b/test/menu_test.cc
@@ -23,17 +23,17 @@ class TranslationAlpha : public Translation {
   }
   shared_ptr<Candidate> Peek() {
     if (exhausted())
-      return nullptr;
-    return New<SimpleCandidate>("alpha", 0, 5, "Alpha");
+      return shared_ptr<Candidate>();
+    return make_shared<SimpleCandidate>("alpha", 0, 5, "Alpha");
   }
 };
 
 class TranslationBeta : public Translation {
  public:
   TranslationBeta() : cursor_(0) {
-    candies_.push_back(New<SimpleCandidate>("beta", 0, 4, "Beta-1"));
-    candies_.push_back(New<SimpleCandidate>("beta", 0, 4, "Beta-2"));
-    candies_.push_back(New<SimpleCandidate>("beta", 0, 4, "Beta-3"));
+    candies_.push_back(make_shared<SimpleCandidate>("beta", 0, 4, "Beta-1"));
+    candies_.push_back(make_shared<SimpleCandidate>("beta", 0, 4, "Beta-2"));
+    candies_.push_back(make_shared<SimpleCandidate>("beta", 0, 4, "Beta-3"));
   }
 
   bool Next() {
@@ -46,25 +46,25 @@ class TranslationBeta : public Translation {
 
   shared_ptr<Candidate> Peek() {
     if (exhausted())
-      return nullptr;
+      return shared_ptr<Candidate>();
     return candies_[cursor_];
   }
 
  private:
-  std::vector<shared_ptr<Candidate>> candies_;
+  std::vector<shared_ptr<Candidate> > candies_;
   size_t cursor_;
 };
 
 TEST(RimeMenuTest, RecipeAlphaBeta) {
   Menu menu;
-  auto alpha = New<TranslationAlpha>();
-  auto beta = New<TranslationBeta>();
+  shared_ptr<Translation> alpha = make_shared<TranslationAlpha>();
+  shared_ptr<Translation> beta = make_shared<TranslationBeta>();
   menu.AddTranslation(alpha);
   menu.AddTranslation(beta);
   // explicit call to Menu::Prepare() is not necessary
   menu.Prepare(2);
-  unique_ptr<Page> page(menu.CreatePage(5, 0));
-  ASSERT_TRUE(bool(page));
+  scoped_ptr<Page> page(menu.CreatePage(5, 0));
+  ASSERT_TRUE(page);
   EXPECT_EQ(5, page->page_size);
   EXPECT_EQ(0, page->page_no);
   EXPECT_TRUE(page->is_last_page);
@@ -74,6 +74,6 @@ TEST(RimeMenuTest, RecipeAlphaBeta) {
   EXPECT_EQ("beta", page->candidates[1]->type());
   EXPECT_EQ("Beta-1", page->candidates[1]->text());
   EXPECT_EQ("Beta-3", page->candidates[3]->text());
-  unique_ptr<Page> no_more_page(menu.CreatePage(5, 1));
-  EXPECT_FALSE(bool(no_more_page));
+  scoped_ptr<Page> no_more_page(menu.CreatePage(5, 1));
+  EXPECT_FALSE(no_more_page);
 }
diff --git a/test/prism_test.cc b/test/prism_test.cc
index c1cd14e..c43193d 100644
--- a/test/prism_test.cc
+++ b/test/prism_test.cc
@@ -37,7 +37,7 @@ class RimePrismTest : public ::testing::Test {
   virtual void TearDown() {
   }
 
-  unique_ptr<Prism> prism_;
+  scoped_ptr<Prism> prism_;
 };
 
 TEST_F(RimePrismTest, SaveAndLoad) {
diff --git a/test/rime_test_main.cc b/test/rime_test_main.cc
index 2212417..1b8fd42 100644
--- a/test/rime_test_main.cc
+++ b/test/rime_test_main.cc
@@ -1,7 +1,7 @@
 #include <gtest/gtest.h>
 #include <rime/setup.h>
 
-int main(int argc, char** argv) {
+int main(int argc, char **argv) {
   testing::InitGoogleTest(&argc, argv);
   rime::SetupLogging("rime.test");
   rime::LoadModules(rime::kDefaultModules);
diff --git a/test/segmentor_test.cc b/test/segmentor_test.cc
index b8cd251..878dc05 100644
--- a/test/segmentor_test.cc
+++ b/test/segmentor_test.cc
@@ -14,11 +14,11 @@
 using namespace rime;
 
 TEST(AbcSegmentorTest, NoMatch) {
-  Segmentor::Component* component = Segmentor::Require("abc_segmentor");
+  Segmentor::Component *component = Segmentor::Require("abc_segmentor");
   ASSERT_TRUE(component != NULL);
-  unique_ptr<Engine> engine(Engine::Create());
-  unique_ptr<Segmentor> segmentor(component->Create(engine.get()));
-  ASSERT_TRUE(bool(segmentor));
+  scoped_ptr<Engine> engine(Engine::Create());
+  scoped_ptr<Segmentor> segmentor(component->Create(engine.get()));
+  ASSERT_TRUE(segmentor);
   Segmentation segmentation;
   segmentation.Reset("3.1415926");
   bool goon = segmentor->Proceed(&segmentation);
@@ -28,11 +28,11 @@ TEST(AbcSegmentorTest, NoMatch) {
 }
 
 TEST(AbcSegmentorTest, FullMatch) {
-  Segmentor::Component* component = Segmentor::Require("abc_segmentor");
+  Segmentor::Component *component = Segmentor::Require("abc_segmentor");
   ASSERT_TRUE(component != NULL);
-  unique_ptr<Engine> engine(Engine::Create());
-  unique_ptr<Segmentor> segmentor(component->Create(engine.get()));
-  ASSERT_TRUE(bool(segmentor));
+  scoped_ptr<Engine> engine(Engine::Create());
+  scoped_ptr<Segmentor> segmentor(component->Create(engine.get()));
+  ASSERT_TRUE(segmentor);
   Segmentation segmentation;
   segmentation.Reset("zyxwvutsrqponmlkjihgfedcba");
   bool goon = segmentor->Proceed(&segmentation);
@@ -45,11 +45,11 @@ TEST(AbcSegmentorTest, FullMatch) {
 }
 
 TEST(AbcSegmentorTest, PrefixMatch) {
-  Segmentor::Component* component = Segmentor::Require("abc_segmentor");
+  Segmentor::Component *component = Segmentor::Require("abc_segmentor");
   ASSERT_TRUE(component != NULL);
-  unique_ptr<Engine> engine(Engine::Create());
-  unique_ptr<Segmentor> segmentor(component->Create(engine.get()));
-  ASSERT_TRUE(bool(segmentor));
+  scoped_ptr<Engine> engine(Engine::Create());
+  scoped_ptr<Segmentor> segmentor(component->Create(engine.get()));
+  ASSERT_TRUE(segmentor);
   Segmentation segmentation;
   segmentation.Reset("abcdefg.1415926");
   bool goon = segmentor->Proceed(&segmentation);
diff --git a/test/syllabifier_test.cc b/test/syllabifier_test.cc
index 5c3847d..5fedbd1 100644
--- a/test/syllabifier_test.cc
+++ b/test/syllabifier_test.cc
@@ -35,8 +35,7 @@ class RimeSyllabifierTest : public ::testing::Test {
 
     prism_.reset(new rime::Prism("syllabifier_test.bin"));
     std::set<std::string> keyset;
-    std::copy(syllables.begin(), syllables.end(),
-              std::inserter(keyset, keyset.begin()));
+    std::copy(syllables.begin(), syllables.end(), std::inserter(keyset, keyset.begin()));
     prism_->Build(keyset);
   }
 
@@ -45,7 +44,7 @@ class RimeSyllabifierTest : public ::testing::Test {
 
  protected:
   std::map<std::string, rime::SyllableId> syllable_id_;
-  rime::unique_ptr<rime::Prism> prism_;
+  boost::scoped_ptr<rime::Prism> prism_;
 };
 
 TEST_F(RimeSyllabifierTest, CaseAlpha) {
@@ -58,7 +57,7 @@ TEST_F(RimeSyllabifierTest, CaseAlpha) {
   EXPECT_EQ(2, g.vertices.size());
   ASSERT_FALSE(g.vertices.end() == g.vertices.find(1));
   EXPECT_EQ(rime::kNormalSpelling, g.vertices[1]);
-  rime::SpellingMap& sp(g.edges[0][1]);
+  rime::SpellingMap &sp(g.edges[0][1]);
   EXPECT_EQ(1, sp.size());
   ASSERT_FALSE(sp.end() == sp.find(syllable_id_["a"]));
   EXPECT_EQ(rime::kNormalSpelling, sp[0].type);
@@ -76,7 +75,7 @@ TEST_F(RimeSyllabifierTest, CaseFailure) {
   ASSERT_TRUE(g.vertices.end() == g.vertices.find(1));
   ASSERT_FALSE(g.vertices.end() == g.vertices.find(2));
   EXPECT_EQ(rime::kNormalSpelling, g.vertices[2]);
-  rime::SpellingMap& sp(g.edges[0][2]);
+  rime::SpellingMap &sp(g.edges[0][2]);
   EXPECT_EQ(1, sp.size());
   ASSERT_FALSE(sp.end() == sp.find(syllable_id_["an"]));
 }
@@ -96,19 +95,19 @@ TEST_F(RimeSyllabifierTest, CaseChangan) {
   EXPECT_EQ(rime::kNormalSpelling, g.vertices[4]);
   EXPECT_EQ(rime::kNormalSpelling, g.vertices[5]);
   // chan, chang but not cha
-  rime::EndVertexMap& e0(g.edges[0]);
+  rime::EndVertexMap &e0(g.edges[0]);
   EXPECT_EQ(2, e0.size());
   ASSERT_FALSE(e0.end() == e0.find(4));
   ASSERT_FALSE(e0.end() == e0.find(5));
   EXPECT_FALSE(e0[4].end() == e0[4].find(syllable_id_["chan"]));
   EXPECT_FALSE(e0[5].end() == e0[5].find(syllable_id_["chang"]));
   // gan$
-  rime::EndVertexMap& e4(g.edges[4]);
+  rime::EndVertexMap &e4(g.edges[4]);
   EXPECT_EQ(1, e4.size());
   ASSERT_FALSE(e4.end() == e4.find(7));
   EXPECT_FALSE(e4[7].end() == e4[7].find(syllable_id_["gan"]));
   // an$
-  rime::EndVertexMap& e5(g.edges[5]);
+  rime::EndVertexMap &e5(g.edges[5]);
   EXPECT_EQ(1, e5.size());
   ASSERT_FALSE(e5.end() == e5.find(7));
   EXPECT_FALSE(e5[7].end() == e5[7].find(syllable_id_["an"]));
@@ -127,14 +126,14 @@ TEST_F(RimeSyllabifierTest, CaseTuan) {
   ASSERT_FALSE(g.vertices.end() == g.vertices.find(4));
   EXPECT_EQ(rime::kAmbiguousSpelling, g.vertices[2]);
   EXPECT_EQ(rime::kNormalSpelling, g.vertices[4]);
-  rime::EndVertexMap& e0(g.edges[0]);
+  rime::EndVertexMap &e0(g.edges[0]);
   EXPECT_EQ(2, e0.size());
   ASSERT_FALSE(e0.end() == e0.find(2));
   ASSERT_FALSE(e0.end() == e0.find(4));
   EXPECT_FALSE(e0[2].end() == e0[2].find(syllable_id_["tu"]));
   EXPECT_FALSE(e0[4].end() == e0[4].find(syllable_id_["tuan"]));
   // an$
-  rime::EndVertexMap& e2(g.edges[2]);
+  rime::EndVertexMap &e2(g.edges[2]);
   EXPECT_EQ(1, e2.size());
   ASSERT_FALSE(e2.end() == e2.find(4));
   EXPECT_FALSE(e2[4].end() == e2[4].find(syllable_id_["an"]));
diff --git a/test/table_test.cc b/test/table_test.cc
index a2d2b3e..dac2aec 100644
--- a/test/table_test.cc
+++ b/test/table_test.cc
@@ -33,16 +33,17 @@ class RimeTableTest : public ::testing::Test {
   static std::string Text(const rime::TableAccessor& a) {
     return table_->GetEntryText(*a.entry());
   }
-  static rime::unique_ptr<rime::Table> table_;
+  static boost::scoped_ptr<rime::Table> table_;
 };
 
 const char RimeTableTest::file_name[] = "table_test.bin";
 
-rime::unique_ptr<rime::Table> RimeTableTest::table_;
+boost::scoped_ptr<rime::Table> RimeTableTest::table_;
 
-void RimeTableTest::PrepareSampleVocabulary(rime::Syllabary& syll,
-                                            rime::Vocabulary& voc) {
-  auto d = rime::New<rime::DictEntry>();
+void RimeTableTest::PrepareSampleVocabulary(rime::Syllabary &syll,
+                                            rime::Vocabulary &voc) {
+  boost::shared_ptr<rime::DictEntry> d;
+  d = boost::make_shared<rime::DictEntry>();
   syll.insert("0");
   // no entries for '0', however
   syll.insert("1");
@@ -50,43 +51,43 @@ void RimeTableTest::PrepareSampleVocabulary(rime::Syllabary& syll,
   d->text = "yi";
   d->weight = 1.0;
   voc[1].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   syll.insert("2");
   d->code.back() = 2;
   d->text = "er";
   voc[2].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   d->text = "liang";
   voc[2].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   d->text = "lia";
   voc[2].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   syll.insert("3");
   d->code.back() = 3;
   d->text = "san";
   voc[3].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   d->text = "sa";
   voc[3].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   syll.insert("4");
-  auto lv2 = rime::New<rime::Vocabulary>();
+  boost::shared_ptr<rime::Vocabulary> lv2 = boost::make_shared<rime::Vocabulary>();
   voc[1].next_level = lv2;
-  auto lv3 = rime::New<rime::Vocabulary>();
+  boost::shared_ptr<rime::Vocabulary> lv3 = boost::make_shared<rime::Vocabulary>();
   (*lv2)[2].next_level = lv3;
-  auto lv4 = rime::New<rime::Vocabulary>();
+  boost::shared_ptr<rime::Vocabulary> lv4 = boost::make_shared<rime::Vocabulary>();
   (*lv3)[3].next_level = lv4;
   d->code.back() = 1;
   d->code.push_back(2);
   d->code.push_back(3);
   d->text = "yi-er-san";
   (*lv3)[3].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   d->code.push_back(4);
   d->text = "yi-er-san-si";
   (*lv4)[-1].entries.push_back(d);
-  d = rime::New<rime::DictEntry>(*d);
+  d = boost::make_shared<rime::DictEntry>(*d);
   d->code.resize(3);
   d->code.push_back(2);
   d->code.push_back(1);
@@ -96,7 +97,7 @@ void RimeTableTest::PrepareSampleVocabulary(rime::Syllabary& syll,
 
 TEST_F(RimeTableTest, IntegrityTest) {
   table_.reset(new rime::Table(file_name));
-  ASSERT_TRUE(bool(table_));
+  ASSERT_TRUE(table_);
   ASSERT_TRUE(table_->Load());
 }
 
diff --git a/test/user_db_test.cc b/test/user_db_test.cc
index 0a8e6be..ef0da99 100644
--- a/test/user_db_test.cc
+++ b/test/user_db_test.cc
@@ -49,8 +49,8 @@ TEST(RimeUserDbTest, Query) {
   EXPECT_TRUE(db.Update("zyx", "ABC"));
   EXPECT_TRUE(db.Update("wvu", "DEF"));
   {
-    rime::shared_ptr<rime::DbAccessor> accessor = db.Query("abc");
-    ASSERT_TRUE(bool(accessor));
+    boost::shared_ptr<rime::DbAccessor> accessor = db.Query("abc");
+    ASSERT_TRUE(accessor);
     EXPECT_FALSE(accessor->exhausted());
     std::string key, value;
     EXPECT_TRUE(accessor->GetNextRecord(&key, &value));
@@ -67,15 +67,15 @@ TEST(RimeUserDbTest, Query) {
     // key, value contain invalid contents
   }
   {
-    rime::shared_ptr<rime::DbAccessor> accessor = db.Query("wvu\tt");
-    ASSERT_TRUE(bool(accessor));
+    boost::shared_ptr<rime::DbAccessor> accessor = db.Query("wvu\tt");
+    ASSERT_TRUE(accessor);
     EXPECT_TRUE(accessor->exhausted());
     std::string key, value;
     EXPECT_FALSE(accessor->GetNextRecord(&key, &value));
   }
   {
-    rime::shared_ptr<rime::DbAccessor> accessor = db.Query("z");
-    ASSERT_TRUE(bool(accessor));
+    boost::shared_ptr<rime::DbAccessor> accessor = db.Query("z");
+    ASSERT_TRUE(accessor);
     EXPECT_FALSE(accessor->exhausted());
     std::string key, value;
     EXPECT_TRUE(accessor->GetNextRecord(&key, &value));
diff --git a/tools/rime_console.cc b/tools/rime_console.cc
index 87cc419..cb3c8e6 100644
--- a/tools/rime_console.cc
+++ b/tools/rime_console.cc
@@ -6,6 +6,8 @@
 //
 #include <cstring>
 #include <iostream>
+#include <boost/bind.hpp>
+#include <boost/foreach.hpp>
 #include <rime/candidate.h>
 #include <rime/common.h>
 #include <rime/composition.h>
@@ -25,7 +27,7 @@ class RimeConsole {
   RimeConsole() : interactive_(false),
                   engine_(rime::Engine::Create()) {
     conn_ = engine_->sink().connect(
-        [this](const std::string& x) { OnCommit(x); });
+        boost::bind(&RimeConsole::OnCommit, this, _1));
   }
   ~RimeConsole() {
     conn_.disconnect();
@@ -53,14 +55,14 @@ class RimeConsole {
       return;
     int page_size = engine_->schema()->page_size();
     int page_no = current.selected_index / page_size;
-    rime::unique_ptr<rime::Page> page(
+    boost::scoped_ptr<rime::Page> page(
         current.menu->CreatePage(page_size, page_no));
     if (!page)
       return;
     std::cout << "page_no: " << page_no
               << ", index: " << current.selected_index << std::endl;
     int i = 0;
-    for (const rime::shared_ptr<rime::Candidate> &cand :
+    BOOST_FOREACH(const boost::shared_ptr<rime::Candidate> &cand,
                   page->candidates) {
       std::cout << "cand. " << (++i % 10) <<  ": [";
       std::cout << cand->text();
@@ -78,7 +80,7 @@ class RimeConsole {
       LOG(ERROR) << "error parsing input: '" << line << "'";
       return;
     }
-    for (const rime::KeyEvent &key : keys) {
+    BOOST_FOREACH(const rime::KeyEvent &key, keys) {
       engine_->ProcessKey(key);
     }
     rime::Context *ctx = engine_->context();
@@ -97,7 +99,7 @@ class RimeConsole {
 
  private:
   bool interactive_;
-  rime::unique_ptr<rime::Engine> engine_;
+  boost::scoped_ptr<rime::Engine> engine_;
   rime::connection conn_;
 };
 
diff --git a/tools/rime_dict_manager.cc b/tools/rime_dict_manager.cc
index 883ec4b..05eefe8 100644
--- a/tools/rime_dict_manager.cc
+++ b/tools/rime_dict_manager.cc
@@ -6,6 +6,7 @@
 //
 #include <iostream>
 #include <string>
+#include <boost/foreach.hpp>
 #include <rime/config.h>
 #include <rime/deployer.h>
 #include <rime/service.h>
@@ -49,7 +50,7 @@ int main(int argc, char *argv[]) {
       std::cerr << "no user dictionary is found." << std::endl;
       return 0;
     }
-    for (const std::string& e : list) {
+    BOOST_FOREACH(const std::string& e, list) {
       std::cout << e << std::endl;
     }
     return 0;
diff --git a/vcbuild.bat b/vcbuild.bat
index 0403ad4..df1f47c 100644
--- a/vcbuild.bat
+++ b/vcbuild.bat
@@ -60,13 +60,19 @@ rem set CURL=%RIME_ROOT%\thirdparty\bin\curl.exe
 rem set DOWNLOAD="%CURL%" --remote-name-all
 rem set GOOGLECODE_SVN=http://rimeime.googlecode.com/svn/trunk/
 
+rem TODO: select a cmake generator
+rem set CMAKE_GENERATOR="MinGW Makefiles"
+rem set CMAKE_GENERATOR="Eclipse CDT4 - MinGW Makefiles"
+rem set CMAKE_GENERATOR="Visual Studio 9 2008"
+set CMAKE_GENERATOR="Visual Studio 10"
+
 if %build_boost% == 1 (
   cd %BOOST_ROOT%
   if not exist bjam.exe call bootstrap.bat
   if %ERRORLEVEL% NEQ 0 goto ERROR
-  bjam toolset=msvc-12.0 variant=release link=static threading=multi runtime-link=static stage --with-chrono --with-date_time --with-filesystem --with-system --with-regex --with-signals --with-thread
+  bjam toolset=msvc-10.0 variant=release link=static threading=multi runtime-link=static stage --with-chrono --with-date_time --with-filesystem --with-system --with-regex --with-signals --with-thread
   if %ERRORLEVEL% NEQ 0 goto ERROR
-  bjam toolset=msvc-12.0 variant=release link=static threading=multi runtime-link=static address-model=64 --stagedir=stage_x64 stage --with-chrono --with-date_time --with-filesystem --with-system --with-regex --with-signals --with-thread
+  bjam toolset=msvc-10.0 variant=release link=static threading=multi runtime-link=static address-model=64 --stagedir=stage_x64 stage --with-chrono --with-date_time --with-filesystem --with-system --with-regex --with-signals --with-thread
   if %ERRORLEVEL% NEQ 0 goto ERROR
 )
 
@@ -74,7 +80,7 @@ if %build_thirdparty% == 1 (
   echo building glog.
   cd "%RIME_ROOT%"\thirdparty\src\glog
   rem devenv google-glog-vc10.sln /build "Release"
-  msbuild.exe google-glog-vc12.sln /p:Configuration=Release
+  msbuild.exe google-glog-vc10.sln /p:Configuration=Release
   if %ERRORLEVEL% NEQ 0 goto ERROR
   echo built. copying artifacts.
   xcopy /S /I /Y src\windows\glog "%RIME_ROOT%"\thirdparty\include\glog\
@@ -86,9 +92,9 @@ if %build_thirdparty% == 1 (
 
   echo building kyotocabinet.
   cd "%RIME_ROOT%"\thirdparty\src\kyotocabinet
-  nmake -f VC12makefile
+  nmake -f VCmakefile
   if %ERRORLEVEL% NEQ 0 goto ERROR
-  nmake -f VC12makefile binpkg
+  nmake -f VCmakefile binpkg
   if %ERRORLEVEL% NEQ 0 goto ERROR
   echo built. copying artifacts.
   copy /Y output\include\*.h "%RIME_ROOT%"\thirdparty\include\
@@ -102,7 +108,7 @@ if %build_thirdparty% == 1 (
   cd "%RIME_ROOT%"\thirdparty\src\yaml-cpp
   if not exist build mkdir build
   cd build
-  cmake -DMSVC_SHARED_RT=OFF ..
+  cmake -G %CMAKE_GENERATOR% -DMSVC_SHARED_RT=OFF ..
   if %ERRORLEVEL% NEQ 0 goto ERROR
   rem devenv YAML_CPP.sln /build "Release"
   msbuild.exe YAML_CPP.sln /p:Configuration=Release
@@ -117,7 +123,7 @@ if %build_thirdparty% == 1 (
   cd "%RIME_ROOT%"\thirdparty\src\gtest
   if not exist build mkdir build
   cd build
-  cmake ..
+  cmake -G %CMAKE_GENERATOR% ..
   if %ERRORLEVEL% NEQ 0 goto ERROR
   rem devenv gtest.sln /build "Release"
   msbuild.exe gtest.sln /p:Configuration=Release
@@ -129,8 +135,8 @@ if %build_thirdparty% == 1 (
   if %ERRORLEVEL% NEQ 0 goto ERROR
 
   echo building marisa.
-  cd "%RIME_ROOT%"\thirdparty\src\marisa-trie\vs2013
-  msbuild.exe vs2013.sln /p:Configuration=Release
+  cd "%RIME_ROOT%"\thirdparty\src\marisa-trie\vs2010
+  msbuild.exe vs2010.sln /p:Configuration=Release
   if %ERRORLEVEL% NEQ 0 goto ERROR
   echo built. copying artifacts.
   xcopy /S /I /Y ..\lib\marisa "%RIME_ROOT%"\thirdparty\include\marisa\
@@ -171,12 +177,6 @@ if %build_thirdparty% == 1 (
 
 if %build_librime% == 0 goto EXIT
 
-rem TODO: select a cmake generator
-rem set CMAKE_GENERATOR="MinGW Makefiles"
-rem set CMAKE_GENERATOR="Eclipse CDT4 - MinGW Makefiles"
-rem set CMAKE_GENERATOR="Visual Studio 9 2008"
-set CMAKE_GENERATOR="Visual Studio 12"
-
 set BUILD_DIR=%RIME_ROOT%\%build%
 if not exist %BUILD_DIR% mkdir %BUILD_DIR%
 
